<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Andre's Blog</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Blog</a>
            </div>
            <div id="navigation">
                <a href="../../">Home</a>
                <a href="../../contact.html">Contact</a>
                <!-- <a href="/about.html">About</a> -->
            </div>
        </div>

        <div id="content">
            <h1><a href="#top">Haskell roguelike - Utility AI annotations</a></h1>

            <div class="info">
    Posted on April  2, 2018
    
</div>

<p><a href="../2018-04-02-haskell-rogue-like.html">start</a> <a href="2018-04-02-haskell-rogue-like_13.html">prev</a> <a href="2018-04-02-haskell-rogue-like_15.html">next</a></p>
<h1 id="understanding-utility-system-decisions">Understanding utility system decisions</h1>
<p>You can often graph your utility functions to see and design how they interact. This is major benefit as you can quickly visualise complex behaviour. Sometimes you may also want to have a trace of how the utilities scored at runtime. Typically this would only be needed during the early development phase.</p>
<p>This chapter shows one way that you can add annotations to the utility system using the writer monad. This is entirely optional. You can skip this section if you don’t need this feature or if you don’t want to use <em>Writer</em>.</p>
<h2 id="writer-not-logging">Writer, not logging</h2>
<p>Instead of using <em>Writer</em> you could use one of the logging packages (<a href="https://hackage.haskell.org/package/di">di</a> etc). What I’m wanting to do here fits much better with a Writer than a logger though. I’m only interested in what actually gets selected and if the system crashes I don’t care that the writer state gets lost. I specifically just want an annotated result only for the selected world, not all speculatively executed ones. If however you do want logs then definitely don’t use <em>Writer</em>.</p>
<p>Skip this chapter if you do not need the annotations or are not comfortable with the writer monad.</p>
<h1 id="annotations">Annotations</h1>
<h2 id="writer">Writer</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Data.DList</span> (<span class="dt">DList</span>)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">import</span> <span class="dt">Control.Monad.Writer.Strict</span> (<span class="dt">Writer</span>)</a></code></pre></div>
<p>I’m using a strict writer to try avoid space leak issues, and <a href="https://hackage.haskell.org/package/dlist">Data.DList</a> which provides O(1) appending.</p>
<h2 id="annotation-entries">Annotation entries</h2>
<p>Lets use a sum type to define the type of annotations we will be adding</p>
<h6 id="utility_annotatesrcgamecore.hs-127-to-132">14_utility_annotate/src/GameCore.hs (127 to 132)</h6>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">UtilAnnotationEntry</span> <span class="fu">=</span> <span class="dt">UeAt</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-2" title="2">                         <span class="fu">|</span> <span class="dt">UeSelectTopNone</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-3" title="3">                         <span class="fu">|</span> <span class="dt">UeSelectTopAbove</span> <span class="dt">Float</span> </a>
<a class="sourceLine" id="cb2-4" title="4">                         <span class="fu">|</span> <span class="dt">UeSelectTopOne</span> <span class="dt">Float</span> <span class="dt">Text</span> <span class="dt">Impulse</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-5" title="5">                         <span class="fu">|</span> <span class="dt">UeNote</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-6" title="6">                         <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>This gives us the type of the annotator</p>
<h6 id="utility_annotatesrcgamecore.hs-30-to-30">14_utility_annotate/src/GameCore.hs (30 to 30)</h6>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">type</span> <span class="dt">UtilAnnotator</span> m <span class="fu">=</span> <span class="dt">Writer</span> (<span class="dt">DList</span> <span class="dt">UtilAnnotationEntry</span>) m</a></code></pre></div>
<h2 id="storing-the-annotations">Storing the annotations</h2>
<p>The actor’s utilities need to use the annotator.</p>
<h6 id="utility_annotatesrcgamecore.hs-50-to-50">14_utility_annotate/src/GameCore.hs (50 to 50)</h6>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">  ,<span class="ot"> _acUtilities ::</span> <span class="fu">!</span>[<span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> <span class="dt">UtilAnnotator</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)]</a></code></pre></div>
<p>The world gets a property in which the latest annotations can be stored. This way its possible to get the annotations and display them to the user (e.g. print to the console)</p>
<h6 id="utility_annotatesrcgamecore.hs-72-to-72">14_utility_annotate/src/GameCore.hs (72 to 72)</h6>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">  ,<span class="ot"> _wdUtilBrainAnnotations ::</span> <span class="fu">!</span>[(<span class="dt">E.EntityType</span>, [<span class="dt">UtilAnnotationEntry</span>], [<span class="dt">UtilAnnotationEntry</span>])]</a></code></pre></div>
<h2 id="annotations-in-the-utility-brain">Annotations in the utility brain</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.DList</span> <span class="kw">as</span> <span class="dt">DLst</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">import</span>           <span class="dt">Control.Monad.Writer.Strict</span> (tell, <span class="dt">MonadWriter</span>)</a></code></pre></div>
<p><em>telld</em> is a helper that calls <em>Data.Monad.Writer.Strict.tell</em> with a single DList element.</p>
<h6 id="utility_annotatesrcutilitybrain.hs-28-to-29">14_utility_annotate/src/UtilityBrain.hs (28 to 29)</h6>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">telld ::</span> <span class="dt">MonadWriter</span> (<span class="dt">DLst.DList</span> a) m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb7-2" title="2">telld t <span class="fu">=</span> tell (DLst.singleton t)</a></code></pre></div>
<p>The utility brain functions are then changed to return a <code>UtilAnnotator a</code> where <code>a</code> was whatever they were returning before. These changes are not terribly interesting so I’ll only show one of them. See the diff below to see the others</p>
<h6 id="utility_annotatesrcutilitybrain.hs-151-to-162">14_utility_annotate/src/UtilityBrain.hs (151 to 162)</h6>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">utilityOfInfatuation ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> <span class="dt">UtilAnnotator</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)</a>
<a class="sourceLine" id="cb8-2" title="2">utilityOfInfatuation world actor allPaths <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" title="3">  telld <span class="fu">.</span> <span class="dt">UeAt</span> <span class="fu">$</span> <span class="st">&quot;Infatuation: &quot;</span> <span class="fu">&lt;&gt;</span> <span class="fu">show</span> (<span class="fu">length</span> allPaths) <span class="co">-- debugShowPathTos allPaths --show (actor ^. acDisposition ^. dsSmitten)</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="kw">let</span> rule x <span class="fu">=</span> clamp <span class="fu">$</span> <span class="fu">-</span>x <span class="fu">**</span> <span class="dv">4</span> <span class="fu">+</span> clamp (actor <span class="fu">^.</span> acDisposition <span class="fu">^.</span> dsSmitten) </a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="kw">let</span> clampedResults <span class="fu">=</span> moveTowardsUtil (actor <span class="fu">^.</span> acDisposition <span class="fu">^.</span> dsSmittenWith) rule allPaths actor</a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="kw">let</span> (r, _) <span class="fu">=</span> ((\(p, score) <span class="ot">-&gt;</span> (score, actor, <span class="dt">ImpMoveTowards</span> (path p), <span class="st">&quot;infatuation&quot;</span>, <span class="dt">Just</span> p)) <span class="fu">&lt;$&gt;</span> clampedResults, world)</a>
<a class="sourceLine" id="cb8-9" title="9">  <span class="kw">let</span> r2 <span class="fu">=</span> (\(f, _, _, _, _) <span class="ot">-&gt;</span> showF f) <span class="fu">&lt;$&gt;</span> r</a>
<a class="sourceLine" id="cb8-10" title="10">  telld <span class="fu">.</span> <span class="dt">UeNote</span> <span class="fu">$</span> <span class="st">&quot;infatuation: &quot;</span> <span class="fu">&lt;&gt;</span> <span class="fu">show</span> r2</a>
<a class="sourceLine" id="cb8-11" title="11">  </a>
<a class="sourceLine" id="cb8-12" title="12">  <span class="fu">pure</span> ((\(p, score) <span class="ot">-&gt;</span> (score, actor, <span class="dt">ImpMoveTowards</span> (path p), <span class="st">&quot;infatuation&quot;</span>, <span class="dt">Just</span> p)) <span class="fu">&lt;$&gt;</span> clampedResults, world)</a></code></pre></div>
<ul>
<li>Add a <em>UeAt</em> annotation to show that infatuation was evaulated</li>
<li>Add a <em>UeNote</em> annotation to show the calculated score</li>
</ul>
<p><em>assessUtilities</em> has to change from using <code>fold'</code> to <code>foldM</code> as we are now folding over the <em>Writer</em> monad results.</p>
<h6 id="utility_annotatesrcutilitybrain.hs-72-to-82">14_utility_annotate/src/UtilityBrain.hs (72 to 82)</h6>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">assessUtilities ::</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> <span class="dt">UtilAnnotator</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)</a>
<a class="sourceLine" id="cb9-2" title="2">assessUtilities paths world actor <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" title="3">  (rs, wNext) <span class="ot">&lt;-</span> foldM assess ([], world) (actor <span class="fu">^.</span> acUtilities)</a>
<a class="sourceLine" id="cb9-4" title="4">  ranked <span class="ot">&lt;-</span> rankUtility rs</a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="fu">pure</span> (ranked, wNext)</a>
<a class="sourceLine" id="cb9-6" title="6">  </a>
<a class="sourceLine" id="cb9-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" title="8">    assess (hist, w) u <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-9" title="9">      <span class="kw">let</span> a <span class="fu">=</span> fromMaybe actor <span class="fu">$</span> w <span class="fu">^.</span> wdActors <span class="fu">^.</span>at (actor <span class="fu">^.</span> acId) </a>
<a class="sourceLine" id="cb9-10" title="10">      (rs, wNext) <span class="ot">&lt;-</span> u w a paths</a>
<a class="sourceLine" id="cb9-11" title="11">      <span class="fu">pure</span> (hist <span class="fu">&lt;&gt;</span> rs, wNext)</a></code></pre></div>
<h2 id="calling-the-annotated-utility-brain">Calling the annotated utility brain</h2>
<p><em>moveAllNonPlayers</em> in <em>playerMoving</em> is changed to get annotated results from <em>assessUtilities</em> and <em>selectTopUtility</em>.</p>
<h6 id="utility_annotatesrcgameengine.hs-797-to-802">14_utility_annotate/src/GameEngine.hs (797 to 802)</h6>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">  moveAllNonPlayers w <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-2" title="2">    <span class="kw">let</span> mv aOrig wOrig <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-3" title="3">          <span class="kw">let</span></a>
<a class="sourceLine" id="cb10-4" title="4">            inFov <span class="fu">=</span> findPathToAllInFov wOrig aOrig </a>
<a class="sourceLine" id="cb10-5" title="5">            ((utilities, wNext), annAssess) <span class="fu">=</span> runWriter <span class="fu">$</span> UB.assessUtilities inFov wOrig aOrig </a>
<a class="sourceLine" id="cb10-6" title="6">            (topUtil, annTop) <span class="fu">=</span> runWriter <span class="fu">$</span> UB.selectTopUtility utilities</a></code></pre></div>
<p>Then the annotations are added the selected world using <em>addAnn</em> which is a helper that adds the <em>annotation</em> to the world’s *wdUtilBrainAnnotations)</p>
<h6 id="utility_annotatesrcgameengine.hs-805-to-823">14_utility_annotate/src/GameEngine.hs (805 to 823)</h6>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">              annotation <span class="fu">=</span> (aOrig <span class="fu">^.</span> acEntity <span class="fu">^.</span> enType, DLst.toList annAssess, DLst.toList annTop)</a>
<a class="sourceLine" id="cb11-2" title="2">              addAnn w' <span class="fu">=</span> w' <span class="fu">&amp;</span> wdUtilBrainAnnotations <span class="fu">%~</span> (annotation <span class="fu">:</span>)</a>
<a class="sourceLine" id="cb11-3" title="3">            <span class="kw">in</span></a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5">            <span class="kw">case</span> topUtil <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-6" title="6">              <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-7" title="7">                <span class="co">-- No utility = no move, skip</span></a>
<a class="sourceLine" id="cb11-8" title="8">                updateActorById (addAnn wNext) (aOrig <span class="fu">^.</span> acId) (\a <span class="ot">-&gt;</span> a <span class="fu">&amp;</span> acSkipMove <span class="fu">.~</span> <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb11-9" title="9"></a>
<a class="sourceLine" id="cb11-10" title="10">              <span class="dt">Just</span> (_, actorIfMoved, action, _, _) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-11" title="11">                <span class="kw">let</span> cost <span class="fu">=</span> <span class="fu">floor</span> <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> aOrig <span class="fu">^.</span> acMoveEnergyCost <span class="kw">in</span></a>
<a class="sourceLine" id="cb11-12" title="12">                </a>
<a class="sourceLine" id="cb11-13" title="13">                <span class="kw">if</span> cost <span class="fu">&gt;</span> B.get (aOrig <span class="fu">^.</span> acEnergy)</a>
<a class="sourceLine" id="cb11-14" title="14">                <span class="kw">then</span></a>
<a class="sourceLine" id="cb11-15" title="15">                  <span class="co">-- Not enough energy to move, disallow. Set skipMove = True so this is not attempted again before</span></a>
<a class="sourceLine" id="cb11-16" title="16">                  <span class="co">-- the next actor move (i.e. avoid looping)</span></a>
<a class="sourceLine" id="cb11-17" title="17">                  wNext <span class="fu">&amp;</span> wdActors <span class="fu">%~</span> Map.insert (aOrig <span class="fu">^.</span> acId) (aOrig <span class="fu">&amp;</span> acSkipMove <span class="fu">.~</span> <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb11-18" title="18">                <span class="kw">else</span></a>
<a class="sourceLine" id="cb11-19" title="19">                  actOnImpulse cost (addAnn wNext) actorIfMoved action</a></code></pre></div>
<h1 id="printing-the-results">Printing the results</h1>
<p>Printing the annotations to the console has worked well enough for my testing. You also could send it to the UI and display in a nicer format if you wanted.</p>
<p><em>runCmd</em> gets the current annotations, clears the history and prints them</p>
<h6 id="utility_annotatesrcgameengine.hs-216-to-256">14_utility_annotate/src/GameEngine.hs (216 to 256)</h6>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">      <span class="kw">let</span> annotations <span class="fu">=</span> w2 <span class="fu">^.</span> wdUtilBrainAnnotations </a>
<a class="sourceLine" id="cb12-2" title="2">      atomically <span class="fu">$</span> modifyTVar' worldV (\w <span class="ot">-&gt;</span> w <span class="fu">&amp;</span> wdUtilBrainAnnotations <span class="fu">.~</span> [])</a>
<a class="sourceLine" id="cb12-3" title="3">      printAnnotations annotations</a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5">      <span class="co">-- Draw</span></a>
<a class="sourceLine" id="cb12-6" title="6">      drawAndSend w2</a>
<a class="sourceLine" id="cb12-7" title="7"></a>
<a class="sourceLine" id="cb12-8" title="8">    _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-9" title="9">      sendError conn <span class="fu">$</span> <span class="st">&quot;Unknown command: &quot;</span> <span class="fu">&lt;&gt;</span> cmd</a>
<a class="sourceLine" id="cb12-10" title="10"></a>
<a class="sourceLine" id="cb12-11" title="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-12" title="12">    updatePlayer f <span class="fu">=</span> atomically <span class="fu">$</span> modifyTVar' worldV (\w <span class="ot">-&gt;</span> w <span class="fu">&amp;</span> wdPlayer <span class="fu">%~</span> f)</a>
<a class="sourceLine" id="cb12-13" title="13"></a>
<a class="sourceLine" id="cb12-14" title="14">    printAnnotations as <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-15" title="15">      putText <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb12-16" title="16">      putText <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb12-17" title="17">      putText <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb12-18" title="18">      putText <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb12-19" title="19">      putText <span class="st">&quot;***** Utility Annotations **************&quot;</span></a>
<a class="sourceLine" id="cb12-20" title="20">      traverse_ printAnnotation as</a>
<a class="sourceLine" id="cb12-21" title="21">      putText <span class="st">&quot;****************************************&quot;</span></a>
<a class="sourceLine" id="cb12-22" title="22">      putText <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb12-23" title="23"></a>
<a class="sourceLine" id="cb12-24" title="24">    printAnnotation (e, assess, top)  <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-25" title="25">      putText <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb12-26" title="26">      putText <span class="fu">$</span> <span class="st">&quot;-----------------------&quot;</span> <span class="fu">&lt;&gt;</span> <span class="fu">show</span> e</a>
<a class="sourceLine" id="cb12-27" title="27">      putText <span class="st">&quot;  -- assess --&quot;</span></a>
<a class="sourceLine" id="cb12-28" title="28">      putText <span class="fu">.</span> Txt.intercalate <span class="st">&quot;\n&quot;</span> <span class="fu">$</span> showEntries <span class="fu">&lt;$&gt;</span> assess</a>
<a class="sourceLine" id="cb12-29" title="29">      putText <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb12-30" title="30">      putText <span class="st">&quot;  -- top --&quot;</span></a>
<a class="sourceLine" id="cb12-31" title="31">      putText <span class="fu">.</span> Txt.intercalate <span class="st">&quot;\n&quot;</span> <span class="fu">$</span> showEntries <span class="fu">&lt;$&gt;</span> top</a>
<a class="sourceLine" id="cb12-32" title="32">      putText <span class="st">&quot;-----------------------&quot;</span></a>
<a class="sourceLine" id="cb12-33" title="33"></a>
<a class="sourceLine" id="cb12-34" title="34"><span class="ot">    showEntries ::</span> <span class="dt">UtilAnnotationEntry</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb12-35" title="35">    showEntries e <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-36" title="36">      <span class="kw">case</span> e <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-37" title="37">        <span class="dt">UeAt</span> a <span class="ot">-&gt;</span> <span class="st">&quot;    At: &quot;</span> <span class="fu">&lt;&gt;</span> a</a>
<a class="sourceLine" id="cb12-38" title="38">        <span class="dt">UeSelectTopNone</span> n <span class="ot">-&gt;</span> <span class="st">&quot;    No utils: &quot;</span> <span class="fu">&lt;&gt;</span> n</a>
<a class="sourceLine" id="cb12-39" title="39">        <span class="dt">UeSelectTopAbove</span> f  <span class="ot">-&gt;</span> <span class="st">&quot;    Top above: &quot;</span> <span class="fu">&lt;&gt;</span> showF f</a>
<a class="sourceLine" id="cb12-40" title="40">        <span class="dt">UeSelectTopOne</span> val n i d <span class="ot">-&gt;</span> <span class="st">&quot;    Select top one: &quot;</span> <span class="fu">&lt;&gt;</span> n <span class="fu">&lt;&gt;</span> <span class="st">&quot;, impulse=&quot;</span> <span class="fu">&lt;&gt;</span> <span class="fu">show</span> i <span class="fu">&lt;&gt;</span> <span class="st">&quot;, score=&quot;</span> <span class="fu">&lt;&gt;</span> showF val <span class="fu">&lt;&gt;</span> <span class="st">&quot;,&quot;</span> <span class="fu">&lt;&gt;</span> d</a>
<a class="sourceLine" id="cb12-41" title="41">        <span class="dt">UeNote</span> n <span class="ot">-&gt;</span> <span class="st">&quot;    Note: &quot;</span> <span class="fu">&lt;&gt;</span> n</a></code></pre></div>
<p>Here is an example of what the output will look like</p>
<pre class="text"><code>***** Utility Annotations **************                              
                                                                      
-----------------------Snake                                          
  -- assess --                                                        
    At: Wander                                                        
    At: WanderToExit                                                  
                                                                      
  -- top --                                                           
    At: select top                                                    
    Top above: 0.07                                                   
    Select top one: wander, impulse=ImpMoveRandom, score=0.07,selected
-----------------------                                               
****************************************                              </code></pre>
<h1 id="chapters">Chapters</h1>
<p><a href="../2018-04-02-haskell-rogue-like.html">start</a> <a href="2018-04-02-haskell-rogue-like_13.html">prev</a> <a href="2018-04-02-haskell-rogue-like_15.html">next</a></p>
<h1 id="changes">Changes</h1>
<div class="wrapper">
<h2 class=".diffh2">
src/GameCore.hs
</h2>
<div class="file-diff">
<pre class="diffpre difffile">diff -w -B -a -d -u -b --new-file 13_utility/src/GameCore.hs 14_utility_annotate/src/GameCore.hs</pre>
<pre class="diffpre delete">--- 13_utility/src/GameCore.hs</pre>
<pre class="diffpre insert">+++ 14_utility_annotate/src/GameCore.hs</pre>
<pre class="diffpre info">@@ -8,11 +8,14 @@</pre>
<pre class="diffpre context"> module GameCore where</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> import           Protolude hiding (Map)</pre>
<pre class="diffpre insert">+import qualified Numeric as Num</pre>
<pre class="diffpre context"> import qualified Data.Text as Txt</pre>
<pre class="diffpre context"> import           Data.Map.Strict (Map)</pre>
<pre class="diffpre insert">+import           Data.DList (DList)</pre>
<pre class="diffpre context"> import qualified Data.Aeson as Ae</pre>
<pre class="diffpre context"> import qualified System.Random as Rnd</pre>
<pre class="diffpre context"> import           Control.Lens.TH (makeLenses)</pre>
<pre class="diffpre insert">+import           Control.Monad.Writer.Strict (Writer)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> import qualified GameHost as Host</pre>
<pre class="diffpre context"> import qualified EntityType as E</pre>
<pre class="diffpre info">@@ -24,6 +27,9 @@</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> newtype Aid = Aid Text deriving (Show, Eq, Ord)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+type UtilAnnotator m = Writer (DList UtilAnnotationEntry) m</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context"> data Actor = Actor { _acId :: !Aid</pre>
<pre class="diffpre context">                    , _acClass :: !ActorClass</pre>
<pre class="diffpre context">                    , _acEntity :: !Entity</pre>
<pre class="diffpre info">@@ -36,12 +42,13 @@</pre>
<pre class="diffpre context">                    , _acMoveEnergyCost :: !Int</pre>
<pre class="diffpre context">                    , _acSkipMove :: !Bool</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context">                    -- | List of utilities in order of execution</pre>
<pre class="diffpre context">                    --    Note that the world is threaded through the utilities and can be updated (i.e. in the ([], World) result)</pre>
<pre class="diffpre context">                    --    The array of results has an updated actor and a score. These are speculative, and are only applied</pre>
<pre class="diffpre context">                    --    if that utility is selected. The world updates are kept even if nothing is selected</pre>
<pre class="diffpre delete">-                   , _acUtilities :: ![World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)]</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+                   , _acUtilities :: ![World -&gt; Actor -&gt; [PathTo] -&gt; UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)]</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">                    </pre>
<pre class="diffpre context">                    -- | The actor's disposition - the values that define the actors personality</pre>
<pre class="diffpre context">                    , _acDisposition :: !Disposition</pre>
<pre class="diffpre info">@@ -62,6 +68,9 @@</pre>
<pre class="diffpre context">                    , _wdActors :: !(Map Aid Actor)</pre>
<pre class="diffpre context">                    , _wdMinMoveEnergy :: !Int   -- ^ min energy required before any more, regardless of cost, can be attempted</pre>
<pre class="diffpre context">                    , _wdEnergyIncrements :: !Int -- ^ amount of energy that is added per game loop</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+                   , _wdUtilBrainAnnotations :: ![(E.EntityType, [UtilAnnotationEntry], [UtilAnnotationEntry])]</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">                    }</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> data Config = Config { _cfgKeys :: !(Map Text Text)</pre>
<pre class="diffpre info">@@ -107,18 +113,23 @@</pre>
<pre class="diffpre context">             | PathToActor Path Actor WorldPos</pre>
<pre class="diffpre context">             | PathToPlayer Path Player WorldPos</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context"> data Impulse = ImpMoveTowards Path</pre>
<pre class="diffpre context">              | ImpMoveRandom</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre insert">+             deriving (Show)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> data Disposition = Disposition { _dsSmitten :: Float</pre>
<pre class="diffpre context">                                , _dsWanderlust :: Float</pre>
<pre class="diffpre context">                                , _dsWanderlustToExits :: Float</pre>
<pre class="diffpre context">                                , _dsSmittenWith :: [E.EntityType]</pre>
<pre class="diffpre delete">-                               } </pre>
<pre class="diffpre insert">+                               } deriving (Show)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+data UtilAnnotationEntry = UeAt Text</pre>
<pre class="diffpre insert">+                         | UeSelectTopNone Text</pre>
<pre class="diffpre insert">+                         | UeSelectTopAbove Float </pre>
<pre class="diffpre insert">+                         | UeSelectTopOne Float Text Impulse Text</pre>
<pre class="diffpre insert">+                         | UeNote Text</pre>
<pre class="diffpre insert">+                         deriving (Show)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> ----------------------------------------------------------------------------------------</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre info">@@ -179,6 +190,9 @@</pre>
<pre class="diffpre context">     mkLower t = Txt.toLower (Txt.take 1 t) &lt;&gt; Txt.drop 1 t</pre>
<pre class="diffpre context"> ----------------------------------------------------------------------------------------</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+showF :: Float -&gt; Text</pre>
<pre class="diffpre insert">+showF x = Txt.pack $ Num.showFFloat (Just 2) x ""</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context"> makeLenses ''World</pre>
<pre class="diffpre context"> makeLenses ''Config</pre>
<pre class="diffpre context"> makeLenses ''Player</pre>
</div>
<h2 class=".diffh2">
src/GameEngine.hs
</h2>
<div class="file-diff">
<pre class="diffpre difffile">diff -w -B -a -d -u -b --new-file 13_utility/src/GameEngine.hs 14_utility_annotate/src/GameEngine.hs</pre>
<pre class="diffpre delete">--- 13_utility/src/GameEngine.hs</pre>
<pre class="diffpre insert">+++ 14_utility_annotate/src/GameEngine.hs</pre>
<pre class="diffpre info">@@ -11,6 +11,7 @@</pre>
<pre class="diffpre context"> import qualified Data.Map.Strict as Map</pre>
<pre class="diffpre context"> import qualified Data.List as Lst</pre>
<pre class="diffpre context"> import qualified Data.List.Index as Lst</pre>
<pre class="diffpre insert">+import qualified Data.DList as DLst</pre>
<pre class="diffpre context"> import qualified Data.Text as Txt</pre>
<pre class="diffpre context"> import qualified Data.Text.IO as Txt</pre>
<pre class="diffpre context"> import qualified Data.Text.Encoding as TxtE</pre>
<pre class="diffpre info">@@ -20,6 +21,7 @@</pre>
<pre class="diffpre context"> import qualified System.Random as Rnd</pre>
<pre class="diffpre context"> import           Control.Lens (at, _1, (^.), (.~), (%~))</pre>
<pre class="diffpre context"> import qualified Control.Arrow as Ar</pre>
<pre class="diffpre insert">+import           Control.Monad.Writer.Strict (runWriter)</pre>
<pre class="diffpre context"> import           Control.Concurrent.STM (atomically, readTVar, newTVar, modifyTVar', TVar)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> import           GameCore</pre>
<pre class="diffpre info">@@ -107,6 +109,7 @@</pre>
<pre class="diffpre context">                                           ]</pre>
<pre class="diffpre context">                , _wdMinMoveEnergy = 100</pre>
<pre class="diffpre context">                , _wdEnergyIncrements = 20</pre>
<pre class="diffpre insert">+               , _wdUtilBrainAnnotations = []</pre>
<pre class="diffpre context">                }</pre>
<pre class="diffpre context">   in</pre>
<pre class="diffpre context">   -- Calculate the actors fov</pre>
<pre class="diffpre info">@@ -205,6 +208,15 @@</pre>
<pre class="diffpre context">                                       )</pre>
<pre class="diffpre context">       -- Get the updated world</pre>
<pre class="diffpre context">       w2 &lt;- atomically $ readTVar worldV</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      -- Handle the annotations</pre>
<pre class="diffpre insert">+      -- This is not terribly pretty as its doing a select for update, but its good enough for debugging</pre>
<pre class="diffpre insert">+      -- the annotation code can be removed once everything is working</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      let annotations = w2 ^. wdUtilBrainAnnotations </pre>
<pre class="diffpre insert">+      atomically $ modifyTVar' worldV (\w -&gt; w &amp; wdUtilBrainAnnotations .~ [])</pre>
<pre class="diffpre insert">+      printAnnotations annotations</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">       -- Draw</pre>
<pre class="diffpre context">       drawAndSend w2</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre info">@@ -214,6 +226,36 @@</pre>
<pre class="diffpre context">   where</pre>
<pre class="diffpre context">     updatePlayer f = atomically $ modifyTVar' worldV (\w -&gt; w &amp; wdPlayer %~ f)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+    printAnnotations as = do</pre>
<pre class="diffpre insert">+      putText ""</pre>
<pre class="diffpre insert">+      putText ""</pre>
<pre class="diffpre insert">+      putText ""</pre>
<pre class="diffpre insert">+      putText ""</pre>
<pre class="diffpre insert">+      putText "***** Utility Annotations **************"</pre>
<pre class="diffpre insert">+      traverse_ printAnnotation as</pre>
<pre class="diffpre insert">+      putText "****************************************"</pre>
<pre class="diffpre insert">+      putText ""</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+    printAnnotation (e, assess, top)  = do</pre>
<pre class="diffpre insert">+      putText ""</pre>
<pre class="diffpre insert">+      putText $ "-----------------------" &lt;&gt; show e</pre>
<pre class="diffpre insert">+      putText "  -- assess --"</pre>
<pre class="diffpre insert">+      putText . Txt.intercalate "\n" $ showEntries &lt;$&gt; assess</pre>
<pre class="diffpre insert">+      putText ""</pre>
<pre class="diffpre insert">+      putText "  -- top --"</pre>
<pre class="diffpre insert">+      putText . Txt.intercalate "\n" $ showEntries &lt;$&gt; top</pre>
<pre class="diffpre insert">+      putText "-----------------------"</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+    showEntries :: UtilAnnotationEntry -&gt; Text</pre>
<pre class="diffpre insert">+    showEntries e =</pre>
<pre class="diffpre insert">+      case e of</pre>
<pre class="diffpre insert">+        UeAt a -&gt; "    At: " &lt;&gt; a</pre>
<pre class="diffpre insert">+        UeSelectTopNone n -&gt; "    No utils: " &lt;&gt; n</pre>
<pre class="diffpre insert">+        UeSelectTopAbove f  -&gt; "    Top above: " &lt;&gt; showF f</pre>
<pre class="diffpre insert">+        UeSelectTopOne val n i d -&gt; "    Select top one: " &lt;&gt; n &lt;&gt; ", impulse=" &lt;&gt; show i &lt;&gt; ", score=" &lt;&gt; showF val &lt;&gt; "," &lt;&gt; d</pre>
<pre class="diffpre insert">+        UeNote n -&gt; "    Note: " &lt;&gt; n</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">   </pre>
<pre class="diffpre context"> sendLog :: Host.Connection -&gt; Text -&gt; IO ()</pre>
<pre class="diffpre context"> sendLog conn err =</pre>
<pre class="diffpre info">@@ -756,13 +798,18 @@</pre>
<pre class="diffpre context">       let mv aOrig wOrig =</pre>
<pre class="diffpre context">             let</pre>
<pre class="diffpre context">               inFov = findPathToAllInFov wOrig aOrig </pre>
<pre class="diffpre delete">-              (utilities, wNext) = UB.assessUtilities inFov wOrig aOrig </pre>
<pre class="diffpre insert">+              ((utilities, wNext), annAssess) = runWriter $ UB.assessUtilities inFov wOrig aOrig </pre>
<pre class="diffpre insert">+              (topUtil, annTop) = runWriter $ UB.selectTopUtility utilities</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+              annotation = (aOrig ^. acEntity ^. enType, DLst.toList annAssess, DLst.toList annTop)</pre>
<pre class="diffpre insert">+              addAnn w' = w' &amp; wdUtilBrainAnnotations %~ (annotation :)</pre>
<pre class="diffpre context">             in</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-            case UB.selectTopUtility utilities of</pre>
<pre class="diffpre insert">+            case topUtil of</pre>
<pre class="diffpre context">               Nothing -&gt;</pre>
<pre class="diffpre context">                 -- No utility = no move, skip</pre>
<pre class="diffpre delete">-                updateActorById wNext (aOrig ^. acId) (\a -&gt; a &amp; acSkipMove .~ True)</pre>
<pre class="diffpre insert">+                updateActorById (addAnn wNext) (aOrig ^. acId) (\a -&gt; a &amp; acSkipMove .~ True)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context">               Just (_, actorIfMoved, action, _, _) -&gt;</pre>
<pre class="diffpre context">                 let cost = floor . fromIntegral $ aOrig ^. acMoveEnergyCost in</pre>
<pre class="diffpre info">@@ -773,7 +820,8 @@</pre>
<pre class="diffpre context">                   -- the next actor move (i.e. avoid looping)</pre>
<pre class="diffpre context">                   wNext &amp; wdActors %~ Map.insert (aOrig ^. acId) (aOrig &amp; acSkipMove .~ True)</pre>
<pre class="diffpre context">                 else</pre>
<pre class="diffpre delete">-                  actOnImpulse cost wNext actorIfMoved action</pre>
<pre class="diffpre insert">+                  actOnImpulse cost (addAnn wNext) actorIfMoved action</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">       in</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context">       let actorsThatCanMove = filter</pre>
</div>
<h2 class=".diffh2">
src/UtilityBrain.hs
</h2>
<div class="file-diff">
<pre class="diffpre difffile">diff -w -B -a -d -u -b --new-file 13_utility/src/UtilityBrain.hs 14_utility_annotate/src/UtilityBrain.hs</pre>
<pre class="diffpre delete">--- 13_utility/src/UtilityBrain.hs</pre>
<pre class="diffpre insert">+++ 14_utility_annotate/src/UtilityBrain.hs</pre>
<pre class="diffpre info">@@ -15,15 +14,21 @@</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> import Protolude </pre>
<pre class="diffpre context"> import qualified Data.List as Lst</pre>
<pre class="diffpre insert">+import qualified Data.DList as DLst</pre>
<pre class="diffpre context"> import qualified System.Random as Rnd</pre>
<pre class="diffpre context"> import qualified Control.Arrow as Ar</pre>
<pre class="diffpre context"> import           Control.Lens</pre>
<pre class="diffpre insert">+import           Control.Monad.Writer.Strict (tell, MonadWriter)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> import           GameCore</pre>
<pre class="diffpre context"> import qualified EntityType as E</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+telld :: MonadWriter (DLst.DList a) m =&gt; a -&gt; m ()</pre>
<pre class="diffpre insert">+telld t = tell (DLst.singleton t)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context"> path :: PathTo -&gt; Path</pre>
<pre class="diffpre context"> path (PathToEntity p _ _) = p</pre>
<pre class="diffpre context"> path (PathToActor p _ _) = p</pre>
<pre class="diffpre info">@@ -29,15 +34,19 @@</pre>
<pre class="diffpre context"> path (PathToActor p _ _) = p</pre>
<pre class="diffpre context"> path (PathToPlayer p _ _) = p</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context"> selectTopUtility :: [(Float, Actor, Impulse, Text, Maybe PathTo)]</pre>
<pre class="diffpre delete">-                 -&gt; Maybe (Float, Actor, Impulse, Text, Maybe PathTo)</pre>
<pre class="diffpre delete">-selectTopUtility rs = </pre>
<pre class="diffpre insert">+                 -&gt; UtilAnnotator (Maybe (Float, Actor, Impulse, Text, Maybe PathTo))</pre>
<pre class="diffpre insert">+selectTopUtility rs = do</pre>
<pre class="diffpre insert">+  telld $ UeAt "select top"</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">   case rs of</pre>
<pre class="diffpre delete">-      [] -&gt; Nothing</pre>
<pre class="diffpre insert">+      [] -&gt; do</pre>
<pre class="diffpre insert">+        telld $ UeSelectTopNone "No utilities"</pre>
<pre class="diffpre insert">+        pure Nothing</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      (u@(v0,a0,i0,n0,_):_) -&gt; do</pre>
<pre class="diffpre insert">+        telld $ UeSelectTopAbove (v0 - 0.001)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-      (u@(v0,a0,_,_,_):_) -&gt; do</pre>
<pre class="diffpre context">         -- Get the results with the top scores (fuzzy match)</pre>
<pre class="diffpre context">         let top = Lst.takeWhile (\(v2,_,_,_,_) -&gt; v2 &gt;= v0 - 0.001) rs </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre info">@@ -47,40 +56,36 @@</pre>
<pre class="diffpre context">               (Rnd.randomR (0, length top - 1) rndA, rndB') </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context">         case atMay top idx of</pre>
<pre class="diffpre delete">-          Just (s, a, i, n, p) -&gt; Just (s, a &amp; acStdGen .~ rndB, i, n, p)</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre delete">-          Nothing -&gt; Just u</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre insert">+          Just (s, a, i, n, p) -&gt; do</pre>
<pre class="diffpre insert">+            telld $ UeSelectTopOne s n i "selected"</pre>
<pre class="diffpre insert">+            pure $ Just (s, a &amp; acStdGen .~ rndB, i, n, p)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+          Nothing -&gt; do</pre>
<pre class="diffpre insert">+            telld $ UeSelectTopOne v0 n0 i0 $ "Nothing at index, using zero: " &lt;&gt; show idx</pre>
<pre class="diffpre insert">+            pure $ Just u</pre>
<pre class="diffpre context">   </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> -- | See the docs on acUtilities</pre>
<pre class="diffpre context"> -- | Mainly that the world is threaded through utilities and any updates are kept even if no/other utilities are selected</pre>
<pre class="diffpre context"> -- | The actor in the results are speculative and only the actor for the selected utility gets used</pre>
<pre class="diffpre delete">-assessUtilities :: [PathTo] -&gt; World -&gt; Actor -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre delete">-assessUtilities paths world actor =</pre>
<pre class="diffpre delete">-  let</pre>
<pre class="diffpre delete">-    (rs, wNext) = foldl' assess ([], world) (actor ^. acUtilities)</pre>
<pre class="diffpre delete">-    ranked = rankUtility rs</pre>
<pre class="diffpre delete">-  in</pre>
<pre class="diffpre delete">-  (ranked, wNext)</pre>
<pre class="diffpre context">   </pre>
<pre class="diffpre delete">-  where</pre>
<pre class="diffpre delete">-    assess (hist, w) u =</pre>
<pre class="diffpre delete">-      let</pre>
<pre class="diffpre delete">-        a = fromMaybe actor $ w ^. wdActors ^.at (actor ^. acId) </pre>
<pre class="diffpre delete">-        (rs, wNext) = u w a paths</pre>
<pre class="diffpre delete">-      in</pre>
<pre class="diffpre delete">-      (hist &lt;&gt; rs, wNext)</pre>
<pre class="diffpre insert">+assessUtilities :: [PathTo] -&gt; World -&gt; Actor -&gt; UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+assessUtilities paths world actor = do</pre>
<pre class="diffpre insert">+  (rs, wNext) &lt;- foldM assess ([], world) (actor ^. acUtilities)</pre>
<pre class="diffpre insert">+  ranked &lt;- rankUtility rs</pre>
<pre class="diffpre insert">+  pure (ranked, wNext)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+  where</pre>
<pre class="diffpre insert">+    assess (hist, w) u = do</pre>
<pre class="diffpre insert">+      let a = fromMaybe actor $ w ^. wdActors ^.at (actor ^. acId) </pre>
<pre class="diffpre insert">+      (rs, wNext) &lt;- u w a paths</pre>
<pre class="diffpre insert">+      pure (hist &lt;&gt; rs, wNext)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-rankUtility :: [(Float, Actor, Impulse, Text, Maybe PathTo)] -&gt; [(Float, Actor, Impulse, Text, Maybe PathTo)]</pre>
<pre class="diffpre insert">+rankUtility :: [(Float, Actor, Impulse, Text, Maybe PathTo)] -&gt; UtilAnnotator [(Float, Actor, Impulse, Text, Maybe PathTo)]</pre>
<pre class="diffpre context"> rankUtility us = </pre>
<pre class="diffpre delete">-  Lst.reverse $ Lst.sortOn (\(x, _, _, _, _) -&gt; x) us</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre insert">+  pure . Lst.reverse $ Lst.sortOn (\(x, _, _, _, _) -&gt; x) us</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> clamp :: Float -&gt; Float</pre>
<pre class="diffpre info">@@ -129,35 +130,36 @@</pre>
<pre class="diffpre context">         Just $ distance / maxDist</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context">       </pre>
<pre class="diffpre insert">+utilityOfWander :: World -&gt; Actor -&gt; [PathTo] -&gt; UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+utilityOfWander world actor _paths = do</pre>
<pre class="diffpre insert">+  telld $ UeAt "Wander"</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+  let rule = clamp $ 0.02 * (10 * clamp (actor ^. acDisposition ^. dsWanderlust)) </pre>
<pre class="diffpre insert">+  pure ([(rule, actor, ImpMoveRandom, "wander", Nothing)], world)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-utilityOfWander :: World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre delete">-utilityOfWander world actor _paths = </pre>
<pre class="diffpre delete">-  let rule = clamp $ 0.02 * (10 * clamp (actor ^. acDisposition ^. dsWanderlust)) in</pre>
<pre class="diffpre delete">-  ([(rule, actor, ImpMoveRandom, "wander", Nothing)], world)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+utilityOfWanderToExit :: World -&gt; Actor -&gt; [PathTo] -&gt; UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+utilityOfWanderToExit world actor allPaths = do</pre>
<pre class="diffpre insert">+  telld $ UeAt "WanderToExit"</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+  let rule x = clamp $ 1 - (0.04 * x + (1.24 - clamp (actor ^. acDisposition ^. dsWanderlustToExits))) </pre>
<pre class="diffpre insert">+  let clampedResults = moveTowardsUtil [E.Door] rule allPaths actor</pre>
<pre class="diffpre insert">+  pure ((\(p, score) -&gt; (score, actor, ImpMoveTowards (path p), "wander to exit", Just p)) &lt;$&gt; clampedResults, world)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-utilityOfWanderToExit :: World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre delete">-utilityOfWanderToExit world actor allPaths =</pre>
<pre class="diffpre delete">-  let</pre>
<pre class="diffpre delete">-    rule x = clamp $ 1 - (0.04 * x + (1.24 - clamp (actor ^. acDisposition ^. dsWanderlustToExits))) </pre>
<pre class="diffpre delete">-    clampedResults = moveTowardsUtil [E.Door] rule allPaths actor</pre>
<pre class="diffpre delete">-  in</pre>
<pre class="diffpre delete">-  ((\(p, score) -&gt; (score, actor, ImpMoveTowards (path p), "wander to exit", Just p)) &lt;$&gt; clampedResults, world)</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+utilityOfInfatuation :: World -&gt; Actor -&gt; [PathTo] -&gt; UtilAnnotator ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+utilityOfInfatuation world actor allPaths = do</pre>
<pre class="diffpre insert">+  telld . UeAt $ "Infatuation: " &lt;&gt; show (length allPaths) -- debugShowPathTos allPaths --show (actor ^. acDisposition ^. dsSmitten)</pre>
<pre class="diffpre context">   </pre>
<pre class="diffpre insert">+  let rule x = clamp $ -x ** 4 + clamp (actor ^. acDisposition ^. dsSmitten) </pre>
<pre class="diffpre insert">+  let clampedResults = moveTowardsUtil (actor ^. acDisposition ^. dsSmittenWith) rule allPaths actor</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-utilityOfInfatuation :: World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre delete">-utilityOfInfatuation world actor allPaths =</pre>
<pre class="diffpre delete">-  let</pre>
<pre class="diffpre delete">-    rule x = clamp $ -x ** 4 + clamp (actor ^. acDisposition ^. dsSmitten) </pre>
<pre class="diffpre delete">-    clampedResults = moveTowardsUtil (actor ^. acDisposition ^. dsSmittenWith) rule allPaths actor</pre>
<pre class="diffpre delete">-  in</pre>
<pre class="diffpre delete">-  ((\(p, score) -&gt; (score, actor, ImpMoveTowards (path p), "infatuation", Just p)) &lt;$&gt; clampedResults, world)</pre>
<pre class="diffpre insert">+  let (r, _) = ((\(p, score) -&gt; (score, actor, ImpMoveTowards (path p), "infatuation", Just p)) &lt;$&gt; clampedResults, world)</pre>
<pre class="diffpre insert">+  let r2 = (\(f, _, _, _, _) -&gt; showF f) &lt;$&gt; r</pre>
<pre class="diffpre insert">+  telld . UeNote $ "infatuation: " &lt;&gt; show r2</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+  pure ((\(p, score) -&gt; (score, actor, ImpMoveTowards (path p), "infatuation", Just p)) &lt;$&gt; clampedResults, world)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
</div>
</div>
<h1 id="chapters-1">Chapters</h1>
<p><a href="../2018-04-02-haskell-rogue-like.html">start</a> <a href="2018-04-02-haskell-rogue-like_13.html">prev</a> <a href="2018-04-02-haskell-rogue-like_15.html">next</a></p>


        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          
          ga('create', 'UA-78428674-1', 'auto');
          ga('send', 'pageview');
        </script>
    </body>
</html>
