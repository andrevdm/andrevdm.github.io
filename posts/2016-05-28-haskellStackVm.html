<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Andre's Blog</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
      <div id="bodyInner">
        <div id="header">
            <div id="logo">
                <a href="../">Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <!-- <a href="/about.html">About</a> -->
            </div>
        </div>

        <div id="content">
            <h1><a href="#top">Creating a Stack Machine with Haskell</a></h1>

            <div class="info">
    Posted on May 28, 2016

</div>

<h2 id="about-the-project">About the Project</h2>
<p>This is a small demonstration project showing how a simple byte code interpreting stack machine (virtual machine) can be built with Haskell. It is not a production VM nor of any particular practical use but is rather a simple demonstration of how a stack machine can be built. All code is available in the github repo <a href="https://github.com/andrevdm/SimpleHaskellStackVM" class="uri">https://github.com/andrevdm/SimpleHaskellStackVM</a></p>
<p>I built this for mainly as a project for learning Haskell, i.e. something a little bigger to work on. So NB this is probably not idiomatic Haskell, and may have some newbie mistakes. Hopefully it is interesting enough despite this…</p>
<h3 id="stack-machines">Stack Machines</h3>
<blockquote>
<p>A stack machine is a real or emulated computer that uses a pushdown stack rather than individual machine registers to evaluate each sub-expression in the program. A stack computer is programmed with a reverse Polish notation instruction set. - <a href="https://en.wikipedia.org/wiki/Stack_machine">wikipedia [1]</a></p>
</blockquote>
<p>Stack machines are simpler to implement than <a href="https://en.wikipedia.org/wiki/Register_machine">register machines</a> but are still practical even for production VMs.</p>
<h3 id="writing-the-vm-in-haskell">Writing the VM in Haskell</h3>
<p>Virtual machines are typically written in a low level language like C for maximum efficiency. They also are typically written using mutable data structures. Here I’m using Haskell and pure functional data structures. I have absolutely no performance goals, so there are no constraints I need to worry about.</p>
<p>A few design decisions</p>
<ol type="1">
<li><p>I’m using a Data.Sequence rather than a list. While I’m not concerned about performance using a linked list to do random access is still a bad idea</p></li>
<li><p>Try to avoid bottom (⊥), so use “safe” versions whenever ⊥ could otherwise be returned (toEnum, index, head etc)</p></li>
<li><p>I’m using <a href="https://github.com/sdiehl/protolude">Stephen Diehl’s Protolude [2]</a> and removing the default prelude</p></li>
</ol>
<p>Using the immutable data structures like Data.Sequence had worked out nicely and means that as the VM runs you can keep a full history of the VM’s state. So you have everything (apart from time) you need to build a nice visualiser / ‘time travelling’ debugger.</p>
<h2 id="the-vm">The VM</h2>
<h3 id="opcodes-byte-code">Opcodes &amp; byte code</h3>
<p>The opcodes are the operations that the virtual CPU can perform. These are simple operations like push, pop, add and jump. The opcodes are encoded as bytes together with the opcode parameters (e.g. the value to push) this forms the byte code.</p>
<p>Here is the current set of opcodes understood by the CPU</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Nop</span>       <span class="co">-- No operation</span></a>
<a class="sourceLine" id="cb1-2" title="2">               <span class="fu">|</span> <span class="dt">Halt</span>      <span class="co">-- Stop CPU execution</span></a>
<a class="sourceLine" id="cb1-3" title="3">               <span class="fu">|</span> <span class="dt">Push</span>      <span class="co">-- Push a value onto the stack</span></a>
<a class="sourceLine" id="cb1-4" title="4">               <span class="fu">|</span> <span class="dt">Pop</span>       <span class="co">-- Pop the most recent value from the stack</span></a>
<a class="sourceLine" id="cb1-5" title="5">               <span class="fu">|</span> <span class="dt">PopPrev</span>   <span class="co">-- Pop n values before the most recent value from the stack</span></a>
<a class="sourceLine" id="cb1-6" title="6">               <span class="fu">|</span> <span class="dt">Add</span>       <span class="co">-- Add the top two items on the stack</span></a>
<a class="sourceLine" id="cb1-7" title="7">               <span class="fu">|</span> <span class="dt">Inc</span>       <span class="co">-- Increment the top item on the stack</span></a>
<a class="sourceLine" id="cb1-8" title="8">               <span class="fu">|</span> <span class="dt">Dup</span>       <span class="co">-- Duplicate the most recent item on the stack</span></a>
<a class="sourceLine" id="cb1-9" title="9">               <span class="fu">|</span> <span class="dt">Jmp</span>       <span class="co">-- Jump unconditionally to a location</span></a>
<a class="sourceLine" id="cb1-10" title="10">               <span class="fu">|</span> <span class="dt">Bne</span>       <span class="co">-- Pop the top two items, compare and branch if the values are not equal</span></a>
<a class="sourceLine" id="cb1-11" title="11">               <span class="fu">|</span> <span class="dt">Beq</span>       <span class="co">-- Pop the top two items, compare and branch if the values are equal</span></a>
<a class="sourceLine" id="cb1-12" title="12">               <span class="fu">|</span> <span class="dt">Bgt</span>       <span class="co">-- Pop the top two items, compare and branch if value 1 is greater than value 2</span></a>
<a class="sourceLine" id="cb1-13" title="13">               <span class="fu">|</span> <span class="dt">Bgte</span>      <span class="co">-- Pop the top two items, compare and branch if value 1 is greater or equal to value 2</span></a>
<a class="sourceLine" id="cb1-14" title="14">               <span class="fu">|</span> <span class="dt">Blt</span>       <span class="co">-- Pop the top two items, compare and branch if value 1 is less than value 2</span></a>
<a class="sourceLine" id="cb1-15" title="15">               <span class="fu">|</span> <span class="dt">Blte</span>      <span class="co">-- Pop the top two items, compare and branch if value 1 is less than or equal to value 2</span></a>
<a class="sourceLine" id="cb1-16" title="16">               <span class="fu">|</span> <span class="dt">Call</span>      <span class="co">-- Call a function</span></a>
<a class="sourceLine" id="cb1-17" title="17">               <span class="fu">|</span> <span class="dt">Ret</span>       <span class="co">-- Return from a function</span></a>
<a class="sourceLine" id="cb1-18" title="18">               <span class="fu">|</span> <span class="dt">LdArg</span>     <span class="co">-- Push local value n onto the stack</span></a>
<a class="sourceLine" id="cb1-19" title="19">               <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>)</a></code></pre></div>
<h3 id="the-virtual-cpu">The virtual CPU</h3>
<p>The data structure representing the CPU is defined below</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">Cpu</span> <span class="fu">=</span> <span class="dt">Cpu</span> {<span class="ot"> ip ::</span> <span class="dt">Int</span>               <span class="co">-- Instruction pointer</span></a>
<a class="sourceLine" id="cb2-2" title="2">               ,<span class="ot"> fp ::</span> <span class="dt">Int</span>               <span class="co">-- Frame pointer</span></a>
<a class="sourceLine" id="cb2-3" title="3">               ,<span class="ot"> cpuStack ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span>   <span class="co">-- The stack</span></a>
<a class="sourceLine" id="cb2-4" title="4">               ,<span class="ot"> cpuGlobals ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="co">-- Gloal variables</span></a>
<a class="sourceLine" id="cb2-5" title="5">               ,<span class="ot"> ranOp ::</span> <span class="dt">Int</span>            <span class="co">-- The last opcode that was executed</span></a>
<a class="sourceLine" id="cb2-6" title="6">               ,<span class="ot"> state ::</span> <span class="dt">Text</span>           <span class="co">-- Debugging message</span></a>
<a class="sourceLine" id="cb2-7" title="7">               ,<span class="ot"> debug ::</span> <span class="dt">Bool</span>           <span class="co">-- Enable/disable debugging</span></a>
<a class="sourceLine" id="cb2-8" title="8">               ,<span class="ot"> panic ::</span> <span class="dt">Bool</span>           <span class="co">-- Is the CPU in a faulted state</span></a>
<a class="sourceLine" id="cb2-9" title="9">               }</a>
<a class="sourceLine" id="cb2-10" title="10">         <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="co">-- | Default empty/initial CPU state</span></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="ot">emptyCpu ::</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb2-14" title="14">emptyCpu <span class="fu">=</span> <span class="dt">Cpu</span> { ip <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb2-15" title="15">               , fp <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb2-16" title="16">               , cpuStack <span class="fu">=</span> S.empty</a>
<a class="sourceLine" id="cb2-17" title="17">               , cpuGlobals <span class="fu">=</span> S.empty</a>
<a class="sourceLine" id="cb2-18" title="18">               , state <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-19" title="19">               , debug <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-20" title="20">               , ranOp <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-21" title="21">               , panic <span class="fu">=</span> <span class="dt">False</span> </a>
<a class="sourceLine" id="cb2-22" title="22">               }</a></code></pre></div>
<p>This is fairly minimal but it’s more than enough for a simple VM like this.</p>
<p>Some things to note</p>
<ul>
<li>The stack (cpuStack) is part of the CPU. This makes sense for a stack machine since a stack is core to everything it does. It also means that as the CPU runs you get a full history of each stack state along with the CPU flags at the time each opcode was run</li>
<li>There is no need for a stack pointer since the stack is a ‘dynamically’ growing Data.Sequence. I.e. sp always points to the head of cpuStack.</li>
<li>The instruction pointer (ip) points to the next instruction to run.</li>
<li>In this implementation the byte stream is fixed (no self-modifying code), so there is no need to copy it on each CPU operation</li>
<li>The frame pointer (fp) is discussed below in the section about function calls (Call &amp; Ret)</li>
</ul>
<h3 id="the-byte-code-assembler">The byte code assembler</h3>
<p>Rather than writing the byte code in hex a very simple assembler is used. Later on additional assemblers and compliers can be layer on top of this low level assembler which does little more than convert opcode mnemonics to byte code.</p>
<p>An operation can take parameters from the byte code stream. For instance a <strong><em>push</em></strong> instruction takes a parameter that is the value to push onto the stack. The type that represents this is the inventively named <strong><em>OpAndParam</em></strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="co">-- | A single CPU operator and its parameters</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">type</span> <span class="dt">OpAndParam</span> <span class="fu">=</span> (<span class="dt">Operation</span>, [<span class="dt">Int</span>])</a></code></pre></div>
<p>Having a type that defines the number of parameters an op takes and how many values it pops off the stack allows the assembler to perform some basic checks. The interpreter can also use this definition when running the code.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="co">-- | Configuration for an operation</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">-- | opParamCount = number of paramaters taken from the code stream</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">-- | opPopsCount = number of values this op pops from the stack</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">-- | opSimple = determines if the op needs full access to cpu state to change things like the fp and ip</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">-- |            note that 'complex' instructions do not need to honour opParamCount and opPopsCount</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">-- |            e.g. a 'ret' instruction pops a variable number of parameters</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">data</span> <span class="dt">Instruction</span> <span class="fu">=</span> <span class="dt">Instruction</span> {<span class="ot"> opCode ::</span> <span class="dt">Operation</span></a>
<a class="sourceLine" id="cb4-8" title="8">                               ,<span class="ot"> opPopsCount ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-9" title="9">                               ,<span class="ot"> opParamCount ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-10" title="10">                               ,<span class="ot"> opSimple ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-11" title="11">                               }</a>
<a class="sourceLine" id="cb4-12" title="12">                 <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>The instructions can then be setup and a map created from opcode to Instruction</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- | Config for the op codes</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">instructions ::</span> [<span class="dt">Instruction</span>]</a>
<a class="sourceLine" id="cb5-3" title="3">instructions <span class="fu">=</span> [ <span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Nop</span>, opParamCount <span class="fu">=</span> <span class="dv">0</span>, opPopsCount <span class="fu">=</span> <span class="dv">0</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a>
<a class="sourceLine" id="cb5-4" title="4">                <span class="co">-- ...</span></a>
<a class="sourceLine" id="cb5-5" title="5">               , <span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Call</span>, opParamCount <span class="fu">=</span> <span class="dv">1</span>, opPopsCount <span class="fu">=</span> <span class="dv">0</span>, opSimple <span class="fu">=</span> <span class="dt">False</span> }</a>
<a class="sourceLine" id="cb5-6" title="6">               ]</a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">-- | Instructions indexed by opcode</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="ot">instrByOp ::</span> <span class="dt">Map.Map</span> <span class="dt">Operation</span> <span class="dt">Instruction</span></a>
<a class="sourceLine" id="cb5-10" title="10">instrByOp <span class="fu">=</span> Map.fromList <span class="fu">$</span> <span class="fu">map</span> (\i <span class="ot">-&gt;</span> (opCode i, i)) instructions</a></code></pre></div>
<p>The assembler then does nothing more than converting the opcode enum to a byte (an Int in the code but it would be serialised as a byte) checking the number of parameters for each opcode. It is small enough to be pasted in full here</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="co">-- | A single assembler error</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">data</span> <span class="dt">AssemblerError</span> <span class="fu">=</span> <span class="dt">AssemblerError</span> <span class="dt">Integer</span> <span class="dt">Operation</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">-- | Compiles the list to byte code</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">-- | Returns as many errors as possible rather than just first error</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="ot">assembleByteCode ::</span> [(<span class="dt">Operation</span>, [<span class="dt">Int</span>])] <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">AssemblerError</span>] [<span class="dt">Int</span>]	</a>
<a class="sourceLine" id="cb6-7" title="7">assembleByteCode code <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="kw">let</span> res <span class="fu">=</span> <span class="fu">foldl</span> assemble [] code <span class="kw">in</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="kw">case</span> lefts res <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-10" title="10">    [] <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="fu">concat</span> <span class="fu">$</span> rights res</a>
<a class="sourceLine" id="cb6-11" title="11">    errors <span class="ot">-&gt;</span> <span class="dt">Left</span> errors</a>
<a class="sourceLine" id="cb6-12" title="12">  </a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="ot">    assemble ::</span> [<span class="dt">Either</span> <span class="dt">AssemblerError</span> [<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">OpAndParam</span> <span class="ot">-&gt;</span> [<span class="dt">Either</span> <span class="dt">AssemblerError</span> [<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb6-15" title="15">    assemble res (op, prms) <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-16" title="16">      res <span class="fu">++</span> <span class="kw">case</span> Map.lookup op instrByOp <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-17" title="17">               <span class="dt">Nothing</span> <span class="ot">-&gt;</span> [<span class="dt">Left</span> <span class="fu">$</span> <span class="dt">AssemblerError</span> (<span class="fu">toInteger</span> <span class="fu">$</span> <span class="fu">length</span> res) op <span class="st">&quot;unknown op code&quot;</span>]</a>
<a class="sourceLine" id="cb6-18" title="18">               <span class="dt">Just</span> i <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-19" title="19">                 <span class="kw">if</span> opParamCount i <span class="fu">==</span> <span class="fu">length</span> prms</a>
<a class="sourceLine" id="cb6-20" title="20">                 <span class="kw">then</span> [<span class="dt">Right</span> <span class="fu">$</span> <span class="fu">fromEnum</span> (opCode i) <span class="fu">:</span> prms]</a>
<a class="sourceLine" id="cb6-21" title="21">                 <span class="kw">else</span> [<span class="dt">Left</span> <span class="fu">$</span> <span class="dt">AssemblerError</span> (<span class="fu">toInteger</span> <span class="fu">$</span> <span class="fu">length</span> res) op <span class="st">&quot;incorrect number of parameters&quot;</span>]</a></code></pre></div>
<h3 id="the-interpreter">The interpreter</h3>
<p>With all of that in place the interpreter can finally be written.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="co">-- | Interpreter for the byte code</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co">-- | Given a byte code stream will 'run' the code</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">-- | If debug is enabled then the full history (all states) will be returned. </span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">interpretByteCode ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Cpu</span>]</a></code></pre></div>
<p>The interpreter takes the output of the assembler or bytes loaded from a file and runs it producing CPU state along the way. In debug mode the interpreter stores all the states as it interprets, in “non-debug” mode only the last state is kept. <em>Note that currently the interpreter is always in debug mode</em></p>
<p>Before looking at the implementation of the interpreter its worth going over a few examples of how it should operate</p>
<h5 id="push-pop">Push &amp; Pop</h5>
<div class="sourceCode" id="cb8"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb8-1" title="1">                                                  +--------+</a>
<a class="sourceLine" id="cb8-2" title="2">                          +--------+              |  123   |</a>
<a class="sourceLine" id="cb8-3" title="3">   +--------+             |  123   |              |  456   |</a>
<a class="sourceLine" id="cb8-4" title="4">   +--------+    push 123 +--------+    push 456  +--------+</a></code></pre></div>
<p>In the first example the value 123 is pushed onto an empty stack. Then the value 456 is pushed. The head of the stack is at the “bottom”</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb9-1" title="1">  +--------+             </a>
<a class="sourceLine" id="cb9-2" title="2">  |  123   |        +--------+</a>
<a class="sourceLine" id="cb9-3" title="3">  |  456   |        |  123   |</a>
<a class="sourceLine" id="cb9-4" title="4">  +--------+    pop +--------+</a></code></pre></div>
<p>A <strong><em>pop</em></strong> is the opposite of a <strong><em>push</em></strong>. The pop operation get the most recent value from the stack (FIFO) in this case 456 leaving 123 on the stack.</p>
<h5 id="add">Add</h5>
<p>An <strong><em>add</em></strong> operation pops the top two items from the stack, adds them and pushes the result back onto the stack</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb10-1" title="1">           +--------+             </a>
<a class="sourceLine" id="cb10-2" title="2">           |  100   |        +--------+</a>
<a class="sourceLine" id="cb10-3" title="3">push 100   |  123   |        |  223   |</a>
<a class="sourceLine" id="cb10-4" title="4">push 123   +--------+    add +--------+</a></code></pre></div>
<p>Look at the definition of the instructions for these three operators</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Push</span>, opParamCount <span class="fu">=</span> <span class="dv">1</span>, opPopsCount <span class="fu">=</span> <span class="dv">0</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Pop</span>, opParamCount <span class="fu">=</span> <span class="dv">0</span>, opPopsCount <span class="fu">=</span> <span class="dv">1</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Add</span>, opParamCount <span class="fu">=</span> <span class="dv">0</span>, opPopsCount <span class="fu">=</span> <span class="dv">2</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a></code></pre></div>
<p>From this you can see that the <strong><em>Instruction</em></strong> shows that a <strong><em>push</em></strong> takes one parameter, a <strong><em>pop</em></strong> takes no parameters but pops a single value off the stack and an <strong><em>Add</em></strong> pops two values off the stack. As noted in the code comments <strong><em>opSimple</em></strong> indicates that these are simple operators with fixed stack effects.</p>
<h5 id="jmp">Jmp</h5>
<p>The <strong><em>Jmp</em></strong> operator performs an unconditional jump to a fixed location relative to the start of the code stream. I.e. <strong><em>Jmp 100</em></strong> sets the instruction pointer to 100 and execution continues from there.</p>
<p>Consider the following simple list of ops in Haskel</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"> [ (<span class="dt">Jmp</span>, [<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb12-2" title="2"> , (<span class="dt">Nop</span>, [])</a>
<a class="sourceLine" id="cb12-3" title="3"> , (<span class="dt">Halt</span>, [])</a>
<a class="sourceLine" id="cb12-4" title="4"> ]</a></code></pre></div>
<p>This gets assembled into the following byte code</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb13-1" title="1"><span class="fu">00: </span>0903  -- Jmp 3</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="fu">02: </span>00    -- Nop</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="fu">03: </span>02    -- Halt</a></code></pre></div>
<p>The Jmp instruction causes the CPU to set the instruction pointer (ip) to 3. In this example that means that the <strong><em>Nop</em></strong> at offset 2 is skipped and execution continues with the <strong><em>Halt</em></strong> operation at offset 3</p>
<h5 id="branching-beq-bne-blr-blte-bgt-bgte">Branching (Beq, Bne, Blr, Blte, Bgt, Bgte)</h5>
<p>Branching is a conditional jump. The top two values are popped off the stack compared based on the type of conditional operator.</p>
<p>In the following example the values 1 and to are pushed. <strong><em>Bgt</em></strong> is executed and if 2 is greater than 1 then the CPU jumps to location 7. If no then it continues executing at the location after the branch (6)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"> [ (<span class="dt">Push</span>, [<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb14-2" title="2"> , (<span class="dt">Push</span>, [<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb14-3" title="3"> , (<span class="dt">Bgt</span>, [<span class="dv">7</span>])</a>
<a class="sourceLine" id="cb14-4" title="4"> , (<span class="dt">Nop</span>, [])</a>
<a class="sourceLine" id="cb14-5" title="5"> , (<span class="dt">Halt</span>, [])</a>
<a class="sourceLine" id="cb14-6" title="6"> ]</a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb15-1" title="1"><span class="fu">00: </span>0301  -- Push 1</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="fu">02: </span>0302  -- Push 2</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="fu">04: </span>0C07  -- Bgt 7</a>
<a class="sourceLine" id="cb15-4" title="4"><span class="fu">06: </span>00    -- Nop</a>
<a class="sourceLine" id="cb15-5" title="5"><span class="fu">07: </span>02    -- Halt</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb16-1" title="1">         +--------+             </a>
<a class="sourceLine" id="cb16-2" title="2">         |   1    |        +--------+</a>
<a class="sourceLine" id="cb16-3" title="3">push 1   |   2    |        |        |</a>
<a class="sourceLine" id="cb16-4" title="4">push 2   +--------+    Bgt +--------+</a></code></pre></div>
<p>This is what the history of the CPU would look like for the above example</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">Cpu</span> {ip <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">0</span>,  state <span class="fu">=</span> <span class="st">&quot;&quot;</span>,     panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">1</span>, cpuStack <span class="fu">=</span>   [<span class="dv">1</span>], ranOp <span class="fu">=</span> <span class="dv">3</span>,  state <span class="fu">=</span> <span class="st">&quot;Push&quot;</span>, panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-3" title="3"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">3</span>, cpuStack <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">1</span>], ranOp <span class="fu">=</span> <span class="dv">3</span>,  state <span class="fu">=</span> <span class="st">&quot;Push&quot;</span>, panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">5</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">12</span>, state <span class="fu">=</span> <span class="st">&quot;Bgt&quot;</span>,  panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-5" title="5"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">6</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">0</span>,  state <span class="fu">=</span> <span class="st">&quot;Nop&quot;</span>,  panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-6" title="6"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">7</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">2</span>,  state <span class="fu">=</span> <span class="st">&quot;Halt&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span>}</a></code></pre></div>
<h5 id="call-ret">Call &amp; Ret</h5>
<p>A function call is much like a jmp except that you have to store an address to return to. You could have two stacks, one for values and one for return address. It’s more common however to have a single stack with “stack frames”.</p>
<p>As a trivial example consider a the case when there are no parameters</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb18-1" title="1"><span class="fu">00: </span>1003  -- Call 03</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="fu">02: </span>02    -- Halt</a>
<a class="sourceLine" id="cb18-3" title="3"><span class="fu">03: </span>00    -- Nop</a>
<a class="sourceLine" id="cb18-4" title="4"><span class="fu">04: </span>11    -- Ret</a></code></pre></div>
<p>The CPU does the following</p>
<ul>
<li>Executes the <strong><em>call</em></strong> operation and pushes the return address onto the stack, i.e. the next instruction after the <strong><em>call</em></strong>. Here it is the <strong><em>halt</em></strong> at 02.</li>
<li>The ip is set to 03, the offset of the function, and the CPU executes the function (<strong><em>nop</em></strong>)</li>
<li>The <strong><em>ret</em></strong> operation gets the return address (02) from the stack and updates the ip</li>
<li>The <strong><em>halt</em></strong> at 02 is executed.</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb19-1" title="1">         +--------+        </a>
<a class="sourceLine" id="cb19-2" title="2">         |   02   |        +--------+</a>
<a class="sourceLine" id="cb19-3" title="3">Call 03  +--------+    Ret +--------+</a></code></pre></div>
<p>However this simple scheme does not work when you have variable numbers of parameters, locals etc. This is where the frame pointer (fp) and stack frames come in.</p>
<p>A stack frame is the set of data stored on the stack for each method call. In this virtual machine that is 1. The return address 2. Parameters for the function 3. The previous frame pointer value</p>
<p>As an example consider a function that adds two numbers and returns the sum.</p>
<ul>
<li>The caller pushes the two values to be added (123 and 22), these are pushed in reverse order. I.e. parameter 1 last.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb20-1" title="1">   00: 0322  -- Push 22    +--------+ ip = 4</a>
<a class="sourceLine" id="cb20-2" title="2">__ 02: 037b  -- Push 123   |   22   | fp = -1</a>
<a class="sourceLine" id="cb20-3" title="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb20-4" title="4">   06: 0502  -- PopPrev 2  +--------+</a>
<a class="sourceLine" id="cb20-5" title="5">   08: 02    -- Halt   </a>
<a class="sourceLine" id="cb20-6" title="6">   09: 1202  -- LdArd 2</a>
<a class="sourceLine" id="cb20-7" title="7">   0b: 1201  -- LdArg 1</a>
<a class="sourceLine" id="cb20-8" title="8">   0c: 06    -- Add    </a>
<a class="sourceLine" id="cb20-9" title="9">   0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>The current frame pointer (-1) is stored. If no function has been called this will be -1. Further down in the example this will make more sense</li>
<li>The return address (06) is pushed onto the stack</li>
<li>The frame pointer is set to the start of the stack frame (02), i.e. position 2 from the end of the stack</li>
<li>The CPU sets the instruction pointer and “jumps” to the function (09) being called.</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb21-1" title="1">   00: 0322  -- Push 22    +--------+ ip = 0b</a>
<a class="sourceLine" id="cb21-2" title="2">   02: 037b  -- Push 123   |   22   | fp = 2</a>
<a class="sourceLine" id="cb21-3" title="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb21-4" title="4">   06: 0502  -- PopPrev 2  |   -1   |</a>
<a class="sourceLine" id="cb21-5" title="5">   08: 02    -- Halt       |    6   | &lt;-- fp</a>
<a class="sourceLine" id="cb21-6" title="6">   09: 1202  -- LdArd 2    |   22   | </a>
<a class="sourceLine" id="cb21-7" title="7">__ 0b: 1201  -- LdArg 1    |  123   |</a>
<a class="sourceLine" id="cb21-8" title="8">   0c: 06    -- Add        +--------+</a>
<a class="sourceLine" id="cb21-9" title="9">   0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>The function can then push any values it needs onto the stack and do its work.</li>
<li>Here the function loads the two arguments <strong><em>LdArg 1</em></strong> and <strong><em>LdArg 2</em></strong> (i.e. get params to top of stack) and then calls <strong><em>Add</em></strong> to add them</li>
<li>In this VM a function always returns a single value on the stack</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb22-1" title="1">   00: 0322  -- Push 22    +--------+ ip = 0c</a>
<a class="sourceLine" id="cb22-2" title="2">   02: 037b  -- Push 123   |   22   | fp = 2</a>
<a class="sourceLine" id="cb22-3" title="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb22-4" title="4">   06: 0502  -- PopPrev 2  |   -1   |</a>
<a class="sourceLine" id="cb22-5" title="5">   08: 02    -- Halt       |    6   | &lt;-- fp</a>
<a class="sourceLine" id="cb22-6" title="6">   09: 1202  -- LdArd 2    |  145   | </a>
<a class="sourceLine" id="cb22-7" title="7">   0b: 1201  -- LdArg 1    +--------+</a>
<a class="sourceLine" id="cb22-8" title="8">__ 0c: 06    -- Add        </a>
<a class="sourceLine" id="cb22-9" title="9">   0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>Then when a <strong><em>ret</em></strong> operation is executed the CPU needs to do the reverse.</li>
<li>The return value is popped, and the stack shifted back to the fp</li>
<li>Notice that the original parameters are still on the stack. This is normal for the cdecl calling convention. The caller is responsible for cleaning up.</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb23-1" title="1">   00: 0322  -- Push 22    +--------+ ip = 06</a>
<a class="sourceLine" id="cb23-2" title="2">   02: 037b  -- Push 123   |   22   | fp = -1</a>
<a class="sourceLine" id="cb23-3" title="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb23-4" title="4">   06: 0502  -- PopPrev 2  |  145   | </a>
<a class="sourceLine" id="cb23-5" title="5">   08: 02    -- Halt       +--------+</a>
<a class="sourceLine" id="cb23-6" title="6">   09: 1202  -- LdArd 2    </a>
<a class="sourceLine" id="cb23-7" title="7">   0b: 1201  -- LdArg 1    </a>
<a class="sourceLine" id="cb23-8" title="8">   0c: 06    -- Add        </a>
<a class="sourceLine" id="cb23-9" title="9">__ 0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>The <strong><em>PopPrev</em></strong> operation is used to do the parameter clean-up by the caller. It pops the number of items specified before the item at the top of the stack</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb24-1" title="1">   00: 0322  -- Push 22    +--------+ ip = 08</a>
<a class="sourceLine" id="cb24-2" title="2">   02: 037b  -- Push 123   |   145  | fp = -1</a>
<a class="sourceLine" id="cb24-3" title="3">   04: 1003  -- Call 09    +--------+</a>
<a class="sourceLine" id="cb24-4" title="4">__ 06: 0502  -- PopPrev 2  </a>
<a class="sourceLine" id="cb24-5" title="5">   08: 02    -- Halt       </a>
<a class="sourceLine" id="cb24-6" title="6">   09: 1202  -- LdArd 2    </a>
<a class="sourceLine" id="cb24-7" title="7">   0b: 1201  -- LdArg 1    </a>
<a class="sourceLine" id="cb24-8" title="8">   0c: 06    -- Add        </a>
<a class="sourceLine" id="cb24-9" title="9">   0d: 11    -- Ret</a></code></pre></div>
<p>The important thing to notice is that since the old frame pointer is stored on the stack you are able to call multiple functions and always be able to return to the previous function. Also having the fp lets you unwind the stack to the frame no matter how many items the current function may have pushed onto the stack, i.e. you don’t need to try and track that</p>
<p>Here is the output for the code above</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb25-1" title="1">{ip = -1, fp = -1, cpuStack = [],                   ranOp =  0, state = &quot;&quot;,        panic = False}</a>
<a class="sourceLine" id="cb25-2" title="2">{ip =  1, fp = -1, cpuStack = [22],                 ranOp =  3, state = &quot;Push&quot;,    panic = False}</a>
<a class="sourceLine" id="cb25-3" title="3">{ip =  3, fp = -1, cpuStack = [123,22],             ranOp =  3, state = &quot;Push&quot;,    panic = False}</a>
<a class="sourceLine" id="cb25-4" title="4">{ip =  8, fp =  2, cpuStack = [6,-1,123,22],        ranOp = 16, state = &quot;Call&quot;,    panic = False}</a>
<a class="sourceLine" id="cb25-5" title="5">{ip = 10, fp =  2, cpuStack = [22,6,-1,123,22],     ranOp = 18, state = &quot;LdArg&quot;,   panic = False}</a>
<a class="sourceLine" id="cb25-6" title="6">{ip = 12, fp =  2, cpuStack = [123,22,6,-1,123,22], ranOp = 18, state = &quot;LdArg&quot;,   panic = False}</a>
<a class="sourceLine" id="cb25-7" title="7">{ip = 13, fp =  2, cpuStack = [145,6,-1,123,22],    ranOp =  6, state = &quot;Add&quot;,     panic = False}</a>
<a class="sourceLine" id="cb25-8" title="8">{ip =  5, fp = -1, cpuStack = [145,123,22],         ranOp = 17, state = &quot;Ret&quot;,     panic = False}</a>
<a class="sourceLine" id="cb25-9" title="9">{ip =  7, fp = -1, cpuStack = [145],                ranOp =  5, state = &quot;PopPrev&quot;, panic = False}</a>
<a class="sourceLine" id="cb25-10" title="10">{ip =  8, fp = -1, cpuStack = [145],                ranOp =  2, state = &quot;Halt&quot;,    panic = True}</a></code></pre></div>
<h5 id="the-interpreter-code">The interpreter code</h5>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="co">-- | Interpreter for the byte code</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="co">-- | Given a byte code stream will run the code</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="ot">interpretByteCode ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Cpu</span>]</a></code></pre></div>
<ul>
<li>The interpreter converts a sequence of byte codes into a list of CPUs. Final CPU is the final state</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1">  interpret [emptyCpu] byteCode</a>
<a class="sourceLine" id="cb27-2" title="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="ot">    interpret ::</span> [<span class="dt">Cpu</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Cpu</span>]</a>
<a class="sourceLine" id="cb27-4" title="4"></a>
<a class="sourceLine" id="cb27-5" title="5">    <span class="co">-- Ensure that this function is not called with an empty CPU list</span></a>
<a class="sourceLine" id="cb27-6" title="6">    interpret [] _ <span class="fu">=</span> [emptyCpu { state <span class="fu">=</span> <span class="st">&quot;INVALID: no start CPU&quot;</span> }]</a>
<a class="sourceLine" id="cb27-7" title="7"></a>
<a class="sourceLine" id="cb27-8" title="8">    <span class="co">-- Start interpreting </span></a>
<a class="sourceLine" id="cb27-9" title="9">    interpret cpus<span class="fu">@</span>(cpu<span class="fu">:</span>_) code <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-10" title="10">      <span class="co">-- Move to next op code</span></a>
<a class="sourceLine" id="cb27-11" title="11">      <span class="kw">let</span> atIp <span class="fu">=</span> ip cpu <span class="fu">+</span> <span class="dv">1</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb27-12" title="12"></a>
<a class="sourceLine" id="cb27-13" title="13">      <span class="co">-- Try get the code byte at index atIp </span></a>
<a class="sourceLine" id="cb27-14" title="14">      <span class="kw">case</span> indexMay code atIp <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-15" title="15">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-16" title="16">          <span class="co">-- No byte at expected index, return error</span></a>
<a class="sourceLine" id="cb27-17" title="17">          cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> <span class="dv">0</span>, state <span class="fu">=</span> <span class="st">&quot;INVALID: invalid ip index, reading past end of byte stream&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb27-18" title="18">          </a>
<a class="sourceLine" id="cb27-19" title="19">        <span class="dt">Just</span> opByte <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-20" title="20">          <span class="co">-- Ensure this is a valid opcode</span></a>
<a class="sourceLine" id="cb27-21" title="21"></a>
<a class="sourceLine" id="cb27-22" title="22">          <span class="kw">case</span> toEnumMay<span class="ot"> opByte ::</span> <span class="dt">Maybe</span> <span class="dt">Operation</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-23" title="23">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-24" title="24">              <span class="co">-- This is not a valid opcode, error</span></a>
<a class="sourceLine" id="cb27-25" title="25">              cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;INVALID: Unknown op&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb27-26" title="26"></a>
<a class="sourceLine" id="cb27-27" title="27">            <span class="dt">Just</span> op <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-28" title="28">              <span class="co">-- Get the instruction for the op code</span></a>
<a class="sourceLine" id="cb27-29" title="29">              <span class="kw">case</span> (op, Map.lookup op instrByOp) <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-30" title="30">                (_, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-31" title="31">                  <span class="co">-- The byte was an opcode enum but was not configured as an instruction</span></a>
<a class="sourceLine" id="cb27-32" title="32">                  cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;INVALID: Op not found&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb27-33" title="33">                  </a></code></pre></div>
<ul>
<li>Start interpreting with an empty CPU</li>
<li>The code does the following checks, to get a valid instruction for the byte</li>
</ul>
<ol type="1">
<li>Check that there is a start CPU</li>
<li>Check that there is an opcode in the sequence at the ip index</li>
<li>Check that the opcode is valid, i.e. belongs to the <strong><em>Operation</em></strong> enum</li>
<li>Check that the opcode is in the instruction map <strong><em>instrByOp</em></strong></li>
</ol>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1">                (_, <span class="dt">Just</span> instr) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-2" title="2">                  <span class="co">-- 'params' are the bytes from the code stream that are used as parameters for the op, e.g. to be pushed onto stack</span></a>
<a class="sourceLine" id="cb28-3" title="3">                  <span class="co">-- get the params from the byte stream into a list</span></a>
<a class="sourceLine" id="cb28-4" title="4">                  <span class="kw">let</span> paramsCount <span class="fu">=</span> opParamCount instr <span class="kw">in</span> </a>
<a class="sourceLine" id="cb28-5" title="5">                  <span class="kw">let</span> params <span class="fu">=</span> S.take paramsCount <span class="fu">$</span> S.drop (atIp <span class="fu">+</span> <span class="dv">1</span>) code <span class="kw">in</span></a>
<a class="sourceLine" id="cb28-6" title="6"></a>
<a class="sourceLine" id="cb28-7" title="7">                  <span class="co">-- 'Pops' are the bytes popped from the stack and used by the current instruction</span></a>
<a class="sourceLine" id="cb28-8" title="8">                  <span class="co">-- get the values from the stack into the list</span></a>
<a class="sourceLine" id="cb28-9" title="9">                  <span class="kw">let</span> popsCount <span class="fu">=</span> opPopsCount instr <span class="kw">in</span> </a>
<a class="sourceLine" id="cb28-10" title="10">                  <span class="kw">let</span> (pops, remainingStack) <span class="fu">=</span> S.splitAt popsCount <span class="fu">$</span> cpuStack cpu <span class="kw">in</span></a>
<a class="sourceLine" id="cb28-11" title="11"></a>
<a class="sourceLine" id="cb28-12" title="12">                  <span class="kw">if</span> S.length params <span class="fu">&gt;</span> paramsCount </a>
<a class="sourceLine" id="cb28-13" title="13">                  <span class="kw">then</span></a>
<a class="sourceLine" id="cb28-14" title="14">                    cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;Code underflow&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb28-15" title="15">                  <span class="kw">else</span></a>
<a class="sourceLine" id="cb28-16" title="16">                    <span class="kw">if</span> <span class="fu">length</span> pops <span class="fu">&lt;</span> popsCount</a>
<a class="sourceLine" id="cb28-17" title="17">                    <span class="kw">then</span> cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;Stack underflow&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a></code></pre></div>
<ul>
<li>Get the parameter bytes from the code stream. E.g. Push takes a single param, the value to be pushed onto the stack</li>
<li>Pop the required number of values from the stack.</li>
<li>Check that both operations succeed</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1">                    <span class="kw">else</span></a>
<a class="sourceLine" id="cb29-2" title="2">                      <span class="co">-- Interpret the opcode using the simple/complex interpreter as indicated by the instruction</span></a>
<a class="sourceLine" id="cb29-3" title="3">                      <span class="kw">let</span> next <span class="fu">=</span> <span class="kw">if</span> opSimple instr <span class="kw">then</span></a>
<a class="sourceLine" id="cb29-4" title="4">                                   <span class="kw">let</span> res <span class="fu">=</span> interpretSimple emptyCpu { ip <span class="fu">=</span> atIp <span class="fu">+</span> paramsCount, state <span class="fu">=</span> <span class="fu">show</span> op } op (toList pops) params <span class="kw">in</span></a>
<a class="sourceLine" id="cb29-5" title="5">                                   cpu { ranOp <span class="fu">=</span> opByte</a>
<a class="sourceLine" id="cb29-6" title="6">                                       , cpuStack <span class="fu">=</span> cpuStack res <span class="fu">&lt;&gt;</span> remainingStack</a>
<a class="sourceLine" id="cb29-7" title="7">                                       , ip <span class="fu">=</span> ip res</a>
<a class="sourceLine" id="cb29-8" title="8">                                       , panic <span class="fu">=</span> panic res</a>
<a class="sourceLine" id="cb29-9" title="9">                                       , state <span class="fu">=</span> state res</a>
<a class="sourceLine" id="cb29-10" title="10">                                       }</a>
<a class="sourceLine" id="cb29-11" title="11">                                 <span class="kw">else</span></a>
<a class="sourceLine" id="cb29-12" title="12">                                   interpretComplex cpu { ip <span class="fu">=</span> atIp <span class="fu">+</span> paramsCount, state <span class="fu">=</span> <span class="fu">show</span> op, ranOp <span class="fu">=</span> opByte } op (toList pops) params remainingStack</a>
<a class="sourceLine" id="cb29-13" title="13">                                  </a>
<a class="sourceLine" id="cb29-14" title="14">                      <span class="kw">in</span> <span class="kw">if</span> panic next</a>
<a class="sourceLine" id="cb29-15" title="15">                      <span class="kw">then</span></a>
<a class="sourceLine" id="cb29-16" title="16">                        <span class="co">-- In panic state, add current CPU and stop executing</span></a>
<a class="sourceLine" id="cb29-17" title="17">                        next <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb29-18" title="18">                      <span class="kw">else</span></a>
<a class="sourceLine" id="cb29-19" title="19">                        <span class="co">-- Everything fine, add CPU and interpret nex byte</span></a>
<a class="sourceLine" id="cb29-20" title="20">                        interpret (next <span class="fu">:</span> cpus) code</a></code></pre></div>
<p>Finally the core interpreter code can be called. Since the params, pops are now stored as lists and all checks performed this code is quite simple.</p>
<ul>
<li>Remember that in this VM there are two types of <strong><em>Instructions</em></strong>; simple and complex. Simple instructions are fully defined by the <strong><em>Instruction</em></strong>. Complex instructions have full control over the CPU</li>
<li>Simple instructions are given an empty CPU and return a CPU with the values that need to be changed. For example simple instructions can not pop extra values or change the fp</li>
<li>Complex instructions are not fully defined by the <strong><em>Instruction</em></strong> and can change the CPU in any way they need to.</li>
</ul>
<h5 id="simple-instructions">Simple instructions</h5>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1">    <span class="co">-- | Simple instructions, can not directly change CPU state, e.g. cant set ip/fp and they just return data to be added to stack</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="ot">    interpretSimple ::</span> <span class="dt">Cpu</span> <span class="ot">-&gt;</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb30-3" title="3">    interpretSimple cpu op popped params <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-4" title="4">      <span class="kw">case</span> op <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-5" title="5">        <span class="dt">Nop</span> <span class="ot">-&gt;</span> cpu </a></code></pre></div>
<ul>
<li>Nop just returns the current CPU</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1">        <span class="dt">Push</span> <span class="ot">-&gt;</span> cpu { cpuStack <span class="fu">=</span> params }</a></code></pre></div>
<ul>
<li>Push sets the stack (appended with current stack in the interpreter code above)</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1">        <span class="dt">Pop</span> <span class="ot">-&gt;</span> cpu</a></code></pre></div>
<ul>
<li>Pop also just returns the CPU. This is because as a “simple” instruction the fact that it pops a single value is configured in the <strong><em>Instruction</em></strong> and the interpreter will do that.</li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1">        <span class="dt">Bne</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb33-2" title="2">        <span class="dt">Beq</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb33-3" title="3">        <span class="dt">Bgt</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb33-4" title="4">        <span class="dt">Bgte</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&gt;=</span>)</a>
<a class="sourceLine" id="cb33-5" title="5">        <span class="dt">Blt</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&lt;</span>)</a>
<a class="sourceLine" id="cb33-6" title="6">        <span class="dt">Blte</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&lt;=</span>)</a></code></pre></div>
<ul>
<li>The branch instructions call the <strong><em>branchIf</em></strong> function with the appropriate conditional operator</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1">    <span class="co">-- | Perform a branch instruction if the predicate for the op (beq, bne, bgte etc) is true</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="ot">    branchIf ::</span> <span class="dt">Cpu</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb34-3" title="3">    branchIf cpu popped params prd <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-4" title="4">      <span class="kw">case</span> <span class="fu">head</span> params <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-5" title="5">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> cpu { panic <span class="fu">=</span> <span class="dt">True</span>, state <span class="fu">=</span> <span class="st">&quot;missing param&quot;</span> }</a>
<a class="sourceLine" id="cb34-6" title="6">        <span class="dt">Just</span> jmp <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-7" title="7">          <span class="kw">case</span> popped <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-8" title="8">            [b, a] <span class="ot">-&gt;</span> cpu { ip <span class="fu">=</span> <span class="kw">if</span> prd a b <span class="kw">then</span> ip cpu <span class="fu">+</span> jmp <span class="kw">else</span> ip cpu } </a>
<a class="sourceLine" id="cb34-9" title="9">            _ <span class="ot">-&gt;</span> cpu { panic <span class="fu">=</span> <span class="dt">True</span>, state <span class="fu">=</span> <span class="st">&quot;invalid stack&quot;</span> }</a></code></pre></div>
<ul>
<li>The branch checks the predicate (prd) and if it is True the ip is updated to the ip specified by the branch.</li>
</ul>
<h5 id="complex-instructions">Complex Instructions</h5>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1">    <span class="co">-- | Complex instructions have full access to the CPU and must ensure the CPU is correctly setup for the next instruction</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="ot">    interpretComplex ::</span> <span class="dt">Cpu</span> <span class="ot">-&gt;</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb35-3" title="3">    interpretComplex cpu op popped params remainingStack <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-4" title="4">      <span class="kw">case</span> op <span class="kw">of</span></a></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1">        <span class="dt">Call</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb36-2" title="2">          <span class="co">-- Set up a stack frame and jump to the call location. See the comments above for details of the stack frame</span></a>
<a class="sourceLine" id="cb36-3" title="3">          singleVal cpu (toList params) (\v <span class="ot">-&gt;</span> cpu { ip <span class="fu">=</span> v <span class="fu">-</span> <span class="dv">1</span> <span class="co">-- 1 byte before method, next loop increments to function start byte</span></a>
<a class="sourceLine" id="cb36-4" title="4">                                                   , fp <span class="fu">=</span> S.length remainingStack <span class="co">-- frame pointer points to start of new stack frame</span></a>
<a class="sourceLine" id="cb36-5" title="5">                                                   , cpuStack <span class="fu">=</span> S.fromList [ip cpu <span class="fu">+</span> <span class="dv">1</span>, fp cpu] <span class="fu">&lt;&gt;</span> remainingStack <span class="co">-- add return ip and current fp to stack</span></a>
<a class="sourceLine" id="cb36-6" title="6">                                                   }) <span class="st">&quot;&quot;</span></a></code></pre></div>
<ul>
<li>Call creates a new CPU, setting the ip, fp and stack frame as discussed above in the section about Call &amp; Ret</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1">        <span class="dt">Ret</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-2" title="2">          <span class="co">-- Return to the calling code, get the previous frame pointer (fp) and return address from the current stack frame.</span></a>
<a class="sourceLine" id="cb37-3" title="3">          <span class="co">-- A ret always 'returns' a single value, the last item on the stack </span></a>
<a class="sourceLine" id="cb37-4" title="4">          <span class="kw">let</span> stackAtFp <span class="fu">=</span> S.drop (S.length remainingStack <span class="fu">-</span> fp cpu <span class="fu">-</span> <span class="dv">2</span>) remainingStack <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-5" title="5">          <span class="kw">let</span> (retParams, retStack) <span class="fu">=</span> S.splitAt <span class="dv">2</span> stackAtFp <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-6" title="6">          <span class="kw">if</span> S.length retParams <span class="fu">==</span> <span class="dv">2</span> <span class="kw">then</span></a>
<a class="sourceLine" id="cb37-7" title="7">            <span class="kw">let</span> [retIp, retFp] <span class="fu">=</span> toList retParams <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-8" title="8">            cpu { cpuStack <span class="fu">=</span> S.fromList popped <span class="fu">&lt;&gt;</span> retStack</a>
<a class="sourceLine" id="cb37-9" title="9">                , ip <span class="fu">=</span> retIp <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb37-10" title="10">                , fp <span class="fu">=</span> retFp</a>
<a class="sourceLine" id="cb37-11" title="11">                }</a>
<a class="sourceLine" id="cb37-12" title="12">          <span class="kw">else</span></a>
<a class="sourceLine" id="cb37-13" title="13">            cpu { panic <span class="fu">=</span> <span class="dt">True</span>, state <span class="fu">=</span> <span class="st">&quot;Stack underflow getting return frame&quot;</span> }            </a></code></pre></div>
<ul>
<li>Ret gets the old fp and the return address from the stack frame and constructs the new CPU to return to the caller.</li>
</ul>
<h2 id="whats-next">What’s next?</h2>
<p>This explanation of the stack machine is significantly longer than the code for it :). Hopefully you’ll be able to see how easy creating a simple stack machine is. There are many things than can be built on top of this. E.g.</p>
<ul>
<li>A higher level assembler with support for labels, i.e. don’t make the user count offsets</li>
<li>A simple higher level language that generates this new assembler code. E.g. stack/concatenative language or a functional language</li>
<li>Many more operators<br />
</li>
<li>Code optimisation</li>
<li>Support for globals</li>
<li>IO</li>
<li>…..</li>
</ul>
<h2 id="links">Links</h2>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Stack_machine" class="uri">https://en.wikipedia.org/wiki/Stack_machine</a></li>
<li><a href="https://github.com/sdiehl/protolude" class="uri">https://github.com/sdiehl/protolude</a></li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=OjaAToVkoTw" class="uri">https://www.youtube.com/watch?v=OjaAToVkoTw</a></li>
</ul>


        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        </div>

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-78428674-1', 'auto');
          ga('send', 'pageview');
        </script>
    </body>
</html>
