<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Andre's Blog</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <!-- <a href="/about.html">About</a> -->
            </div>
        </div>

        <div id="content">
            <h1><a href="#top">Parsing and generating ABIF files (DNA chromatograms)</a></h1>

            <div class="info">
    Posted on January  9, 2019
    
</div>

<h1 id="introduction">Introduction</h1>
<p><a href="https://github.com/hyraxbio/hyraxAbif">Hyrax ABIF</a> is a Haskell package, that I created at <a href="https://hyraxbio.co.za">HyraxBio</a> to test our bioinformatics software pipeline. We have released the <a href="https://hackage.haskell.org/package/hyraxAbif">HyraxAbif package</a> as open source (BSD3 licence) in the hopes that it will be useful to others.</p>
<p>In this post I’ll show how the package can be used as a standalone tool as well as looking at how the Haskell code works. <em>Skip directly to the usage / ABIF format / Haskell sections if that is all you are interested in reading about</em>.</p>
<h1 id="licence">Licence</h1>
<p>See the <a href="https://github.com/hyraxbio/hyraxAbif/blob/master/LICENSE">LICENCE</a> file. Please note that this package is distributed <em>without warranties or conditions of any kind</em>.</p>
<h1 id="chromatograms-some-basic-biology">Chromatograms &amp; some basic biology</h1>
<h2 id="chromatograms">Chromatograms</h2>
<p>Part of what we do at HyraxBio is analyze DNA sequences to determine drug resistance for various pathogens. The first step in this process getting DNA data from a sequencing machine. The mechanics of sequencing are pretty complex. Fortunately for us we start with the data already sequenced which means that all the “wet-work” is done and we can analyse and interpret the results as data, i.e. bioinformatics.</p>
<p>DNA is made up of four bases <code>A</code>, <code>C</code>, <code>G</code> and <code>T</code> (adenine, cytosine, guanine, and thymine respectively). A sequencing machine takes DNA strands and determines the sequences of bases that are present. There is a fair amount of complexity here. You can’t simply grab a strand of DNA and read it in its entirety and certainly not with 100% accuracy (because biology). Rather the DNA is amplified and a consensus of reads for each position in the DNA strand is calculated. There can be both (many) variations of the same virus (mutations) as well as errors in the reading process itself. So each position is calculated based on which of the bases have the strongest signal per position.</p>
<p>ABIF files are generated by these sequencing machines by using chemical reactions that release a tiny amount of coloured light when a reagent reacts with one of the bases. Each base results in a different colour which enables the machine to detect which base is present DNA. The details behind this are fascinating see e.g. <a href="https://en.wikipedia.org/wiki/DNA_sequencing">wikipedia</a> for more detail if you are interested.</p>
<p>Below is a section of a chromatogram showing a wave for each of the four bases.</p>
<p><img src="../images/abif_chromatogram_bases.png" /></p>
<p>This is a perfect chromatogram, there are often multiple possibilities per position of different intensity. In the image below you can see that the second and third positions have more than one possible base, this is called a mix.</p>
<p><img src="../images/abif_chromatogram_no_label.png" /></p>
<p>Even that is an unnaturally clean chromatogram. In reality they often look more like this, and take complicated base calling software and/or trained lab workers (or overworked PHD students) to decide on what base is actually represented.</p>
<p><img src="../images/abif_chromatogram_real.png" /></p>
<p>The chromatogram data in ABIF format is fed into base calling software like <a href="http://www.phrap.com/phred/">PHRED</a> and/or <a href="https://pssm.cfenet.ubc.ca/wiki">recall</a> which analyze the chromatogram and decide on which base to call per position. The result being a string of bases (A/C/G/T).</p>
<h2 id="why-we-created-hyraxabif">Why we created hyraxAbif</h2>
<p>Testing a full bioinformatics pipeline is critical to ensuring that every step works correctly and results in high quality outputs. The problem is that we could find no practical existing way to generate our own chromatograms (ABIFs). It is possible to use a set of existing ABIF files but this has two major problems</p>
<ul>
<li>These are DNA sequences from real people so there are confidentiality issues</li>
<li>More practically, we needed very specific input data to test decisions further down the pipeline and finding real data with the exact mutations and no others is not realistic.</li>
</ul>
<p>HyraxABIF was created to resolve this. It lets us easily create chromatograms from a DNA sequence and thus do all the testing we need to.</p>
<h2 id="a-bit-more-biology">A bit more biology</h2>
<p><img src="../images/abif_chromatogram_hyrax.png" /></p>
<p>The image above has a bit more detail, it shows the bases including ambiguous ones as well as the amino acids.</p>
<h3 id="ambiguous-bases">Ambiguous bases</h3>
<p>As discussed above there could be multiple possibilities per position. The IUPAC ambiguity codes (see <a href="https://en.wikipedia.org/wiki/Nucleic_acid_notation">wikipedia</a> ) or <a href="https://www.bioinformatics.org/sms/iupac.html">bioinformatics.org</a> are a way of encoding the ambiguity in a single letter. For example a <code>Y</code> IUPAC code means that the base is either a <code>C</code> or a <code>T</code>.</p>
<h3 id="amino-acids">Amino acids</h3>
<p>Each group of three nucleotide bases is called a codon and encodes for a single amino acid (in coding regions…). The chromatogram also shows the amino acid per codon. This is not important to know for this post but may help if you see other pictures of other chromatograms as this will usually be show.</p>
<h1 id="using-the-application">Using the application</h1>
<p>HyraxAbif’s primary goal was for generating chromatograms from an input DNA sequence. It can be installed from <a href="https://hackage.haskell.org/package/hyraxAbif">hackage with cabal</a>, from stack, or by cloning the <a href="https://github.com/hyraxbio/hyraxAbif">git repo</a>.</p>
<h2 id="generating-a-simple-abif">Generating a simple ABIF</h2>
<p>The input for generating a chromatogram is a simplified <a href="https://en.wikipedia.org/wiki/FASTA_format">FASTA format file</a>. These files look like this</p>
<pre class="text"><code>&gt; 1
ACTG</code></pre>
<p>The first line is the weight (more on this later), the second is the DNA sequence. Given this input file you would run</p>
<p><code>hyraxAbif-exe gen inputDir/ outputDir/</code></p>
<p>and you would end up with a ABIF file and a chromatogram like this</p>
<p><img src="../images/abif_chromatogram_bases.png" /></p>
<p>For many scenarios this is all you’ll need. You create a folder of FASTA input files and get a folder of generated corresponding ABIF files.</p>
<h3 id="generating-more-complex-chromatograms">Generating more complex chromatograms</h3>
<p>You can also generate chromatograms with mixes. The first line has the weight for the sequence, and each FASTA file can contain multiple reads.</p>
<pre class="text"><code>&gt; weight
read
&gt; weight
read</code></pre>
<ul>
<li>The weight is a numeric value between 0 and 1 that specifies the weight of the current read i.e. the intensity of the peak.</li>
<li>No other header/name is allowed (no quality data / naming etc)</li>
<li>The read is the set of input nucleotides, <a href="https://www.bioinformatics.org/sms/iupac.html">IUPAC</a> ambiguity codes are supported (MRWSYKVHDBNX).</li>
<li>A read can be single or multi-line</li>
<li>Weights for each position are summed to a maximum of 1.0 per nucleotide</li>
<li>You can use _ as a “blank” nucleotide, in which case only the nucleotides from other reads will be considered</li>
<li>Reads need not be the same length</li>
</ul>
<p>For example</p>
<pre class="text"><code>&gt; 0.5
ACG
&gt; 0.3
AAAA
&gt; 1
__AC</code></pre>
<p>Results in the following weighted nucleotide per position</p>
<table>
<thead>
<tr class="header">
<th>position</th>
<th>A</th>
<th>C</th>
<th>G</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0.5 + 0.3 = 0.8</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0.3</td>
<td>0.5</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0.3 + 1 = 1.0</td>
<td>0</td>
<td>0.5</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>0.3</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><em>Note that 0.3 + 1.0 = 1.0 because the max value is 1.0</em></p>
<p>And this sample</p>
<pre class="text"><code>&gt; 1
ACAG
&gt; 0.3
_GT
&gt; 0.2
_G</code></pre>
<p>results in this chromatogram</p>
<p><img src="../images/abif_chromatogram_mix.png" /></p>
<p>The <a href="https://www.bioinformatics.org/sms/iupac.html">IUPAC</a> codes here are</p>
<ul>
<li><code>S</code> = <code>G</code> or <code>C</code></li>
<li><code>W</code> = <code>A</code> or <code>T</code></li>
</ul>
<h3 id="reverse-reads">Reverse reads</h3>
<p>A weighted FASTA can represent a reverse read. To do this add a <code>R</code> suffix to the weight. The data you enter should be entered as if it was a forward read. This data will be complemented and reversed before writing to the ABIF</p>
<pre class="text"><code>&gt; 0.9R
ACAG</code></pre>
<p>which results in the sequence <code>TGTC</code></p>
<h2 id="dumping-an-existing-abif-file">Dumping an existing ABIF file</h2>
<p>You can also dump an existing ABIF file</p>
<p><code>hyraxAbif-exe dump sample.abif</code></p>
<p>This prints two views of the file. First a detail view, partially show below</p>
<p><img src="../images/abif_dump_top.png" /></p>
<p>and then a summary</p>
<p><img src="../images/abif_dump_bottom.png" /></p>
<p>For certain types of data (e.g. strings) the parsed value is displayed.</p>
<h1 id="the-abif-file-format">The ABIF file format</h1>
<p>The ABIF format is <a href="http://www6.appliedbiosystems.com/support/software_community/ABIF_File_Format.pdf">documented here</a>. As you can see from the spec the ABIF format <em>was modeled after the TIFF format</em>. This means that there is a directory of entries and each entry has a data type.</p>
<p>The spec is quite thorough and explains the layout well. If you are wanting to understand the format it is your best starting point. The spec, however, only goes into detail on the ABIF structure. It does not go into much detail on how the chromatogram data itself is stored, I’ll cover that here.</p>
<p>In the file after the ABIF header and version number is the root directory entry. This entry points to the first of the data directory entries that can be located at any other location in the file.</p>
<p>Each directory entry has an offset to the location of its data in the file, the data size, the element size and number of entries. See the spec or the discussion of the Haskell code below for more details on each field.</p>
<p>Note that for data with a size of four bytes or less, the data is stored in the offset field itself.</p>
<p><img src="../images/abif_directory.png" /></p>
<h2 id="important-abif-directory-entries">Important ABIF directory entries</h2>
<p>Towards the end of the spec are examples of the layout of ABIF files for a few sequencing machines. Lets take a look at some of these for the 3500 layout.</p>
<h3 id="chromatogram-traces">Chromatogram traces</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 7%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Tag Number</th>
<th>Contains</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DATA</td>
<td>1 - 4</td>
<td>The raw data per base (channel). The order of the bases is specified by the FWO_ entry</td>
</tr>
<tr class="even">
<td>DATA</td>
<td>5</td>
<td>Short Array holding measured volts/10 (EP voltage) during run</td>
</tr>
<tr class="odd">
<td>DATA</td>
<td>6</td>
<td>Short Array holding measured milliAmps trace (EP current) during run</td>
</tr>
<tr class="even">
<td>DATA</td>
<td>7</td>
<td>Short Array holding measured milliWatts trace (Laser EP Power) during</td>
</tr>
<tr class="odd">
<td>DATA</td>
<td>8</td>
<td>Short Array holding measured oven Temperature (polymer temperature) trace during run</td>
</tr>
<tr class="even">
<td>DATA</td>
<td>9 - 12</td>
<td>Short Array holding analyzed color data</td>
</tr>
</tbody>
</table>
<p>This is a pretty intimidating set of values we thought we would have to generate from a FASTA input, just for the traces. Fortunately through trial and error we were able to see that only a small subset of the entries were required for the base calling software we were using (PHRED + Recall). All we needed to generate were the data sections 9 to 12, i.e. one per base, the <em>analyzed colour data</em>.</p>
<p>The four DATA sections we need to generate (entries 9 through 12) contain an array of shorts. Each short represents the intensity of the light for that base at a given point. Each of these DATA sections have the wave of the light intensity over time. The <strong>FWO_</strong> directory entry specifies which base each DATA entry represents. We always generate it in the 3500 format, so the order is <code>9=G</code>, <code>10=A</code>, <code>11=T</code>, <code>12=C</code>.</p>
<h3 id="peak-location">Peak location</h3>
<p>The traces above are just the wave form, the <strong>PLOC</strong> entry specifies the location of each peak. This is the location, across all four DATA entries, where the peak of the waves should be found. There is a single <strong>PLOC</strong> entry for all four <strong>DATA</strong> entries.</p>
<p><img src="../images/abif_peaks.png" /></p>
<h3 id="other-required-entries">Other required entries</h3>
<p>The other required entries are easy to generate, they are things like the base order (FWO_), file name (PDMF) and called based (PBAS). See the Haskell code discussion below to see them all.</p>
<h3 id="generating-the-waveforms">Generating the waveforms</h3>
<p>Given a base, we then need to create a wave and a single peak location entry. The data we use for each wave is this array of shorts <code>[0, 0, 128, 512, 1024, 1024, 512, 128, 0, 0]</code> which creates a wave like this.</p>
<p><img src="../images/abif_wave.png" /></p>
<p>The peak is the middle of the wave, nice and simple.</p>
<p>Again see the code discussion for more details in this.</p>
<h1 id="using-the-code-some-basic-examples">Using the code, some basic examples</h1>
<h2 id="reading-and-printing-the-abif-structure">Reading and printing the ABIF structure</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">module</span> <span class="dt">Examples.ReadAb1</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Hyrax.Abif.Read</span> <span class="kw">as</span> <span class="dt">H</span></a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="co">-- | Read and print a ABIF file</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="ot">readAbif ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-11" title="11">readAbif <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-12" title="12">  abif' <span class="ot">&lt;-</span> H.readAbif <span class="st">&quot;example.ab1&quot;</span></a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14">  <span class="kw">case</span> abif' <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;error reading ABIF: &quot;</span> <span class="fu">&lt;&gt;</span> e</a>
<a class="sourceLine" id="cb6-16" title="16">    <span class="dt">Right</span> abif <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-17" title="17">      <span class="co">-- Print after removing the data, to make it readable</span></a>
<a class="sourceLine" id="cb6-18" title="18">      <span class="fu">print</span> <span class="fu">$</span> H.clearAbif abif</a></code></pre></div>
<ol type="1">
<li><code>readAbif</code> tries to parse an ABIF file, it returns an <code>Either Text Abif</code></li>
<li>Check if the file was parsed successfully</li>
<li>If not (<strong>Left</strong>) then print the error</li>
<li>If successful (<strong>Right</strong>) then
<ol type="1">
<li><code>clearAbif</code> removes all the raw data. If you don’t do this then all the massive byte arrays will get printed too</li>
<li><code>print</code> the result.</li>
</ol></li>
</ol>
<p>The functions are all commented and visible on <a href="https://hackage.haskell.org/package/hyraxAbif">hackage</a>.</p>
<h2 id="adding-a-comment-to-an-existing-abif">Adding a comment to an existing ABIF</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">module</span> <span class="dt">Examples.AddComment</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Hyrax.Abif.Read</span> <span class="kw">as</span> <span class="dt">H</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Hyrax.Abif.Write</span> <span class="kw">as</span> <span class="dt">H</span></a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">-- | Add a comment to an existing AB1 file</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="ot">addComment ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-12" title="12">addComment <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-13" title="13">  abif' <span class="ot">&lt;-</span> H.readAbif <span class="st">&quot;example.ab1&quot;</span></a>
<a class="sourceLine" id="cb7-14" title="14"></a>
<a class="sourceLine" id="cb7-15" title="15">  <span class="kw">case</span> abif' <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-16" title="16">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;error reading ABIF: &quot;</span> <span class="fu">&lt;&gt;</span> e</a>
<a class="sourceLine" id="cb7-17" title="17">    <span class="dt">Right</span> abif <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-18" title="18">      <span class="kw">let</span> modified <span class="fu">=</span> H.addDirectory abif <span class="fu">$</span> H.mkComment <span class="st">&quot;new comment&quot;</span></a>
<a class="sourceLine" id="cb7-19" title="19">      H.writeAbif <span class="st">&quot;example.modified.ab1&quot;</span> modified</a></code></pre></div>
<p>Only the <strong>Right</strong> case is different than the previous example</p>
<ol type="1">
<li><code>addDirectory</code> is called to add a new comment directory entry that is created by <code>mkComment</code></li>
<li><code>writeAbif</code> writes the updated file to disk</li>
</ol>
<h2 id="more-examples">More examples</h2>
<p>The <code>Examples</code> directory contains more examples. You can also look at the <code>Generate</code> and <code>Main</code> modules to see how the code is used.</p>
<h1 id="understanding-the-code">Understanding the code</h1>
<h2 id="data.binary">Data.Binary</h2>
<p><a href="http://hackage.haskell.org/package/binary">Data.Binary</a> is used to read and write the raw bytes in the ABIF files.</p>
<h3 id="writing">Writing</h3>
<p>Below is an example of writing two Int8 and an Int32 value.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">import</span> <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Binary.Put</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BSL</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-11" title="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-12" title="12">  <span class="kw">let</span> outData <span class="fu">=</span> B.runPut testWrite</a>
<a class="sourceLine" id="cb8-13" title="13">  BSL.writeFile <span class="st">&quot;test.dat&quot;</span> outData</a>
<a class="sourceLine" id="cb8-14" title="14"></a>
<a class="sourceLine" id="cb8-15" title="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="ot">    testWrite ::</span> <span class="dt">B.PutM</span> ()</a>
<a class="sourceLine" id="cb8-17" title="17">    testWrite <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-18" title="18">      B.putInt8 <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-19" title="19">      B.putInt8 <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-20" title="20">      B.putInt32be <span class="dv">3</span></a></code></pre></div>
<p><code>runPut</code> “runs” the <code>PutM</code> monad. <code>testWrite</code> can then simply call the <code>put*</code> functions to write the data in whatever format is required.</p>
<p>This creates a file that looks like this</p>
<p><img src="../images/abif_binary_file.png" /></p>
<h3 id="reading">Reading</h3>
<p>Reading the data from the file looks like this</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">import</span> <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Binary.Get</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BSL</span></a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9"></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-11" title="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-12" title="12">  inData <span class="ot">&lt;-</span> BSL.readFile <span class="st">&quot;test.dat&quot;</span></a>
<a class="sourceLine" id="cb9-13" title="13">  <span class="kw">let</span> <span class="fu">read</span> <span class="fu">=</span> B.runGet testRead inData</a>
<a class="sourceLine" id="cb9-14" title="14">  <span class="fu">print</span> <span class="fu">read</span></a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-17" title="17"><span class="ot">    testRead ::</span> <span class="dt">B.Get</span> (<span class="dt">Int8</span>, <span class="dt">Int8</span>, <span class="dt">Int32</span>)</a>
<a class="sourceLine" id="cb9-18" title="18">    testRead <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-19" title="19">      a <span class="ot">&lt;-</span> B.getInt8</a>
<a class="sourceLine" id="cb9-20" title="20">      b <span class="ot">&lt;-</span> B.getInt8</a>
<a class="sourceLine" id="cb9-21" title="21">      c <span class="ot">&lt;-</span> B.getInt32be</a>
<a class="sourceLine" id="cb9-22" title="22">      <span class="fu">pure</span> (a, b, c)</a></code></pre></div>
<p><code>runGet</code> is given the ByteString from the file and <code>testRead</code> gets the values in the appropriate format.</p>
<p>If you prefer applicatives you could instead have written <code>testGet</code> as</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">(,,) <span class="fu">&lt;$&gt;</span> B.getInt8 <span class="fu">&lt;*&gt;</span> B.getInt8 <span class="fu">&lt;*&gt;</span> B.getInt32be</a></code></pre></div>
<p>and <code>testWrite</code> as</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">B.putInt8 <span class="dv">1</span> <span class="fu">*&gt;</span> B.putInt8 <span class="dv">2</span> <span class="fu">*&gt;</span> B.putInt32be <span class="dv">3</span></a></code></pre></div>
<h2 id="abif-types">ABIF Types</h2>
<p><strong>Hyrax.Abif</strong> contains the core types for the package</p>
<h6 id="srchyraxabif.hs-22-to-32">src/Hyrax/Abif.hs (22 to 32)</h6>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">module</span> <span class="dt">Hyrax.Abif</span></a>
<a class="sourceLine" id="cb12-2" title="2">    ( <span class="dt">Abif</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb12-3" title="3">    , <span class="dt">Header</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb12-4" title="4">    , <span class="dt">Directory</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb12-5" title="5">    , <span class="dt">ElemType</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb12-6" title="6">    , getElemType</a>
<a class="sourceLine" id="cb12-7" title="7">    , describeElemType</a>
<a class="sourceLine" id="cb12-8" title="8">    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" title="9"></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BSL</span></a></code></pre></div>
<h6 id="srchyraxabif.hs-37-to-64">src/Hyrax/Abif.hs (37 to 64)</h6>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="co">-- | A single ABIF</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">data</span> <span class="dt">Abif</span> <span class="fu">=</span> <span class="dt">Abif</span> {<span class="ot"> aHeader ::</span> <span class="fu">!</span><span class="dt">Header</span></a>
<a class="sourceLine" id="cb13-3" title="3">                 ,<span class="ot"> aRootDir ::</span> <span class="fu">!</span><span class="dt">Directory</span></a>
<a class="sourceLine" id="cb13-4" title="4">                 ,<span class="ot"> aDirs ::</span> <span class="fu">!</span>[<span class="dt">Directory</span>]</a>
<a class="sourceLine" id="cb13-5" title="5">                 } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="co">-- | ABIF header</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="kw">data</span> <span class="dt">Header</span> <span class="fu">=</span> <span class="dt">Header</span> {<span class="ot"> hName ::</span> <span class="fu">!</span><span class="dt">Text</span></a>
<a class="sourceLine" id="cb13-10" title="10">                     ,<span class="ot"> hVersion ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-11" title="11">                     } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="co">-- | ABIF directory entry.</span></a>
<a class="sourceLine" id="cb13-14" title="14"><span class="co">-- The 'dData' field contains the data for the entry</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="kw">data</span> <span class="dt">Directory</span> <span class="fu">=</span> <span class="dt">Directory</span> {<span class="ot"> dTagName ::</span> <span class="fu">!</span><span class="dt">Text</span>        <span class="co">-- ^ Tag name</span></a>
<a class="sourceLine" id="cb13-16" title="16">                           ,<span class="ot"> dTagNum ::</span> <span class="fu">!</span><span class="dt">Int</span>          <span class="co">-- ^ Tag number, see e.g. how DATA entries use this</span></a>
<a class="sourceLine" id="cb13-17" title="17">                           ,<span class="ot"> dElemType ::</span> <span class="fu">!</span><span class="dt">ElemType</span>   <span class="co">-- ^ Type of an element</span></a>
<a class="sourceLine" id="cb13-18" title="18">                           ,<span class="ot"> dElemTypeCode ::</span> <span class="fu">!</span><span class="dt">Int</span>    <span class="co">-- ^ Integer value of 'dElemType'</span></a>
<a class="sourceLine" id="cb13-19" title="19">                           ,<span class="ot"> dElemTypeDesc ::</span> <span class="fu">!</span><span class="dt">Text</span>   <span class="co">-- ^ Description of 'dElemType'</span></a>
<a class="sourceLine" id="cb13-20" title="20">                           ,<span class="ot"> dElemSize ::</span> <span class="fu">!</span><span class="dt">Int</span>        <span class="co">-- ^ Size in bytes of each element</span></a>
<a class="sourceLine" id="cb13-21" title="21">                           ,<span class="ot"> dElemNum ::</span> <span class="fu">!</span><span class="dt">Int</span>         <span class="co">-- ^ Number of elements in the data. See the spec per data type. E.g. for a string this is the number of characters</span></a>
<a class="sourceLine" id="cb13-22" title="22">                           ,<span class="ot"> dDataSize ::</span> <span class="fu">!</span><span class="dt">Int</span>        <span class="co">-- ^ Number of bytes in the data</span></a>
<a class="sourceLine" id="cb13-23" title="23">                           ,<span class="ot"> dDataOffset ::</span> <span class="fu">!</span><span class="dt">Int</span>      <span class="co">-- ^ Offset of this directory entry's data in the file. For data that is four</span></a>
<a class="sourceLine" id="cb13-24" title="24">                                                      <span class="co">--    bytes or less, the data itself is stored in this field.</span></a>
<a class="sourceLine" id="cb13-25" title="25">                                                      <span class="co">--    This value will be recalculated when writing an ABIF so you do not need to manually set it.</span></a>
<a class="sourceLine" id="cb13-26" title="26">                           ,<span class="ot"> dData ::</span> <span class="fu">!</span><span class="dt">BSL.ByteString</span> <span class="co">-- ^ The entry's data</span></a>
<a class="sourceLine" id="cb13-27" title="27">                           ,<span class="ot"> dDataDebug ::</span> <span class="fu">!</span>[<span class="dt">Text</span>]    <span class="co">-- ^ Optinal debug data, populated by 'Hyrax.Abif.Read.getDebug' when a ABIF is parsed</span></a>
<a class="sourceLine" id="cb13-28" title="28">                           } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>These three types make up most of what we need to represent an ABIF. A few things to notice</p>
<ul>
<li>The root directory in the <code>Abif</code> type will point to the array of <code>Directory</code> entries</li>
<li><code>dElemTypeCode</code> is the integer value read from the file (see the spec for the codes). <code>dElemType</code> and <code>dElemTypeDesc</code> are interpreted values from this</li>
<li><code>dElemSize</code> and <code>dElemOffset</code> are read from the file, but are automatically calculated when writing (see the Hyrax.Abif.Write section below)</li>
<li><code>dData</code> is the actual raw data read from the file, or data to be written to an ABIF file</li>
<li><code>dDataDebug</code> is populated while reading the file and used during dumping to give human readable info about the file being inspected.</li>
</ul>
<h3 id="element-types">Element types</h3>
<p>The remaining code is the definition of <code>ElemType</code> and functions for interpreting the raw element type integer value. Note that the spec defines a number of unsupported data types, these are included here.</p>
<h2 id="hyrax.abif.read">Hyrax.Abif.Read</h2>
<h3 id="starting-the-read">Starting the read</h3>
<p><code>readAbif</code> calls <code>getAbif</code> to parse the data</p>
<h6 id="srchyraxabifread.hs-51-to-53">src/Hyrax/Abif/Read.hs (51 to 53)</h6>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="co">-- | Read and parse an AB1 file</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="ot">readAbif ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Abif</span>)</a>
<a class="sourceLine" id="cb14-3" title="3">readAbif path <span class="fu">=</span> getAbif <span class="fu">&lt;$&gt;</span> BSL.readFile path</a></code></pre></div>
<p><code>getAbif</code> starts the parsing of the <code>Abif</code> data structure.</p>
<h6 id="srchyraxabifread.hs-58-to-75">src/Hyrax/Abif/Read.hs (58 to 75)</h6>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="co">-- | Parse an AB1 from a 'ByteString'</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ot">getAbif ::</span> <span class="dt">BSL.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Abif</span></a>
<a class="sourceLine" id="cb15-3" title="3">getAbif bs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-4" title="4">  (header, rootDir) <span class="ot">&lt;-</span> <span class="kw">case</span> B.runGetOrFail (getRoot bs) bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-5" title="5">                         <span class="dt">Right</span> (_, _, x) <span class="ot">-&gt;</span> <span class="fu">pure</span> x</a>
<a class="sourceLine" id="cb15-6" title="6">                         <span class="dt">Left</span> (_, _, e) <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="st">&quot;Error reading root: &quot;</span> <span class="fu">&lt;&gt;</span> Txt.pack e)</a>
<a class="sourceLine" id="cb15-7" title="7"></a>
<a class="sourceLine" id="cb15-8" title="8">  <span class="kw">let</span> dirBytes <span class="fu">=</span> BSL.drop (<span class="fu">fromIntegral</span> <span class="fu">$</span> dDataOffset rootDir) bs</a>
<a class="sourceLine" id="cb15-9" title="9">  </a>
<a class="sourceLine" id="cb15-10" title="10">  ds <span class="ot">&lt;-</span> <span class="kw">case</span> B.runGetOrFail (getDirectories bs [] <span class="fu">$</span> dElemNum rootDir) dirBytes <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-11" title="11">          <span class="dt">Right</span> (_, _, x) <span class="ot">-&gt;</span> <span class="fu">pure</span> x</a>
<a class="sourceLine" id="cb15-12" title="12">          <span class="dt">Left</span> (_, _, e) <span class="ot">-&gt;</span> <span class="dt">Left</span> (<span class="st">&quot;Error reading &quot;</span></a>
<a class="sourceLine" id="cb15-13" title="13">                                  <span class="fu">&lt;&gt;</span> <span class="fu">show</span> (dElemNum rootDir)</a>
<a class="sourceLine" id="cb15-14" title="14">                                  <span class="fu">&lt;&gt;</span> <span class="st">&quot; directories (at &quot;</span> <span class="fu">&lt;&gt;</span> <span class="fu">show</span> (dDataOffset rootDir) <span class="fu">&lt;&gt;</span> <span class="st">&quot;): &quot;</span></a>
<a class="sourceLine" id="cb15-15" title="15">                                  <span class="fu">&lt;&gt;</span> Txt.pack e</a>
<a class="sourceLine" id="cb15-16" title="16">                                 )</a>
<a class="sourceLine" id="cb15-17" title="17">  </a>
<a class="sourceLine" id="cb15-18" title="18">  <span class="fu">pure</span> <span class="fu">$</span> <span class="dt">Abif</span> header rootDir ds</a></code></pre></div>
<ul>
<li>The <code>Either</code> monad is used so any <code>Left</code> value will short-circuit out of the function and return the <code>Left</code> value immediately.</li>
<li><code>Data.Binary.runGetOrFail</code> returns a <code>Left</code> if the get operation fails. Much better than getting an exception as you would with <code>runGet</code></li>
<li>The first step is to read the header and the root directory</li>
<li>Then the ABIF directory entries are read. These directories are found at the offset specified in the root directory. The code “goes” to this offset by dropping the number of bytes from the read data.</li>
<li><code>getDirectories</code> reads the number of directory entries specified by the root entry.</li>
</ul>
<p><code>getRoot</code> gets the header and root directory (see next section)</p>
<h6 id="srchyraxabifread.hs-218-to-223">src/Hyrax/Abif/Read.hs (218 to 223)</h6>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="co">-- | Parse the root ('Header' and 'Directory')</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="ot">getRoot ::</span> <span class="dt">BSL.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.Get</span> (<span class="dt">Header</span>, <span class="dt">Directory</span>)</a>
<a class="sourceLine" id="cb16-3" title="3">getRoot bs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-4" title="4">  h <span class="ot">&lt;-</span> getHeader</a>
<a class="sourceLine" id="cb16-5" title="5">  rd <span class="ot">&lt;-</span> getDirectory bs</a>
<a class="sourceLine" id="cb16-6" title="6">  <span class="fu">pure</span> (h, rd)</a></code></pre></div>
<p><code>getHeader</code> gets the “ABIF” magic string and version number. Similar to the read example above.</p>
<h6 id="srchyraxabifread.hs-209-to-213">src/Hyrax/Abif/Read.hs (209 to 213)</h6>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="co">-- | Parse the ABIF 'Header'</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="ot">getHeader ::</span> <span class="dt">B.Get</span> <span class="dt">Header</span></a>
<a class="sourceLine" id="cb17-3" title="3">getHeader <span class="fu">=</span> </a>
<a class="sourceLine" id="cb17-4" title="4">  <span class="dt">Header</span> <span class="fu">&lt;$&gt;</span> (TxtE.decodeUtf8 <span class="fu">&lt;$&gt;</span> B.getByteString <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb17-5" title="5">         <span class="fu">&lt;*&gt;</span> (<span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt16be)</a></code></pre></div>
<h3 id="reading-directories">Reading directories</h3>
<p><code>getDirectories</code> is given the number of directories to read. It tries to read a single <code>Directory</code> by calling <code>getDirectory</code> and then recursively calls itself until done.</p>
<h6 id="srchyraxabifread.hs-272-to-279">src/Hyrax/Abif/Read.hs (272 to 279)</h6>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="co">-- | Parse all the directoy entries</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="ot">getDirectories ::</span> <span class="dt">BSL.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">Directory</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">B.Get</span> [<span class="dt">Directory</span>]</a>
<a class="sourceLine" id="cb18-3" title="3">getDirectories _ acc <span class="dv">0</span> <span class="fu">=</span> <span class="fu">pure</span> acc</a>
<a class="sourceLine" id="cb18-4" title="4">getDirectories bs acc more <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-5" title="5">  d <span class="ot">&lt;-</span> getDirectory bs</a>
<a class="sourceLine" id="cb18-6" title="6">  B.skip <span class="dv">4</span> <span class="co">-- Skip the reserved field</span></a>
<a class="sourceLine" id="cb18-7" title="7">  getDirectories bs (acc <span class="fu">&lt;&gt;</span> [d]) (more <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-8" title="8"></a></code></pre></div>
<p>Reading and individual directory is done by <code>getDirectory</code>.</p>
<ul>
<li>Read the values and convert into appropriate types (e.g. Int8 to Int)</li>
<li>If the data is four bytes or less then the offset field contains the data</li>
<li>If the data is larger than four bytes, go to the offset and read the entire chunk as a <code>ByteString</code>.</li>
<li>Create a <code>Abif</code> value</li>
</ul>
<h6 id="srchyraxabifread.hs-228-to-267">src/Hyrax/Abif/Read.hs (228 to 267)</h6>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="co">-- | Parse a single 'Directory' entry and read its data</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="ot">getDirectory ::</span> <span class="dt">BSL.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.Get</span> <span class="dt">Directory</span></a>
<a class="sourceLine" id="cb19-3" title="3">getDirectory bs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-4" title="4">  tagName <span class="ot">&lt;-</span> TxtE.decodeUtf8 <span class="fu">&lt;$&gt;</span> B.getByteString <span class="dv">4</span></a>
<a class="sourceLine" id="cb19-5" title="5">  tagNum <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt32be</a>
<a class="sourceLine" id="cb19-6" title="6">  typeCode <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt16be</a>
<a class="sourceLine" id="cb19-7" title="7">  elemSize <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt16be</a>
<a class="sourceLine" id="cb19-8" title="8">  elemNum <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt32be</a>
<a class="sourceLine" id="cb19-9" title="9">  dataSize <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt32be</a>
<a class="sourceLine" id="cb19-10" title="10">  offsetDataBytes <span class="ot">&lt;-</span> B.lookAhead <span class="fu">$</span> B.getLazyByteString <span class="dv">4</span></a>
<a class="sourceLine" id="cb19-11" title="11">  dataOffset <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt32be</a>
<a class="sourceLine" id="cb19-12" title="12"></a>
<a class="sourceLine" id="cb19-13" title="13">  <span class="co">-- Read the data</span></a>
<a class="sourceLine" id="cb19-14" title="14">  <span class="co">--  Data that is 4 bytes or less is stored in the offset field</span></a>
<a class="sourceLine" id="cb19-15" title="15">  dataBytes <span class="ot">&lt;-</span> <span class="kw">if</span> dataSize <span class="fu">&lt;=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb19-16" title="16">                    <span class="kw">then</span> <span class="fu">pure</span> <span class="fu">$</span> BSL.take (<span class="fu">fromIntegral</span> dataSize) offsetDataBytes</a>
<a class="sourceLine" id="cb19-17" title="17">                    <span class="kw">else</span> <span class="kw">case</span> B.runGetOrFail (B.getLazyByteString <span class="fu">$</span> <span class="fu">fromIntegral</span> dataSize) <span class="fu">$</span> BSL.drop (<span class="fu">fromIntegral</span> dataOffset) bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-18" title="18">                           <span class="dt">Right</span> (_, _, x) <span class="ot">-&gt;</span> <span class="fu">pure</span> x</a>
<a class="sourceLine" id="cb19-19" title="19">                           <span class="dt">Left</span> (_, _, e) <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="fu">$</span> <span class="st">&quot;error reading data (&quot;</span></a>
<a class="sourceLine" id="cb19-20" title="20">                                                    <span class="fu">&lt;&gt;</span> <span class="fu">show</span> dataSize</a>
<a class="sourceLine" id="cb19-21" title="21">                                                    <span class="fu">&lt;&gt;</span> <span class="st">&quot; bytes starting at &quot;</span></a>
<a class="sourceLine" id="cb19-22" title="22">                                                    <span class="fu">&lt;&gt;</span> <span class="fu">show</span> dataOffset</a>
<a class="sourceLine" id="cb19-23" title="23">                                                    <span class="fu">&lt;&gt;</span> <span class="st">&quot;) for directory entry '&quot;</span></a>
<a class="sourceLine" id="cb19-24" title="24">                                                    <span class="fu">&lt;&gt;</span> Txt.unpack tagName</a>
<a class="sourceLine" id="cb19-25" title="25">                                                    <span class="fu">&lt;&gt;</span> <span class="st">&quot;': &quot;</span></a>
<a class="sourceLine" id="cb19-26" title="26">                                                    <span class="fu">&lt;&gt;</span> e</a>
<a class="sourceLine" id="cb19-27" title="27"></a>
<a class="sourceLine" id="cb19-28" title="28">  <span class="kw">let</span> (elemType, elemCode) <span class="fu">=</span> describeElemType typeCode</a>
<a class="sourceLine" id="cb19-29" title="29">  <span class="fu">pure</span> <span class="dt">Directory</span> { dTagName <span class="fu">=</span> tagName </a>
<a class="sourceLine" id="cb19-30" title="30">                 , dTagNum <span class="fu">=</span> tagNum </a>
<a class="sourceLine" id="cb19-31" title="31">                 , dElemTypeCode <span class="fu">=</span> typeCode </a>
<a class="sourceLine" id="cb19-32" title="32">                 , dElemTypeDesc <span class="fu">=</span> elemCode </a>
<a class="sourceLine" id="cb19-33" title="33">                 , dElemType <span class="fu">=</span> elemType </a>
<a class="sourceLine" id="cb19-34" title="34">                 , dElemSize <span class="fu">=</span> elemSize </a>
<a class="sourceLine" id="cb19-35" title="35">                 , dElemNum <span class="fu">=</span> elemNum </a>
<a class="sourceLine" id="cb19-36" title="36">                 , dDataSize <span class="fu">=</span> dataSize </a>
<a class="sourceLine" id="cb19-37" title="37">                 , dDataOffset <span class="fu">=</span> dataOffset </a>
<a class="sourceLine" id="cb19-38" title="38">                 , dData <span class="fu">=</span> dataBytes </a>
<a class="sourceLine" id="cb19-39" title="39">                 , dDataDebug <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb19-40" title="40">                 } </a></code></pre></div>
<h3 id="reading-strings">Reading strings</h3>
<ul>
<li>A <code>PString</code> is prefixed with an <code>Int8</code> size. So read the size and then the string</li>
<li>A <code>CString</code> is null terminated, so read all the data for the length of the string (from the directory entry) and drop the final null character.</li>
</ul>
<h6 id="srchyraxabifread.hs-194-to-204">src/Hyrax/Abif/Read.hs (194 to 204)</h6>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="co">-- | Parse a 'ElemPString'</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="ot">getPString ::</span> <span class="dt">B.Get</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb20-3" title="3">getPString <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-4" title="4">  sz <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> B.getInt8</a>
<a class="sourceLine" id="cb20-5" title="5">  TxtE.decodeUtf8 <span class="fu">&lt;$&gt;</span> B.label (<span class="st">&quot;PString length=&quot;</span> <span class="fu">&lt;&gt;</span> <span class="fu">show</span> sz <span class="fu">&lt;&gt;</span> <span class="st">&quot;.&quot;</span>) (B.getByteString sz)</a>
<a class="sourceLine" id="cb20-6" title="6"></a>
<a class="sourceLine" id="cb20-7" title="7"></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="co">-- | Parse a 'ElemCString'</span></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="ot">getCString ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">B.Get</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb20-10" title="10">getCString sz <span class="fu">=</span> </a>
<a class="sourceLine" id="cb20-11" title="11">  TxtE.decodeUtf8 <span class="fu">&lt;$&gt;</span> B.getByteString (sz <span class="fu">-</span> <span class="dv">1</span>)</a></code></pre></div>
<h3 id="debug-info">Debug info</h3>
<p>getDebug adds human readable information for some types, e.g. for strings. This lets us print the <code>Abif</code> structure to the console with some useful data. Only a portion of <code>getDebug</code> is show here as it is a little repetitive. However it is a good function to look at to see more examples of reading the raw data.</p>
<h6 id="srchyraxabifread.hs-94-to-112">src/Hyrax/Abif/Read.hs (94 to 112)</h6>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="co">-- | Populate the directory entry with debug data (into 'dDataDebug').</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="co">-- This is done for selected types only, e.g. for strings so that printing the structure will display</span></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="co">-- readable/meaningfull info</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="ot">getDebug ::</span> <span class="dt">Directory</span> <span class="ot">-&gt;</span> <span class="dt">Directory</span></a>
<a class="sourceLine" id="cb21-5" title="5">getDebug d <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-6" title="6">  <span class="kw">let</span> bsAtOffset <span class="fu">=</span> dData d <span class="kw">in</span></a>
<a class="sourceLine" id="cb21-7" title="7">  </a>
<a class="sourceLine" id="cb21-8" title="8">  <span class="kw">case</span> dElemType d <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-9" title="9">    <span class="co">-- Strings have a count = number of chars, not number of &quot;strings&quot;</span></a>
<a class="sourceLine" id="cb21-10" title="10">    <span class="dt">ElemPString</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-11" title="11">      <span class="kw">if</span> dDataSize d <span class="fu">&lt;=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb21-12" title="12">      <span class="kw">then</span> d { dDataDebug <span class="fu">=</span> [TxtE.decodeUtf8 <span class="fu">.</span> BSL.toStrict <span class="fu">.</span> BSL.drop <span class="dv">1</span> <span class="fu">.</span> BSL.take (<span class="fu">fromIntegral</span> <span class="fu">$</span> dDataSize d) <span class="fu">$</span> dData d] }</a>
<a class="sourceLine" id="cb21-13" title="13">      <span class="kw">else</span> d { dDataDebug <span class="fu">=</span> [B.runGet (lbl getPString) bsAtOffset] }</a>
<a class="sourceLine" id="cb21-14" title="14"></a>
<a class="sourceLine" id="cb21-15" title="15">    <span class="co">-- Strings have a count = number of chars, not number of &quot;strings&quot;</span></a>
<a class="sourceLine" id="cb21-16" title="16">    <span class="dt">ElemCString</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-17" title="17">      <span class="kw">if</span> dDataSize d <span class="fu">&lt;=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb21-18" title="18">      <span class="kw">then</span> d { dDataDebug <span class="fu">=</span> [TxtE.decodeUtf8 <span class="fu">.</span> BSL.toStrict <span class="fu">.</span> BSL.take (<span class="fu">fromIntegral</span> <span class="fu">$</span> dDataSize d <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">$</span> dData d] }</a>
<a class="sourceLine" id="cb21-19" title="19">      <span class="kw">else</span> d { dDataDebug <span class="fu">=</span> [B.runGet (lbl <span class="fu">.</span> getCString <span class="fu">$</span> dDataSize d) bsAtOffset] }</a></code></pre></div>
<p>When printing the structure it does not make sense to print all the raw data too. So the <code>clear*</code> functions remove that before printing</p>
<h6 id="srchyraxabifread.hs-80-to-89">src/Hyrax/Abif/Read.hs (80 to 89)</h6>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="co">-- | Removes all data from the ABIF's directories</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="ot">clearAbif ::</span> <span class="dt">Abif</span> <span class="ot">-&gt;</span> <span class="dt">Abif</span></a>
<a class="sourceLine" id="cb22-3" title="3">clearAbif a <span class="fu">=</span> a { aRootDir <span class="fu">=</span> clear <span class="fu">$</span> aRootDir a</a>
<a class="sourceLine" id="cb22-4" title="4">                , aDirs <span class="fu">=</span> clear <span class="fu">&lt;$&gt;</span> aDirs a</a>
<a class="sourceLine" id="cb22-5" title="5">                }</a>
<a class="sourceLine" id="cb22-6" title="6"></a>
<a class="sourceLine" id="cb22-7" title="7"></a>
<a class="sourceLine" id="cb22-8" title="8"><span class="co">-- | Removes all data from a directory entry. This will probably only be useful when trying to show an ABIF value</span></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="ot">clear ::</span> <span class="dt">Directory</span> <span class="ot">-&gt;</span> <span class="dt">Directory</span></a>
<a class="sourceLine" id="cb22-10" title="10">clear d <span class="fu">=</span> d { dData <span class="fu">=</span> <span class="st">&quot;&quot;</span> }</a></code></pre></div>
<h2 id="hyrax.abif.write">Hyrax.Abif.Write</h2>
<p>As with the read functions there are two write functions for writing to <code>ByteString</code> or to a file.</p>
<h6 id="srchyraxabifwrite.hs-54-to-64">src/Hyrax/Abif/Write.hs (54 to 64)</h6>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="co">-- | Write an 'Abif' to a 'ByteString'</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="ot">createAbifBytes ::</span> <span class="dt">Abif</span> <span class="ot">-&gt;</span> <span class="dt">BSL.ByteString</span></a>
<a class="sourceLine" id="cb23-3" title="3">createAbifBytes ab1 <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-4" title="4">  B.runPut (putAbif ab1)</a>
<a class="sourceLine" id="cb23-5" title="5"></a>
<a class="sourceLine" id="cb23-6" title="6">  </a>
<a class="sourceLine" id="cb23-7" title="7"><span class="co">-- | Write an 'Abif' to a file</span></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="ot">writeAbif ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Abif</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-9" title="9">writeAbif destPath ab1 <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-10" title="10">  <span class="kw">let</span> b <span class="fu">=</span> createAbifBytes ab1</a>
<a class="sourceLine" id="cb23-11" title="11">  BS.writeFile destPath <span class="fu">$</span> BSL.toStrict b</a></code></pre></div>
<p>Writing the ABIF data is relatively simple since each directory entry already contains the <code>ByteString</code> raw data. <code>putAbif</code> does need to recalculate the data size though</p>
<h6 id="srchyraxabifwrite.hs-69-to-98">src/Hyrax/Abif/Write.hs (69 to 98)</h6>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="co">-- | Create the 'Abif' using &quot;Data.Binary&quot;</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="ot">putAbif ::</span> <span class="dt">Abif</span> <span class="ot">-&gt;</span> <span class="dt">B.Put</span></a>
<a class="sourceLine" id="cb24-3" title="3">putAbif (<span class="dt">Abif</span> header root dirs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-4" title="4">  <span class="co">-- Total data size</span></a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="kw">let</span> dataSize <span class="fu">=</span> foldl' (\acc i <span class="ot">-&gt;</span> <span class="kw">if</span> i <span class="fu">&gt;</span> <span class="dv">4</span> <span class="kw">then</span> acc <span class="fu">+</span> i <span class="kw">else</span> acc) <span class="dv">0</span> <span class="fu">$</span> dDataSize <span class="fu">&lt;$&gt;</span> dirs</a>
<a class="sourceLine" id="cb24-6" title="6">  </a>
<a class="sourceLine" id="cb24-7" title="7">  <span class="co">-- Write the header</span></a>
<a class="sourceLine" id="cb24-8" title="8">  putHeader header</a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10">  <span class="co">-- Data starts at offset 128</span></a>
<a class="sourceLine" id="cb24-11" title="11">  <span class="kw">let</span> startDataOffset <span class="fu">=</span> <span class="dv">128</span></a>
<a class="sourceLine" id="cb24-12" title="12">  <span class="co">-- Write the root directory entry</span></a>
<a class="sourceLine" id="cb24-13" title="13">  putDirectory (startDataOffset <span class="fu">+</span> dataSize) <span class="fu">$</span> root { dDataSize <span class="fu">=</span> <span class="dv">28</span> <span class="fu">*</span> <span class="fu">length</span> dirs</a>
<a class="sourceLine" id="cb24-14" title="14">                                                   , dElemNum <span class="fu">=</span> <span class="fu">length</span> dirs</a>
<a class="sourceLine" id="cb24-15" title="15">                                                   }</a>
<a class="sourceLine" id="cb24-16" title="16"></a>
<a class="sourceLine" id="cb24-17" title="17">  <span class="co">-- Write 47 zero Int16 values as required by the spec</span></a>
<a class="sourceLine" id="cb24-18" title="18">  traverse_ B.putInt16be <span class="fu">$</span> <span class="fu">replicate</span> <span class="dv">47</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb24-19" title="19">  <span class="co">-- Write the data, for all data larger than four bytes. Data four bytes or less is stored</span></a>
<a class="sourceLine" id="cb24-20" title="20">  <span class="co">--  in the offset field</span></a>
<a class="sourceLine" id="cb24-21" title="21">  traverse_ (B.putLazyByteString <span class="fu">.</span> dData) <span class="fu">$</span> <span class="fu">filter</span> (\d <span class="ot">-&gt;</span> dDataSize d <span class="fu">&gt;</span> <span class="dv">4</span>) dirs</a>
<a class="sourceLine" id="cb24-22" title="22">  <span class="co">-- Write the directory entries. </span></a>
<a class="sourceLine" id="cb24-23" title="23">  foldM_ writeDir startDataOffset dirs</a>
<a class="sourceLine" id="cb24-24" title="24"></a>
<a class="sourceLine" id="cb24-25" title="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-26" title="26">    writeDir offset dir <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-27" title="27">      putDirectory offset dir</a>
<a class="sourceLine" id="cb24-28" title="28">      <span class="fu">pure</span> <span class="fu">$</span> <span class="kw">if</span> dDataSize dir <span class="fu">&gt;</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb24-29" title="29">             <span class="kw">then</span> offset <span class="fu">+</span> dDataSize dir</a>
<a class="sourceLine" id="cb24-30" title="30">             <span class="kw">else</span> offset</a></code></pre></div>
<ul>
<li>The total data size is calculated. It is the sum of all the non-root directory entries where the data is not stored in the offset field (i.e. where data size &gt; 4 bytes)</li>
<li>The data will starting being written at offset 128, i.e. immediately after the header and root directory entry</li>
<li>Add the root directory</li>
<li>Write the 47 zeros required by the spec</li>
<li>Write all the data from each of the directory entries</li>
<li>Write the directory entries, incrementing the offset for each entry with data &gt; 4 bytes</li>
</ul>
<h3 id="header">Header</h3>
<p>Writing the header is pretty simple, write the magic string and version number.</p>
<h6 id="srchyraxabifwrite.hs-117-to-121">src/Hyrax/Abif/Write.hs (117 to 121)</h6>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="co">-- | Write a 'Header'</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ot">putHeader ::</span> <span class="dt">Header</span> <span class="ot">-&gt;</span> <span class="dt">B.Put</span></a>
<a class="sourceLine" id="cb25-3" title="3">putHeader h <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-4" title="4">  putTextStr <span class="fu">$</span> hName h</a>
<a class="sourceLine" id="cb25-5" title="5">  B.putInt16be <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> hVersion h</a></code></pre></div>
<h3 id="strings">Strings</h3>
<p>There are two functions for writing <code>Text</code> values</p>
<h6 id="srchyraxabifwrite.hs-103-to-112">src/Hyrax/Abif/Write.hs (103 to 112)</h6>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="co">-- | Write 'Text'</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="ot">putTextStr ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">B.Put</span></a>
<a class="sourceLine" id="cb26-3" title="3">putTextStr t <span class="fu">=</span> B.putByteString <span class="fu">$</span> TxtE.encodeUtf8 t</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="co">-- | Write a 'ElemPString'</span></a>
<a class="sourceLine" id="cb26-7" title="7"><span class="ot">putPStr ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">B.Put</span></a>
<a class="sourceLine" id="cb26-8" title="8">putPStr t <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-9" title="9">  B.putInt8 <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> Txt.length t</a>
<a class="sourceLine" id="cb26-10" title="10">  B.putByteString <span class="fu">$</span> TxtE.encodeUtf8 t</a></code></pre></div>
<h3 id="directory">Directory</h3>
<p>When writing a directory there a few things to take care of</p>
<ul>
<li>Ensure that the directory name is exactly 4 bytes long</li>
<li>Write the offset for data &gt; 4 bytes</li>
<li>Write the data to the offset field if it is &lt;= 4 bytes, ensure it is exactly 4 bytes long on disk</li>
<li>Append the reserved zero value</li>
</ul>
<h6 id="srchyraxabifwrite.hs-126-to-142">src/Hyrax/Abif/Write.hs (126 to 142)</h6>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="co">-- | Write a 'Directory'</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="ot">putDirectory ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Directory</span> <span class="ot">-&gt;</span> <span class="dt">B.Put</span></a>
<a class="sourceLine" id="cb27-3" title="3">putDirectory dirOffset d <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-4" title="4">  <span class="kw">let</span> name <span class="fu">=</span> Txt.justifyLeft <span class="dv">4</span> <span class="ch">' '</span> <span class="fu">.</span> Txt.take <span class="dv">4</span> <span class="fu">$</span> dTagName d</a>
<a class="sourceLine" id="cb27-5" title="5">  putTextStr name</a>
<a class="sourceLine" id="cb27-6" title="6">  B.putInt32be <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> dTagNum d</a>
<a class="sourceLine" id="cb27-7" title="7">  B.putInt16be <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> dElemTypeCode d</a>
<a class="sourceLine" id="cb27-8" title="8">  B.putInt16be <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> dElemSize d</a>
<a class="sourceLine" id="cb27-9" title="9">  B.putInt32be <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> dElemNum d</a>
<a class="sourceLine" id="cb27-10" title="10">  B.putInt32be <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> dDataSize d</a>
<a class="sourceLine" id="cb27-11" title="11"></a>
<a class="sourceLine" id="cb27-12" title="12">  <span class="co">-- data with a size &gt;= 4 are written in the offset</span></a>
<a class="sourceLine" id="cb27-13" title="13">  <span class="kw">if</span> dDataSize d <span class="fu">&gt;</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb27-14" title="14">    <span class="kw">then</span> B.putInt32be <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">$</span> dirOffset</a>
<a class="sourceLine" id="cb27-15" title="15">    <span class="kw">else</span> B.putLazyByteString <span class="fu">.</span> BSL.take <span class="dv">4</span> <span class="fu">$</span> dData d <span class="fu">&lt;&gt;</span> <span class="st">&quot;\0\0\0\0&quot;</span></a>
<a class="sourceLine" id="cb27-16" title="16"></a>
<a class="sourceLine" id="cb27-17" title="17">  B.putInt32be <span class="dv">0</span> <span class="co">-- reserved / datahandle</span></a></code></pre></div>
<h3 id="mk-helper-functions">mk* helper functions</h3>
<p>The <code>mk*</code> set of functions help in constructing valid directory entries.</p>
<p>Below are two of these functions</p>
<ul>
<li><code>mkBaseOrder</code> which creates a FWO_ Directory entry.</li>
<li><code>mkLane</code> which creates a LANE Directory entry.</li>
</ul>
<p>As you can see these functions take appropriately typed values in and produce a valid directory entry for the data and directory type. (See <code>Hyrax.Abif.Generate</code> to see them in use)</p>
<h6 id="srchyraxabifwrite.hs-48-to-49">src/Hyrax/Abif/Write.hs (48 to 49)</h6>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="co">-- | Used to specify the base order for the FWO directry entry, see 'mkBaseOrder'</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="kw">data</span> <span class="dt">Base</span> <span class="fu">=</span> <span class="dt">BaseA</span> <span class="fu">|</span> <span class="dt">BaseC</span> <span class="fu">|</span> <span class="dt">BaseG</span> <span class="fu">|</span> <span class="dt">BaseT</span></a></code></pre></div>
<h6 id="srchyraxabifwrite.hs-208-to-244">src/Hyrax/Abif/Write.hs (208 to 244)</h6>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="co">-- | Create a base order (FWO_) 'Directory' entry data</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="ot">mkBaseOrder ::</span> <span class="dt">Base</span> <span class="ot">-&gt;</span> <span class="dt">Base</span> <span class="ot">-&gt;</span> <span class="dt">Base</span> <span class="ot">-&gt;</span> <span class="dt">Base</span> <span class="ot">-&gt;</span> <span class="dt">Directory</span></a>
<a class="sourceLine" id="cb29-3" title="3">mkBaseOrder w x y z <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-4" title="4">  <span class="dt">Directory</span> { dTagName <span class="fu">=</span> <span class="st">&quot;FWO_&quot;</span> <span class="co">-- Base order</span></a>
<a class="sourceLine" id="cb29-5" title="5">            , dTagNum <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb29-6" title="6">            , dElemTypeCode <span class="fu">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb29-7" title="7">            , dElemTypeDesc <span class="fu">=</span> <span class="st">&quot;char&quot;</span></a>
<a class="sourceLine" id="cb29-8" title="8">            , dElemType <span class="fu">=</span> <span class="dt">ElemChar</span></a>
<a class="sourceLine" id="cb29-9" title="9">            , dElemSize <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb29-10" title="10">            , dDataOffset <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb29-11" title="11">            , dDataDebug <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb29-12" title="12">            , dData <span class="fu">=</span> getBase w <span class="fu">&lt;&gt;</span> getBase x <span class="fu">&lt;&gt;</span> getBase y <span class="fu">&lt;&gt;</span> getBase z</a>
<a class="sourceLine" id="cb29-13" title="13">            , dDataSize <span class="fu">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb29-14" title="14">            , dElemNum <span class="fu">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb29-15" title="15">            }</a>
<a class="sourceLine" id="cb29-16" title="16">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-17" title="17">    getBase <span class="dt">BaseA</span> <span class="fu">=</span> <span class="st">&quot;A&quot;</span></a>
<a class="sourceLine" id="cb29-18" title="18">    getBase <span class="dt">BaseC</span> <span class="fu">=</span> <span class="st">&quot;C&quot;</span></a>
<a class="sourceLine" id="cb29-19" title="19">    getBase <span class="dt">BaseG</span> <span class="fu">=</span> <span class="st">&quot;G&quot;</span></a>
<a class="sourceLine" id="cb29-20" title="20">    getBase <span class="dt">BaseT</span> <span class="fu">=</span> <span class="st">&quot;T&quot;</span></a>
<a class="sourceLine" id="cb29-21" title="21"></a>
<a class="sourceLine" id="cb29-22" title="22"></a>
<a class="sourceLine" id="cb29-23" title="23"><span class="co">-- | Create a lane (LANE) 'Directory' entry and data</span></a>
<a class="sourceLine" id="cb29-24" title="24"><span class="ot">mkLane ::</span> <span class="dt">Int16</span> <span class="ot">-&gt;</span> <span class="dt">Directory</span></a>
<a class="sourceLine" id="cb29-25" title="25">mkLane lane <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-26" title="26">  <span class="dt">Directory</span> { dTagName <span class="fu">=</span> <span class="st">&quot;LANE&quot;</span> <span class="co">-- Lane or capliary number</span></a>
<a class="sourceLine" id="cb29-27" title="27">            , dTagNum <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb29-28" title="28">            , dElemTypeCode <span class="fu">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb29-29" title="29">            , dElemTypeDesc <span class="fu">=</span> <span class="st">&quot;short&quot;</span></a>
<a class="sourceLine" id="cb29-30" title="30">            , dElemType <span class="fu">=</span> <span class="dt">ElemShort</span></a>
<a class="sourceLine" id="cb29-31" title="31">            , dElemSize <span class="fu">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb29-32" title="32">            , dElemNum <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb29-33" title="33">            , dDataSize <span class="fu">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb29-34" title="34">            , dDataOffset <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb29-35" title="35">            , dData <span class="fu">=</span> B.runPut <span class="fu">$</span> B.putInt16be lane</a>
<a class="sourceLine" id="cb29-36" title="36">            , dDataDebug <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb29-37" title="37">            }</a></code></pre></div>
<p>See the code or haddock for the full set of mk* functions.</p>
<h3 id="adding-a-directory">Adding a directory</h3>
<p><code>addDirectory</code> appends a directory entry to an existing <code>Abif</code>. See the examples to see this in use.</p>
<h6 id="srchyraxabifwrite.hs-346-to-349">src/Hyrax/Abif/Write.hs (346 to 349)</h6>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="co">-- | Add a directory to an 'Abif'</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="ot">addDirectory ::</span> <span class="dt">Abif</span> <span class="ot">-&gt;</span> <span class="dt">Directory</span> <span class="ot">-&gt;</span> <span class="dt">Abif</span></a>
<a class="sourceLine" id="cb30-3" title="3">addDirectory abif dir <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-4" title="4">  abif { aDirs <span class="fu">=</span> aDirs abif <span class="fu">&lt;&gt;</span> [dir] }</a></code></pre></div>
<h2 id="hyrax.abif.generate-and-hyrax.abif.fasta">Hyrax.Abif.Generate and Hyrax.Abif.Fasta</h2>
<p>Generating ABIFs is the main purpose of this package and the code to do this is in <code>Hyrax.Abif.Generate</code>. There is less than 200 lines of code, but I’ll go through how it works in some detail.</p>
<p><code>generateAb1</code> is the main function in this module, it controls the flow of generating a single ABIF. It has the following high level concerns</p>
<ol type="1">
<li>Generate the traces per base from the weighted FASTA</li>
<li>Generate the peak locations</li>
<li>Generate the directories</li>
<li>Create the ABIF</li>
</ol>
<h6 id="srchyraxabifgenerate.hs-131-to-171">src/Hyrax/Abif/Generate.hs (131 to 171)</h6>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="co">-- | Create the 'ByteString' data for an AB1 given the data from a weighted FASTA (see 'readWeightedFasta')</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="ot">generateAb1 ::</span> (<span class="dt">Text</span>, [(<span class="dt">Double</span>, <span class="dt">Text</span>)]) <span class="ot">-&gt;</span> <span class="dt">BSL.ByteString</span></a>
<a class="sourceLine" id="cb31-3" title="3">generateAb1 (fName, sourceFasta) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb31-4" title="4">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb31-5" title="5">    tr <span class="fu">=</span> generateTraceData sourceFasta</a>
<a class="sourceLine" id="cb31-6" title="6">    valsPerBase <span class="fu">=</span> trValsPerBase tr</a>
<a class="sourceLine" id="cb31-7" title="7">    generatedFastaLen <span class="fu">=</span> (Txt.length <span class="fu">$</span> trFasta tr)</a>
<a class="sourceLine" id="cb31-8" title="8"></a>
<a class="sourceLine" id="cb31-9" title="9">    <span class="co">-- The point that is the peak of the trace, i.e. mid point of trace for a single base</span></a>
<a class="sourceLine" id="cb31-10" title="10">    midPeek <span class="fu">=</span> valsPerBase <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb31-11" title="11">    <span class="co">-- Get the peak locations for all bases</span></a>
<a class="sourceLine" id="cb31-12" title="12">    peakLocations <span class="fu">=</span> <span class="fu">take</span> generatedFastaLen [midPeek, valsPerBase <span class="fu">+</span> midPeek<span class="fu">..</span>]</a>
<a class="sourceLine" id="cb31-13" title="13"></a>
<a class="sourceLine" id="cb31-14" title="14">    <span class="co">-- Sample name (from the FASTA name)</span></a>
<a class="sourceLine" id="cb31-15" title="15">    sampleName <span class="fu">=</span> <span class="fu">fst</span> <span class="fu">.</span> Txt.breakOn <span class="st">&quot;_&quot;</span> <span class="fu">$</span> fName</a>
<a class="sourceLine" id="cb31-16" title="16"></a>
<a class="sourceLine" id="cb31-17" title="17">    <span class="co">-- Create the ABIF directories</span></a>
<a class="sourceLine" id="cb31-18" title="18">    dirs <span class="fu">=</span> [ mkData  <span class="dv">9</span> <span class="fu">$</span> trData09G tr <span class="co">-- G</span></a>
<a class="sourceLine" id="cb31-19" title="19">           , mkData <span class="dv">10</span> <span class="fu">$</span> trData10A tr <span class="co">-- A</span></a>
<a class="sourceLine" id="cb31-20" title="20">           , mkData <span class="dv">11</span> <span class="fu">$</span> trData11T tr <span class="co">-- T</span></a>
<a class="sourceLine" id="cb31-21" title="21">           , mkData <span class="dv">12</span> <span class="fu">$</span> trData12C tr <span class="co">-- C</span></a>
<a class="sourceLine" id="cb31-22" title="22">           , mkBaseOrder <span class="dt">BaseG</span> <span class="dt">BaseA</span> <span class="dt">BaseT</span> <span class="dt">BaseC</span> <span class="co">-- Base order, should be GATC for 3500</span></a>
<a class="sourceLine" id="cb31-23" title="23">           , mkLane <span class="dv">1</span> <span class="co">-- Lane or capliary number</span></a>
<a class="sourceLine" id="cb31-24" title="24">           , mkCalledBases <span class="fu">$</span> trFasta tr <span class="co">-- Called bases</span></a>
<a class="sourceLine" id="cb31-25" title="25">           , mkMobilityFileName <span class="dv">1</span> <span class="st">&quot;KB_3500_POP7_BDTv3.mob&quot;</span> <span class="co">-- Mobility file name</span></a>
<a class="sourceLine" id="cb31-26" title="26">           , mkMobilityFileName <span class="dv">2</span> <span class="st">&quot;KB_3500_POP7_BDTv3.mob&quot;</span> <span class="co">-- Mobility file name</span></a>
<a class="sourceLine" id="cb31-27" title="27">           , mkPeakLocations <span class="fu">$</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> peakLocations <span class="co">-- Peak locations</span></a>
<a class="sourceLine" id="cb31-28" title="28">           , mkDyeSignalStrength <span class="dv">53</span> <span class="dv">75</span> <span class="dv">79</span> <span class="dv">48</span> <span class="co">-- Signal strength per dye</span></a>
<a class="sourceLine" id="cb31-29" title="29">           , mkSampleName sampleName  <span class="co">-- Sample name</span></a>
<a class="sourceLine" id="cb31-30" title="30">           , mkComment <span class="st">&quot;Generated by HyraxBio AB1 generator&quot;</span></a>
<a class="sourceLine" id="cb31-31" title="31">           ]</a>
<a class="sourceLine" id="cb31-32" title="32"></a>
<a class="sourceLine" id="cb31-33" title="33">    <span class="co">-- The ABIF</span></a>
<a class="sourceLine" id="cb31-34" title="34">    abif <span class="fu">=</span> <span class="dt">Abif</span> { aHeader <span class="fu">=</span> mkHeader</a>
<a class="sourceLine" id="cb31-35" title="35">                , aRootDir <span class="fu">=</span> mkRoot</a>
<a class="sourceLine" id="cb31-36" title="36">                , aDirs <span class="fu">=</span> dirs</a>
<a class="sourceLine" id="cb31-37" title="37">                }</a>
<a class="sourceLine" id="cb31-38" title="38">            </a>
<a class="sourceLine" id="cb31-39" title="39">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb31-40" title="40">  <span class="co">-- Generate the data</span></a>
<a class="sourceLine" id="cb31-41" title="41">  B.runPut (putAbif abif)</a></code></pre></div>
<h3 id="a-quick-detour---reading-the-weighted-fasta">A quick detour - Reading the weighted FASTA</h3>
<p><code>readWeightedFasta</code> reads the contents of a single weighted <code>.fasta</code> file. (<em>Unless you are interested in how the FASTA parsing works, you can skip this and go to the next section. Just have a look at what the types represent</em>).</p>
<p>The parsed content has the type <code>[('Double', 'Text')]</code>, which stores the data like this</p>
<pre class="text"><code>[('Double', 'Text')]   
   ^         ^         
   |         |         
   |         +---- read
   |                   
   +---- weight        </code></pre>
<p>i.e. an array of weights together with the sequence at that weight.</p>
<h6 id="srchyraxabifgenerate.hs-265-to-290">src/Hyrax/Abif/Generate.hs (265 to 290)</h6>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="ot">readWeightedFasta ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> [(<span class="dt">Double</span>, <span class="dt">Text</span>)]</a>
<a class="sourceLine" id="cb33-2" title="2">readWeightedFasta fastaData <span class="fu">=</span> </a>
<a class="sourceLine" id="cb33-3" title="3">  <span class="kw">case</span> parseFasta <span class="fu">$</span> TxtE.decodeUtf8 fastaData <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-4" title="4">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="dt">Left</span> e</a>
<a class="sourceLine" id="cb33-5" title="5">    <span class="dt">Right</span> fs <span class="ot">-&gt;</span> getWeightedFasta fs</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-8" title="8"><span class="ot">    getWeightedFasta ::</span> [<span class="dt">Fasta</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> [(<span class="dt">Double</span>, <span class="dt">Text</span>)]</a>
<a class="sourceLine" id="cb33-9" title="9">    getWeightedFasta fs <span class="fu">=</span> </a>
<a class="sourceLine" id="cb33-10" title="10">      <span class="kw">case</span> <span class="fu">sequenceA</span> <span class="fu">$</span> readWeighted <span class="fu">&lt;$&gt;</span> fs <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-11" title="11">        <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="dt">Left</span> e</a>
<a class="sourceLine" id="cb33-12" title="12">        <span class="dt">Right</span> r <span class="ot">-&gt;</span> <span class="dt">Right</span> r</a>
<a class="sourceLine" id="cb33-13" title="13"></a>
<a class="sourceLine" id="cb33-14" title="14"><span class="ot">    readWeighted ::</span> <span class="dt">Fasta</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> (<span class="dt">Double</span>, <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb33-15" title="15">    readWeighted (<span class="dt">Fasta</span> hdr' dta) <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-16" title="16">      <span class="kw">let</span> (processNucs, hdr) <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-17" title="17">            <span class="co">-- If there is a 'R' suffix, then generate a reverse sequence</span></a>
<a class="sourceLine" id="cb33-18" title="18">            <span class="co">--  Which means complement each nucleotide and then reverse the string</span></a>
<a class="sourceLine" id="cb33-19" title="19">            <span class="kw">if</span> Txt.isSuffixOf <span class="st">&quot;R&quot;</span> hdr'</a>
<a class="sourceLine" id="cb33-20" title="20">            <span class="kw">then</span> (Txt.reverse <span class="fu">.</span> complementNucleotides, Txt.strip <span class="fu">.</span> Txt.dropEnd <span class="dv">1</span> <span class="fu">$</span> hdr')</a>
<a class="sourceLine" id="cb33-21" title="21">            <span class="kw">else</span> (identity, hdr')</a>
<a class="sourceLine" id="cb33-22" title="22">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb33-23" title="23">      </a>
<a class="sourceLine" id="cb33-24" title="24">      <span class="kw">case</span> (readMaybe <span class="fu">.</span> Txt.unpack <span class="fu">$</span><span class="ot"> hdr ::</span> <span class="dt">Maybe</span> <span class="dt">Double</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-25" title="25">        <span class="dt">Just</span> weight <span class="ot">-&gt;</span> <span class="dt">Right</span> (<span class="fu">min</span> <span class="dv">1</span> <span class="fu">.</span> <span class="fu">max</span> <span class="dv">0</span> <span class="fu">$</span> weight, processNucs <span class="fu">$</span> Txt.strip dta)</a>
<a class="sourceLine" id="cb33-26" title="26">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="st">&quot;Invalid header reading, expecting numeric weight, got: &quot;</span> <span class="fu">&lt;&gt;</span> hdr</a></code></pre></div>
<p>The FASTA is read and parsed in <code>Hyrax.Abif.Fasta</code>. Note that <code>readWeighted</code> handles the reverse read logic by calling <code>complementNucleotides</code> and then reversing the string. This section of the code is not entirely relevant for this discussion of the ABIF generation so I wont spend much time on it.</p>
<h6 id="srchyraxabifgenerate.hs-391-to-406">src/Hyrax/Abif/Generate.hs (391 to 406)</h6>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="co">-- | Return the complement of a nucelotide string</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="ot">complementNucleotides ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb34-3" title="3">complementNucleotides ns <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-4" title="4">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb34-5" title="5">    un <span class="fu">=</span> unIupac <span class="fu">&lt;$&gt;</span> Txt.unpack ns</a>
<a class="sourceLine" id="cb34-6" title="6">    comp <span class="fu">=</span> complementNuc <span class="fu">&lt;&lt;$&gt;&gt;</span> un</a>
<a class="sourceLine" id="cb34-7" title="7">    iu <span class="fu">=</span> iupac comp</a>
<a class="sourceLine" id="cb34-8" title="8">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb34-9" title="9">  Txt.pack iu</a>
<a class="sourceLine" id="cb34-10" title="10"></a>
<a class="sourceLine" id="cb34-11" title="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-12" title="12">    complementNuc <span class="ch">'A'</span> <span class="fu">=</span> <span class="ch">'T'</span></a>
<a class="sourceLine" id="cb34-13" title="13">    complementNuc <span class="ch">'G'</span> <span class="fu">=</span> <span class="ch">'C'</span></a>
<a class="sourceLine" id="cb34-14" title="14">    complementNuc <span class="ch">'T'</span> <span class="fu">=</span> <span class="ch">'A'</span></a>
<a class="sourceLine" id="cb34-15" title="15">    complementNuc <span class="ch">'C'</span> <span class="fu">=</span> <span class="ch">'G'</span></a>
<a class="sourceLine" id="cb34-16" title="16">    complementNuc x <span class="fu">=</span> x</a></code></pre></div>
<h6 id="srchyraxabiffasta.hs-23-to-51">src/Hyrax/Abif/Fasta.hs (23 to 51)</h6>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="co">-- | FASTA data</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="kw">data</span> <span class="dt">Fasta</span> <span class="fu">=</span> <span class="dt">Fasta</span> {<span class="ot"> fastaName ::</span> <span class="fu">!</span><span class="dt">Text</span> <span class="co">-- ^ Name</span></a>
<a class="sourceLine" id="cb35-3" title="3">                   ,<span class="ot"> fastaRead ::</span> <span class="fu">!</span><span class="dt">Text</span> <span class="co">-- ^ Data</span></a>
<a class="sourceLine" id="cb35-4" title="4">                   } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb35-5" title="5"></a>
<a class="sourceLine" id="cb35-6" title="6"></a>
<a class="sourceLine" id="cb35-7" title="7"><span class="co">-- | Parse the data for a single FASTA into a list of 'Fasta' values.</span></a>
<a class="sourceLine" id="cb35-8" title="8"><span class="co">-- Single and multi-line FASTAs are supported.</span></a>
<a class="sourceLine" id="cb35-9" title="9"><span class="co">-- Used by &quot;Hyrax.Abif.Generate&quot; to read weighted-FASTAs</span></a>
<a class="sourceLine" id="cb35-10" title="10"><span class="ot">parseFasta ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> [<span class="dt">Fasta</span>]</a>
<a class="sourceLine" id="cb35-11" title="11">parseFasta s <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-12" title="12">  <span class="fu">reverse</span> <span class="fu">&lt;$&gt;</span> go (Txt.lines s) <span class="dt">Nothing</span> <span class="st">&quot;&quot;</span> []</a>
<a class="sourceLine" id="cb35-13" title="13"></a>
<a class="sourceLine" id="cb35-14" title="14">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-15" title="15"><span class="ot">    go ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Fasta</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> [<span class="dt">Fasta</span>]</a>
<a class="sourceLine" id="cb35-16" title="16">    go (line<span class="fu">:lines</span>) (<span class="dt">Just</span> name) <span class="fu">read</span> acc <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-17" title="17">      <span class="kw">if</span> Txt.take <span class="dv">1</span> line <span class="fu">/=</span> <span class="st">&quot;&gt;&quot;</span></a>
<a class="sourceLine" id="cb35-18" title="18">      <span class="kw">then</span> go <span class="fu">lines</span> (<span class="dt">Just</span> name) (<span class="fu">read</span> <span class="fu">&lt;&gt;</span> line) acc</a>
<a class="sourceLine" id="cb35-19" title="19">      <span class="kw">else</span> go <span class="fu">lines</span> (<span class="dt">Just</span> <span class="fu">$</span> Txt.drop <span class="dv">1</span> line) <span class="st">&quot;&quot;</span> (<span class="dt">Fasta</span> (Txt.strip name) <span class="fu">read</span> <span class="fu">:</span> acc)</a>
<a class="sourceLine" id="cb35-20" title="20">    go (line<span class="fu">:lines</span>) <span class="dt">Nothing</span> _read acc <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-21" title="21">      <span class="kw">if</span> Txt.take <span class="dv">1</span> line <span class="fu">==</span> <span class="st">&quot;&gt;&quot;</span></a>
<a class="sourceLine" id="cb35-22" title="22">      <span class="kw">then</span> go <span class="fu">lines</span> (<span class="dt">Just</span> <span class="fu">$</span> Txt.strip <span class="fu">.</span> Txt.drop <span class="dv">1</span> <span class="fu">$</span> line) <span class="st">&quot;&quot;</span> acc</a>
<a class="sourceLine" id="cb35-23" title="23">      <span class="kw">else</span> <span class="dt">Left</span> <span class="st">&quot;Expecting name&quot;</span></a>
<a class="sourceLine" id="cb35-24" title="24">    go [] <span class="dt">Nothing</span> _ acc <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-25" title="25">      <span class="dt">Right</span> acc</a>
<a class="sourceLine" id="cb35-26" title="26">    go [] (<span class="dt">Just</span> _name) <span class="st">&quot;&quot;</span> _acc <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-27" title="27">      <span class="dt">Left</span> <span class="st">&quot;Expecting read&quot;</span></a>
<a class="sourceLine" id="cb35-28" title="28">    go [] (<span class="dt">Just</span> name) <span class="fu">read</span> acc <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-29" title="29">      <span class="dt">Right</span> <span class="fu">$</span> <span class="dt">Fasta</span> (Txt.strip name) <span class="fu">read</span> <span class="fu">:</span> acc</a></code></pre></div>
<p><code>readWeightedFastas</code> reads all the FASTA files from a directory and returns a tuple of <code>( file-name, f )</code> where <code>f</code> is <code>[('Double', 'Text')]</code> as described above.</p>
<h6 id="srchyraxabifgenerate.hs-296-to-317">src/Hyrax/Abif/Generate.hs (296 to 317)</h6>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="co">-- | Read all FASTA files in a directory</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">--</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">-- The result data has the type</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">-- </span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">-- @</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co">--                    [ ('Text', [('Double', 'Text')]) ]</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="co">--                        ^         ^         ^</span></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="co">--                        |         |         |</span></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="co">-- file name -------------+         |         +---- read </span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="co">--                                  | </span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">--                                  +---- weight</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="co">-- @</span></a>
<a class="sourceLine" id="cb36-13" title="13"><span class="co">--</span></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="ot">readWeightedFastas ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Text</span> [(<span class="dt">Text</span>, [(<span class="dt">Double</span>, <span class="dt">Text</span>)])])</a>
<a class="sourceLine" id="cb36-15" title="15">readWeightedFastas source <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb36-16" title="16">  files <span class="ot">&lt;-</span> <span class="fu">filter</span> (Txt.isSuffixOf <span class="st">&quot;.fasta&quot;</span> <span class="fu">.</span> Txt.pack) <span class="fu">&lt;$&gt;</span> getFiles source</a>
<a class="sourceLine" id="cb36-17" title="17">  <span class="kw">let</span> names <span class="fu">=</span> Txt.pack <span class="fu">.</span> FP.takeBaseName <span class="fu">&lt;$&gt;</span> files</a>
<a class="sourceLine" id="cb36-18" title="18">  contents <span class="ot">&lt;-</span> <span class="fu">traverse</span> BS.readFile files</a>
<a class="sourceLine" id="cb36-19" title="19">  </a>
<a class="sourceLine" id="cb36-20" title="20">  <span class="kw">case</span> <span class="fu">sequenceA</span> <span class="fu">$</span> readWeightedFasta <span class="fu">&lt;$&gt;</span> contents <span class="kw">of</span></a>
<a class="sourceLine" id="cb36-21" title="21">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">$</span> e</a>
<a class="sourceLine" id="cb36-22" title="22">    <span class="dt">Right</span> rs <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> <span class="fu">zip</span> names rs</a></code></pre></div>
<h3 id="generating-the-trace-data">Generating the trace data</h3>
<p><code>generateTraceData</code> does the bulk of the work in the ABIF data generation</p>
<h6 id="srchyraxabifgenerate.hs-181-to-183">src/Hyrax/Abif/Generate.hs (181 to 183)</h6>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="co">-- | Generate the traces for the AB1 from the parsed weighted FASTA</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="ot">generateTraceData ::</span> [(<span class="dt">Double</span>, <span class="dt">Text</span>)] <span class="ot">-&gt;</span> <span class="dt">TraceData</span></a>
<a class="sourceLine" id="cb37-3" title="3">generateTraceData weighted <span class="fu">=</span></a></code></pre></div>
<h6 id="srchyraxabifgenerate.hs-187-to-188">src/Hyrax/Abif/Generate.hs (187 to 188)</h6>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1">  weightedNucs' <span class="fu">=</span> (\(w, ns) <span class="ot">-&gt;</span> (w,) <span class="fu">.</span> unIupac <span class="fu">&lt;$&gt;</span> Txt.unpack ns) <span class="fu">&lt;$&gt;</span> weighted</a>
<a class="sourceLine" id="cb38-2" title="2">  weightedNucs <span class="fu">=</span> Lst.transpose weightedNucs'</a></code></pre></div>
<p>Lets break <code>(\(w, ns) -&gt; (w,) . unIupac &lt;$&gt; Txt.unpack ns) &lt;$&gt; weighted</code> down a bit</p>
<ul>
<li>Its running a lambda for each weighted element
<ul>
<li>So <code>lambda &lt;$&gt; weighted</code></li>
<li>Weighted has the type <code>[(Double, Text)]</code> as discussed above</li>
<li>The lambda takes the params <code>\(w, ns)</code>. I.e. it destuctures a tuple from the array and gets the weight and the string of nucleotides.</li>
<li>For each nucleotide <code>f &lt;$&gt; Txt.unpack ns</code>
<ul>
<li><code>f</code> is <code>(w,) . unIupac</code></li>
<li>So each nucleotide gets passed to <code>unIupac</code> (as a <code>Text</code>) and added to a tuple with the weigh, so (weight, [nucleotide])
<ul>
<li><code>unIupac</code> takes a possibly ambiguous nucleotide code and returns the list of nucleotides it represents. E.g. <code>V</code> -&gt; <code>ACG</code></li>
</ul></li>
</ul></li>
</ul></li>
<li>And then <code>List.transpose</code> is called. This gives us all the nulceotides and weights per position</li>
</ul>
<p>This code is perhaps a bit hard to follow, so here is an example showing how this would work for the weighted FASTA</p>
<pre class="test"><code>&gt;1
AC
&gt;0.5
WK</code></pre>
<ol type="1">
<li>The weighted fasta is parsed as</li>
</ol>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1">[ (<span class="fl">1.0</span>,<span class="st">&quot;AC&quot;</span>) <span class="co">-- Read 0</span></a>
<a class="sourceLine" id="cb40-2" title="2">, (<span class="fl">0.5</span>,<span class="st">&quot;WK&quot;</span>) <span class="co">-- Read 1</span></a>
<a class="sourceLine" id="cb40-3" title="3">]</a></code></pre></div>
<ol start="2" type="1">
<li>Each of the nucleotides is passed to <code>unIupac</code>, and since <code>W</code> = <code>AT</code> and <code>K</code> = <code>GT</code> we get</li>
</ol>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1">[   [ (<span class="fl">1.0</span>, <span class="st">&quot;A&quot;</span>)  <span class="co">-- Read 0</span></a>
<a class="sourceLine" id="cb41-2" title="2">    , (<span class="fl">1.0</span>, <span class="st">&quot;C&quot;</span>)</a>
<a class="sourceLine" id="cb41-3" title="3">    ]</a>
<a class="sourceLine" id="cb41-4" title="4"></a>
<a class="sourceLine" id="cb41-5" title="5">,   [ (<span class="fl">0.5</span>, <span class="st">&quot;AT&quot;</span>)  <span class="co">-- Read 1</span></a>
<a class="sourceLine" id="cb41-6" title="6">    , (<span class="fl">0.5</span>, <span class="st">&quot;GT&quot;</span>)</a>
<a class="sourceLine" id="cb41-7" title="7">    ]</a>
<a class="sourceLine" id="cb41-8" title="8">]</a></code></pre></div>
<ol start="3" type="1">
<li>Finally, the list is transposed to get the weight and nucleotide per position</li>
</ol>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1">[  [ (<span class="fl">1.0</span>, <span class="st">&quot;A&quot;</span>)   <span class="co">-- Position 0</span></a>
<a class="sourceLine" id="cb42-2" title="2">   , (<span class="fl">0.5</span>, <span class="st">&quot;AT&quot;</span>)</a>
<a class="sourceLine" id="cb42-3" title="3">   ]</a>
<a class="sourceLine" id="cb42-4" title="4">,</a>
<a class="sourceLine" id="cb42-5" title="5">   [ (<span class="fl">1.0</span>, <span class="st">&quot;C&quot;</span>)   <span class="co">-- Position 1</span></a>
<a class="sourceLine" id="cb42-6" title="6">   , (<span class="fl">0.5</span>, <span class="st">&quot;GT&quot;</span>)</a>
<a class="sourceLine" id="cb42-7" title="7">   ]</a>
<a class="sourceLine" id="cb42-8" title="8">]</a></code></pre></div>
<ul>
<li>position <code>0</code> has an <code>A</code> with weight 1 and an <code>A</code>/<code>T</code> with weight 0.5</li>
<li>position <code>1</code> has a <code>C</code> with weight 1 and a <code>G</code>/<code>T</code> with weight 0.5</li>
</ul>
<h6 id="srchyraxabifgenerate.hs-192-to-195">src/Hyrax/Abif/Generate.hs (192 to 195)</h6>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1">  <span class="co">-- Values for a base that was present. This defines the shape of the chromatogram curve,</span></a>
<a class="sourceLine" id="cb43-2" title="2">  <span class="co">--  and defines the number of values per base</span></a>
<a class="sourceLine" id="cb43-3" title="3">  curve <span class="fu">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">128</span>, <span class="dv">512</span>, <span class="dv">1024</span>, <span class="dv">1024</span>, <span class="dv">512</span>, <span class="dv">128</span>, <span class="dv">0</span>, <span class="dv">0</span>]</a>
<a class="sourceLine" id="cb43-4" title="4">  valsPerBase <span class="fu">=</span> <span class="fu">length</span> curve</a></code></pre></div>
<p>Next the shape of the curve is defined. A curve this shape, was selected as it has some space either side to avoid mixing with neighboring waves and a steep climb so that the peak is easily detectable.</p>
<p><img src="../images/abif_wave.png" /></p>
<h6 id="srchyraxabifgenerate.hs-199-to-203">src/Hyrax/Abif/Generate.hs (199 to 203)</h6>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1">  <span class="co">-- Create the G, A, T and C traces</span></a>
<a class="sourceLine" id="cb44-2" title="2">  data09G <span class="fu">=</span> <span class="fu">concat</span> <span class="fu">$</span> getWeightedTrace curve <span class="ch">'G'</span> <span class="fu">&lt;$&gt;</span> weightedNucs</a>
<a class="sourceLine" id="cb44-3" title="3">  data10A <span class="fu">=</span> <span class="fu">concat</span> <span class="fu">$</span> getWeightedTrace curve <span class="ch">'A'</span> <span class="fu">&lt;$&gt;</span> weightedNucs</a>
<a class="sourceLine" id="cb44-4" title="4">  data11T <span class="fu">=</span> <span class="fu">concat</span> <span class="fu">$</span> getWeightedTrace curve <span class="ch">'T'</span> <span class="fu">&lt;$&gt;</span> weightedNucs</a>
<a class="sourceLine" id="cb44-5" title="5">  data12C <span class="fu">=</span> <span class="fu">concat</span> <span class="fu">$</span> getWeightedTrace curve <span class="ch">'C'</span> <span class="fu">&lt;$&gt;</span> weightedNucs</a></code></pre></div>
<h6 id="srchyraxabifgenerate.hs-224-to-232">src/Hyrax/Abif/Generate.hs (224 to 232)</h6>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="ot">  getWeightedTrace ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [(<span class="dt">Double</span>, [<span class="dt">Char</span>])] <span class="ot">-&gt;</span> [<span class="dt">Int16</span>]</a>
<a class="sourceLine" id="cb45-2" title="2">  getWeightedTrace curve nuc ws <span class="fu">=</span></a>
<a class="sourceLine" id="cb45-3" title="3">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb45-4" title="4">      found <span class="fu">=</span> <span class="fu">filter</span> ((nuc <span class="ot">`elem`</span>) <span class="fu">.</span> <span class="fu">snd</span>) ws</a>
<a class="sourceLine" id="cb45-5" title="5">      score' <span class="fu">=</span> foldl' (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">$</span> <span class="fu">fst</span> <span class="fu">&lt;$&gt;</span> found</a>
<a class="sourceLine" id="cb45-6" title="6">      score <span class="fu">=</span> <span class="fu">min</span> <span class="dv">1</span> <span class="fu">.</span> <span class="fu">max</span> <span class="dv">0</span> <span class="fu">$</span> score'</a>
<a class="sourceLine" id="cb45-7" title="7">      wave <span class="fu">=</span> <span class="fu">floor</span> <span class="fu">.</span> (score <span class="fu">*</span>) <span class="fu">.</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> curve</a>
<a class="sourceLine" id="cb45-8" title="8">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb45-9" title="9">    wave</a></code></pre></div>
<p><code>getWeightedTrace</code> is then called for each of the four bases. For each position for a base it returns a curve. If the position does not have the base then the curve is flat (zeros), if it does the curve above is returned multiplied by the weight.</p>
<p>Again an example may make this easier to understand</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1">  <span class="kw">let</span> ns <span class="fu">=</span> [  [ (<span class="fl">1.0</span>, <span class="st">&quot;A&quot;</span>)   <span class="co">-- Position 0</span></a>
<a class="sourceLine" id="cb46-2" title="2">              , (<span class="fl">0.5</span>, <span class="st">&quot;AT&quot;</span>)</a>
<a class="sourceLine" id="cb46-3" title="3">              ]</a>
<a class="sourceLine" id="cb46-4" title="4">           ,</a>
<a class="sourceLine" id="cb46-5" title="5">              [ (<span class="fl">1.0</span>, <span class="st">&quot;C&quot;</span>)   <span class="co">-- Position 1</span></a>
<a class="sourceLine" id="cb46-6" title="6">              , (<span class="fl">0.5</span>, <span class="st">&quot;GT&quot;</span>)</a>
<a class="sourceLine" id="cb46-7" title="7">              ]</a>
<a class="sourceLine" id="cb46-8" title="8">          ]</a>
<a class="sourceLine" id="cb46-9" title="9"></a>
<a class="sourceLine" id="cb46-10" title="10">  <span class="kw">let</span> curve <span class="fu">=</span> [<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">0</span>]</a>
<a class="sourceLine" id="cb46-11" title="11"></a>
<a class="sourceLine" id="cb46-12" title="12">  <span class="kw">let</span> rA <span class="fu">=</span> getWeightedTrace curve <span class="ch">'A'</span> <span class="fu">&lt;$&gt;</span> ns</a>
<a class="sourceLine" id="cb46-13" title="13">  <span class="fu">print</span> rA</a>
<a class="sourceLine" id="cb46-14" title="14"></a>
<a class="sourceLine" id="cb46-15" title="15">  <span class="kw">let</span> rG <span class="fu">=</span> getWeightedTrace curve <span class="ch">'G'</span> <span class="fu">&lt;$&gt;</span> ns</a>
<a class="sourceLine" id="cb46-16" title="16">  <span class="fu">print</span> rG</a></code></pre></div>
<ul>
<li>We start with the same parsed FASTA as above</li>
<li>We define a small curve as [0, 100, 0]</li>
<li>We call <code>getWeightedTrace</code> for the <code>A</code> and <code>G</code> bases</li>
</ul>
<p>For <code>A</code></p>
<ul>
<li>there is a <code>A</code> at position <code>0</code> with a total weight of <code>1</code> (remember max is 1.0) so the full curve is used</li>
<li>no <code>A</code> at position <code>1</code></li>
</ul>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1">[  [<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">0</span>]  <span class="co">-- Position 0</span></a>
<a class="sourceLine" id="cb47-2" title="2">,  [<span class="dv">0</span>,   <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co">-- Position 1</span></a>
<a class="sourceLine" id="cb47-3" title="3">]</a></code></pre></div>
<p>For <code>G</code></p>
<ul>
<li>no <code>G</code> at position <code>0</code></li>
<li>there is a <code>G</code> at position <code>1</code> with a weight of <code>0.5</code> so each value in the wave is multiplied by 0.5</li>
</ul>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1">[  [<span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co">-- Position 0</span></a>
<a class="sourceLine" id="cb48-2" title="2">,  [<span class="dv">0</span>, <span class="dv">50</span>, <span class="dv">0</span>]  <span class="co">-- Position 1</span></a>
<a class="sourceLine" id="cb48-3" title="3">]</a></code></pre></div>
<p>Notice that in the code above, these results are then concatenated so the actual results are</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1">[<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>]  <span class="co">-- A</span></a>
<a class="sourceLine" id="cb49-2" title="2">[<span class="dv">0</span>,   <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">50</span>, <span class="dv">0</span>]  <span class="co">-- G</span></a></code></pre></div>
<p>With that have a way to generate a wave form for the input weighted fasta</p>
<h6 id="srchyraxabifgenerate.hs-207-to-209">src/Hyrax/Abif/Generate.hs (207 to 209)</h6>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1">  <span class="co">-- Create fasta sequence for the trace</span></a>
<a class="sourceLine" id="cb50-2" title="2">  fastaSeq <span class="fu">=</span> <span class="fu">concat</span> <span class="fu">&lt;$&gt;</span> (<span class="fu">snd</span> <span class="fu">&lt;&lt;$&gt;&gt;</span> weightedNucs)</a>
<a class="sourceLine" id="cb50-3" title="3">  fasta <span class="fu">=</span> Txt.pack <span class="fu">$</span> iupac fastaSeq</a></code></pre></div>
<p>The ABIF needs to store the called bases in the PBAS entry. We get the bases from the input data, IUPAC encode each position and we have the sequence.</p>
<h6 id="srchyraxabifgenerate.hs-213-to-219">src/Hyrax/Abif/Generate.hs (213 to 219)</h6>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1">  <span class="dt">TraceData</span> { trData09G <span class="fu">=</span> data09G</a>
<a class="sourceLine" id="cb51-2" title="2">            , trData10A <span class="fu">=</span> data10A</a>
<a class="sourceLine" id="cb51-3" title="3">            , trData11T <span class="fu">=</span> data11T</a>
<a class="sourceLine" id="cb51-4" title="4">            , trData12C <span class="fu">=</span> data12C</a>
<a class="sourceLine" id="cb51-5" title="5">            , trFasta <span class="fu">=</span> fasta</a>
<a class="sourceLine" id="cb51-6" title="6">            , trValsPerBase <span class="fu">=</span> valsPerBase</a>
<a class="sourceLine" id="cb51-7" title="7">            }</a></code></pre></div>
<p>And return the <code>TraceData</code> value</p>
<p>For completeness here is the <code>unIupac</code> function</p>
<h6 id="srchyraxabifgenerate.hs-329-to-352">src/Hyrax/Abif/Generate.hs (329 to 352)</h6>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" title="1"><span class="co">-- | Convert a IUPAC ambiguity code to the set of nucleotides it represents</span></a>
<a class="sourceLine" id="cb52-2" title="2"><span class="ot">unIupac ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb52-3" title="3">unIupac c <span class="fu">=</span></a>
<a class="sourceLine" id="cb52-4" title="4">  <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb52-5" title="5">    <span class="ch">'T'</span> <span class="ot">-&gt;</span> <span class="st">&quot;T&quot;</span></a>
<a class="sourceLine" id="cb52-6" title="6">    <span class="ch">'C'</span> <span class="ot">-&gt;</span> <span class="st">&quot;C&quot;</span></a>
<a class="sourceLine" id="cb52-7" title="7">    <span class="ch">'A'</span> <span class="ot">-&gt;</span> <span class="st">&quot;A&quot;</span></a>
<a class="sourceLine" id="cb52-8" title="8">    <span class="ch">'G'</span> <span class="ot">-&gt;</span> <span class="st">&quot;G&quot;</span></a>
<a class="sourceLine" id="cb52-9" title="9">   </a>
<a class="sourceLine" id="cb52-10" title="10">    <span class="ch">'U'</span> <span class="ot">-&gt;</span> <span class="st">&quot;T&quot;</span></a>
<a class="sourceLine" id="cb52-11" title="11">    <span class="ch">'M'</span> <span class="ot">-&gt;</span> <span class="st">&quot;AC&quot;</span></a>
<a class="sourceLine" id="cb52-12" title="12">    <span class="ch">'R'</span> <span class="ot">-&gt;</span> <span class="st">&quot;AG&quot;</span></a>
<a class="sourceLine" id="cb52-13" title="13">    <span class="ch">'W'</span> <span class="ot">-&gt;</span> <span class="st">&quot;AT&quot;</span></a>
<a class="sourceLine" id="cb52-14" title="14">    <span class="ch">'S'</span> <span class="ot">-&gt;</span> <span class="st">&quot;CG&quot;</span></a>
<a class="sourceLine" id="cb52-15" title="15">    <span class="ch">'Y'</span> <span class="ot">-&gt;</span> <span class="st">&quot;CT&quot;</span></a>
<a class="sourceLine" id="cb52-16" title="16">    <span class="ch">'K'</span> <span class="ot">-&gt;</span> <span class="st">&quot;GT&quot;</span></a>
<a class="sourceLine" id="cb52-17" title="17">    <span class="ch">'V'</span> <span class="ot">-&gt;</span> <span class="st">&quot;ACG&quot;</span></a>
<a class="sourceLine" id="cb52-18" title="18">    <span class="ch">'H'</span> <span class="ot">-&gt;</span> <span class="st">&quot;ACT&quot;</span></a>
<a class="sourceLine" id="cb52-19" title="19">    <span class="ch">'D'</span> <span class="ot">-&gt;</span> <span class="st">&quot;AGT&quot;</span></a>
<a class="sourceLine" id="cb52-20" title="20">    <span class="ch">'B'</span> <span class="ot">-&gt;</span> <span class="st">&quot;CGT&quot;</span></a>
<a class="sourceLine" id="cb52-21" title="21">    <span class="ch">'N'</span> <span class="ot">-&gt;</span> <span class="st">&quot;GATC&quot;</span></a>
<a class="sourceLine" id="cb52-22" title="22">  </a>
<a class="sourceLine" id="cb52-23" title="23">    <span class="ch">'X'</span> <span class="ot">-&gt;</span> <span class="st">&quot;GATC&quot;</span></a>
<a class="sourceLine" id="cb52-24" title="24">    _   <span class="ot">-&gt;</span> <span class="st">&quot;&quot;</span></a></code></pre></div>
<h3 id="generating-the-peak-locations">Generating the peak locations</h3>
<h6 id="srchyraxabifgenerate.hs-140-to-143">src/Hyrax/Abif/Generate.hs (140 to 143)</h6>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1">  <span class="co">-- The point that is the peak of the trace, i.e. mid point of trace for a single base</span></a>
<a class="sourceLine" id="cb53-2" title="2">  midPeek <span class="fu">=</span> valsPerBase <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb53-3" title="3">  <span class="co">-- Get the peak locations for all bases</span></a>
<a class="sourceLine" id="cb53-4" title="4">  peakLocations <span class="fu">=</span> <span class="fu">take</span> generatedFastaLen [midPeek, valsPerBase <span class="fu">+</span> midPeek<span class="fu">..</span>]</a></code></pre></div>
<p>To generate the array of peak locations</p>
<ul>
<li>Take the midpoint of a single wave (which will always be the peak for the shape of the waves we have define)</li>
<li>Create an array of positions that start from this point, per wave for the total length of the input data</li>
</ul>
<p>Given a curve of <code>[0, 10, 10, 0]</code></p>
<ul>
<li><code>valsPerBase</code> = the length of the curve = 4</li>
<li><code>midPeak</code> = 4 / 2 = 2</li>
<li>The peaks generated are <code>[2, 6, 10, 14, 18......</code>, one element per length of the input FASTA.</li>
<li>This is the data that is stored in the <code>PLOC</code> directory entry.</li>
</ul>
<h3 id="generating-the-abif">Generating the ABIF</h3>
<p>We now have all the data we need, the <code>mk*</code> functions are used to generate the minimal set of directories</p>
<h6 id="srchyraxabifgenerate.hs-150-to-170">src/Hyrax/Abif/Generate.hs (150 to 170)</h6>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1">    <span class="co">-- Create the ABIF directories</span></a>
<a class="sourceLine" id="cb54-2" title="2">    dirs <span class="fu">=</span> [ mkData  <span class="dv">9</span> <span class="fu">$</span> trData09G tr <span class="co">-- G</span></a>
<a class="sourceLine" id="cb54-3" title="3">           , mkData <span class="dv">10</span> <span class="fu">$</span> trData10A tr <span class="co">-- A</span></a>
<a class="sourceLine" id="cb54-4" title="4">           , mkData <span class="dv">11</span> <span class="fu">$</span> trData11T tr <span class="co">-- T</span></a>
<a class="sourceLine" id="cb54-5" title="5">           , mkData <span class="dv">12</span> <span class="fu">$</span> trData12C tr <span class="co">-- C</span></a>
<a class="sourceLine" id="cb54-6" title="6">           , mkBaseOrder <span class="dt">BaseG</span> <span class="dt">BaseA</span> <span class="dt">BaseT</span> <span class="dt">BaseC</span> <span class="co">-- Base order, should be GATC for 3500</span></a>
<a class="sourceLine" id="cb54-7" title="7">           , mkLane <span class="dv">1</span> <span class="co">-- Lane or capliary number</span></a>
<a class="sourceLine" id="cb54-8" title="8">           , mkCalledBases <span class="fu">$</span> trFasta tr <span class="co">-- Called bases</span></a>
<a class="sourceLine" id="cb54-9" title="9">           , mkMobilityFileName <span class="dv">1</span> <span class="st">&quot;KB_3500_POP7_BDTv3.mob&quot;</span> <span class="co">-- Mobility file name</span></a>
<a class="sourceLine" id="cb54-10" title="10">           , mkMobilityFileName <span class="dv">2</span> <span class="st">&quot;KB_3500_POP7_BDTv3.mob&quot;</span> <span class="co">-- Mobility file name</span></a>
<a class="sourceLine" id="cb54-11" title="11">           , mkPeakLocations <span class="fu">$</span> <span class="fu">fromIntegral</span> <span class="fu">&lt;$&gt;</span> peakLocations <span class="co">-- Peak locations</span></a>
<a class="sourceLine" id="cb54-12" title="12">           , mkDyeSignalStrength <span class="dv">53</span> <span class="dv">75</span> <span class="dv">79</span> <span class="dv">48</span> <span class="co">-- Signal strength per dye</span></a>
<a class="sourceLine" id="cb54-13" title="13">           , mkSampleName sampleName  <span class="co">-- Sample name</span></a>
<a class="sourceLine" id="cb54-14" title="14">           , mkComment <span class="st">&quot;Generated by HyraxBio AB1 generator&quot;</span></a>
<a class="sourceLine" id="cb54-15" title="15">           ]</a>
<a class="sourceLine" id="cb54-16" title="16"></a>
<a class="sourceLine" id="cb54-17" title="17">    <span class="co">-- The ABIF</span></a>
<a class="sourceLine" id="cb54-18" title="18">    abif <span class="fu">=</span> <span class="dt">Abif</span> { aHeader <span class="fu">=</span> mkHeader</a>
<a class="sourceLine" id="cb54-19" title="19">                , aRootDir <span class="fu">=</span> mkRoot</a>
<a class="sourceLine" id="cb54-20" title="20">                , aDirs <span class="fu">=</span> dirs</a>
<a class="sourceLine" id="cb54-21" title="21">                }</a></code></pre></div>
<p>And with that we can generate any test ABIF we need. The code is much shorter than the explanation. Hopefully with the guidance from this post and the code comments it should be easy enough to follow.</p>
<h1 id="testing">Testing</h1>
<p>The package comes with property tests that test</p>
<ul>
<li>Weighted FASTA parsing</li>
<li>Round tripping a ABIF, i.e. generated ABIF == generated + read + written + read</li>
<li>That the peaks in a generated ABIF represent the expected nucleotide sequence.</li>
</ul>
<p>We used <a href="http://hackage.haskell.org/package/hedgehog">Hedgehog</a> for the property tests. It made writing the properties &amp; generators (see the <code>Generators</code> module) really easy.</p>
<p>For more details see the property tests and the following Hedgehog links</p>
<ul>
<li><a href="http://hackage.haskell.org/package/hedgehog">Hedgehog on hackage</a></li>
<li><a href="https://teh.id.au/posts/2017/04/23/property-testing-with-hedgehog/index.html">Tim Humphries’ introduction to Hedgehog</a></li>
</ul>
<h1 id="conclusion">Conclusion</h1>
<p>Hopefully you find this package useful, either as a standalone tool or as a library. If you do we would love to hear how you are using it.</p>
<p>If you have any questions feel free to email me.</p>
<p>Thanks</p>
<p>Andre.</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://github.com/hyraxbio/hyraxAbif">Code on github</a>
<ul>
<li>Latest code is on <code>master</code> branch</li>
<li>Code for the blog is on the <code>blog</code> branch, commit = <code>3fa4f873bcb54756d520f9d2f2cd4995aeccaa4c</code></li>
</ul></li>
<li><a href="https://www.reddit.com/r/haskell/comments/ae8qv2/parsing_and_generating_abif_files_dna/">Comments thread on /r/haskell subreddit</a></li>
<li><a href="https://hackage.haskell.org/package/hyraxAbif">HyraxAbif package on hackage</a></li>
<li><a href="http://www6.appliedbiosystems.com/support/software_community/ABIF_File_Format.pdf">ABIF spec</a></li>
<li><a href="https://hyraxbio.co.za">HyraxBio</a></li>
<li><a href="http://hackage.haskell.org/package/hedgehog">Hedgehog</a></li>
</ul>


        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          
          ga('create', 'UA-78428674-1', 'auto');
          ga('send', 'pageview');
        </script>
    </body>
</html>
