<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Andre's Blog</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Blog</a>
            </div>
            <div id="navigation">
                <a href="../../">Home</a>
                <a href="../../contact.html">Contact</a>
                <!-- <a href="/about.html">About</a> -->
            </div>
        </div>

        <div id="content">
            <h1><a href="#top">Haskell roguelike - Utility AI</a></h1>

            <div class="info">
    Posted on April  2, 2018
    
</div>

<p><a href="../2018-04-02-haskell-rogue-like.html">start</a> <a href="2018-04-02-haskell-rogue-like_12.html">prev</a> <a href="2018-04-02-haskell-rogue-like_14.html">next</a></p>
<h1 id="ai">AI</h1>
<p>Finally my favorite part of the code. Implementing some form of “AI” was a major part of the reason I decided to make a roguelike in the first place.</p>
<p>As always there are options to choose from</p>
<ol type="1">
<li>Hard coded if-then-else logic</li>
<li>State machines</li>
<li>Statecharts</li>
<li>Behaviour trees</li>
<li>Utility ai</li>
<li>Genetic algorithms</li>
<li>Neural networks</li>
<li>etc.</li>
</ol>
<p>Hard coded if-then-else logic is too inflexible and in my opinion can be rule out immediately.</p>
<p>State machines for AI have issues</p>
<ul>
<li>States are not composable / reusable, so its hard to share logic</li>
<li>They quickly get out of hand when you start adding more logic, the state explosion problem</li>
<li>You are always at a state (its in the name!). Its hard to make a reasonable state machine if you need to always/often run a global ruleset. E.g. the actor is in a “hunger” state but “evading capture” should sometimes take precedence.</li>
</ul>
<p>Statecharts are an option. They resolve many of the state machine flaws. However there are very few good statechart libraries around and implementing them well is far from trivial.</p>
<p><a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)">Behaviour trees</a> are another possibility. They handle they global rule issue. However they did seem more complex than utility AI, so I avoided them.</p>
<p>Genetic algorithms and neural networks can more realistically be called AI. However they can mostly be ruled out for rogue likes for several reasons</p>
<ul>
<li>Complexity. Non-trivial code, not usually worth the effort given the following issues</li>
<li>Training. You can’t train them during a game, there are far to few moves / interactions to get reasonable training data</li>
<li>Predictability. This is the biggest flaw in my opinion. When you are designing your game you will almost certainly want your actor classes to behave in a particular way. Its really hard to see why a neural net acts the way it does and even harder to change it to act subtly differently. Since we almost always want deterministic behaviour why go to the trouble of trying to evolve something to do that.</li>
</ul>
<p>Utility AI is what I went with. The idea is quite simple to understand and is easy to tweak the settings to get exactly the behaviour you want. Utility AI also handles complex behaviour simply and makes reusing / composing logic trivial.</p>
<p>The trade off between the options here is both complexity and predictability. Utility AI seems to me to get the balance right.</p>
<h1 id="utility-ai">Utility AI</h1>
<p>The theory is pretty simple: You have a set of functions that calculate the utility of independent “desires”. E.g. utility of hunger / wanderlust / aggression / healing etc. For each turn you simply select the utility with the highest value.</p>
<p>The utility functions are usually designed to return a normalised value between 0 and 1. They are also most often implemented as a formula which is easy to visualise on a graph</p>
<h2 id="graphs">Graphs</h2>
<p>The graphs below are from <a href="http://fooplot.com">fooplot.com</a></p>
<h3 id="infatuation-vs-wanderlust">Infatuation vs Wanderlust</h3>
<p>Lets consider two utilities. <strong>Infatuation</strong> is the utility of following the actor. <strong>Wanderlust</strong> is the utility of randomly wandering around. To get started lets set their formulas as</p>
<ul>
<li>Infatuation: <code>y = -( (x + 0.2) ^ 4 ) + 0.9</code></li>
<li>Wanderlust: <code>y = 0.15</code></li>
</ul>
<p>We can graph this as (with x and y range from 0 to 1)</p>
<p><img src="../../images/rogue_13_graph_0.9_.png" /></p>
<ul>
<li>For infatuation the input (<code>x</code>) is the distance to the player normalised to the range 0..1</li>
<li>For wander the result is always 0.15</li>
</ul>
<p>At each turn the utilities are evaluated. For example</p>
<table>
<thead>
<tr class="header">
<th>normalised distance to player</th>
<th>infatuation value</th>
<th>wander value</th>
<th>select</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.1</td>
<td>~0.8</td>
<td>0.15</td>
<td>infatuation</td>
</tr>
<tr class="even">
<td>0.5</td>
<td>~0.75</td>
<td>0.15</td>
<td>infatuation</td>
</tr>
<tr class="odd">
<td>0.8</td>
<td>~0.4</td>
<td>0.15</td>
<td>infatuation</td>
</tr>
<tr class="even">
<td>0.95</td>
<td>~0.05</td>
<td>0.15</td>
<td>wanderlust</td>
</tr>
<tr class="odd">
<td>no player in fov</td>
<td>N/A</td>
<td>0.15</td>
<td>wanderlust</td>
</tr>
</tbody>
</table>
<p>So if the player is in the actors fov the actor will almost always follow the actor, unless the actor is at the limit of the players fov. If there is no player in the actors fov then the utility of infatuation is not applicable (returns 0) so wanderlust gets selected.</p>
<h3 id="multiple-utilities">Multiple utilities</h3>
<p>As you can see with two simple formulas we already get some interesting behavior that is easy to control. It is also easy to add many utilities and we just select the highest scoring one.</p>
<p>Here are a few examples of formulas, perhaps this will give you some ideas. You can also combine these functions (see the last example).</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Formula</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="../../images/rogue_13_graph_10.png" /></td>
<td><code>(0.9 * (-x)) + 0.8</code></td>
</tr>
<tr class="even">
<td><img src="../../images/rogue_13_graph_12.png" /></td>
<td><code>0.9 - (x^3)</code></td>
</tr>
<tr class="odd">
<td><img src="../../images/rogue_13_graph_13.png" /></td>
<td><code>x ^ 8</code></td>
</tr>
<tr class="even">
<td><img src="../../images/rogue_13_graph_14.png" /></td>
<td><code>x &gt; 0.5 ? 0.2 : 0.8</code></td>
</tr>
<tr class="odd">
<td><img src="../../images/rogue_13_graph_11.png" /></td>
<td><code>x &gt; 0.4 ? (0.4  - (x ^ 8)) : 0.7</code></td>
</tr>
</tbody>
</table>
<p>Remember that the only requirement of a utility function is that it returns a value between 0..1. Using simple formulas like the ones above makes for easy to understand logic that is also easy to visualise. However you can write as much complex logic as you like in a utility function. E.g. you may take multiple inputs, rely on history, combine other simple utilities etc.</p>
<h1 id="implementing-a-utility-system">Implementing a utility system</h1>
<h2 id="types">Types</h2>
<p>I’m making the assumption that most utilities are going to decide how to react based on what is around them. Some like <em>wanderlust</em> may not but since the vast majority will I’m going to pass a list of what is around the actor (in fov) to the utility functions rather than having the utility function ask for it.</p>
<p>A <em>Path</em> describes the path to an entity</p>
<h6 id="utilitysrcutilitybrain.hs-27-to-30">13_utility/src/UtilityBrain.hs (27 to 30)</h6>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">path ::</span> <span class="dt">PathTo</span> <span class="ot">-&gt;</span> <span class="dt">Path</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">path (<span class="dt">PathToEntity</span> p _ _) <span class="fu">=</span> p</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">path (<span class="dt">PathToActor</span> p _ _) <span class="fu">=</span> p</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">path (<span class="dt">PathToPlayer</span> p _ _) <span class="fu">=</span> p</a></code></pre></div>
<p>A <em>PathTo</em> is a path to a particular type of thing</p>
<h6 id="utilitysrcgamecore.hs-106-to-108">13_utility/src/GameCore.hs (106 to 108)</h6>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">PathTo</span> <span class="fu">=</span> <span class="dt">PathToEntity</span> <span class="dt">Path</span> <span class="dt">Entity</span> <span class="dt">WorldPos</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">            <span class="fu">|</span> <span class="dt">PathToActor</span> <span class="dt">Path</span> <span class="dt">Actor</span> <span class="dt">WorldPos</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">            <span class="fu">|</span> <span class="dt">PathToPlayer</span> <span class="dt">Path</span> <span class="dt">Player</span> <span class="dt">WorldPos</span></a></code></pre></div>
<p>An <em>Impulse</em> is what the utility functions “decides” to do. To start with our actor’s impulses are pretty simplistic.</p>
<h6 id="utilitysrcgamecore.hs-112-to-113">13_utility/src/GameCore.hs (112 to 113)</h6>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Impulse</span> <span class="fu">=</span> <span class="dt">ImpMoveTowards</span> <span class="dt">Path</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">             <span class="fu">|</span> <span class="dt">ImpMoveRandom</span></a></code></pre></div>
<p>I’m calling the set of utilities for an actor the <strong>utility brain</strong>. A utility brain has a <em>disposition</em> which is the set of properties that control a utility.</p>
<h6 id="utilitysrcgamecore.hs-117-to-121">13_utility/src/GameCore.hs (117 to 121)</h6>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Disposition</span> <span class="fu">=</span> <span class="dt">Disposition</span> {<span class="ot"> _dsSmitten ::</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">                               ,<span class="ot"> _dsWanderlust ::</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">                               ,<span class="ot"> _dsWanderlustToExits ::</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">                               ,<span class="ot"> _dsSmittenWith ::</span> [<span class="dt">E.EntityType</span>]</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">                               } </a></code></pre></div>
<p>This allows each utility to have configurable values but share the same code. E.g. different actor classes may have a different wanderlust setting but still use the exact same wanderlust utility</p>
<h2 id="utility-functions">Utility functions</h2>
<p>As I said above utilities are mostly going to base decisions on where other entities are. So utilities are going to be given a list of paths to entities (<code>[PathTo]</code>) and need to return a score for any impulses resulting from looking at the paths, <code>[(Float, Impulse)]</code>. The actor can return multiple impulses, e.g. one per path, and the evaluation code will select the highest overall.</p>
<p>You can quickly end up with lots of impulses for a single move as there are multiple utilities each possibly generating multiple impulses. While building your game it is a good idea to have a way to see what impulses were generated, which one was selected and why. In the next chapter I’ll show one way of doing this. For now lets simply make sure that each utility function returns plenty of identifying information that we may need.</p>
<p>Rather than <code>[(Float, Impulse)]</code> a utility will create a <code>[(Float, Actor, Impulse, Text, Maybe PathTo)]</code></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">[ </a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  ( <span class="dt">Float</span>        <span class="co">-- The utility score 0..1</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  , <span class="dt">Actor</span>        <span class="co">-- The actor that the utility was run for</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  , <span class="dt">Impulse</span>      <span class="co">-- The Impulse to act out</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  , <span class="dt">Text</span>         <span class="co">-- Name of the utility</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  , <span class="dt">Maybe</span> <span class="dt">PathTo</span> <span class="co">-- The path that resulted in the Impulse, if applicable</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  )</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">]</a></code></pre></div>
<p>One more wrinkle… All the utility functions returns a list of impulses, only one of which is selected. Only that single utility function can thus effect the world. However its easy to imagine a utility that needs to effect the world even if it is not selected. E.g. the actor sees another actor which never attacks them, so a utility of trust could mark that actor’s class as more reliable. For that reason the utility function is given a <em>World</em> and is allowed to modify it.</p>
<p>The final utility function type is then</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">  ::</span> <span class="dt">World</span>              <span class="co">-- Original world</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ot">-&gt;</span> <span class="dt">Actor</span>              <span class="co">-- Actor that the utility is being run for</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>]           <span class="co">-- Paths to every entitiy in the actor's fov</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="ot">-&gt;</span> ( [ ( <span class="dt">Float</span>        <span class="co">-- The utility score 0..1</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">         , <span class="dt">Actor</span>        <span class="co">-- The actor that the utility was run for</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">         , <span class="dt">Impulse</span>      <span class="co">-- The Impulse to act out</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">         , <span class="dt">Text</span>         <span class="co">-- Name of the utility</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">         , <span class="dt">Maybe</span> <span class="dt">PathTo</span> <span class="co">-- The path that resulted in the Impulse, if applicable</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">         )]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">     , <span class="dt">World</span>            <span class="co">-- Updated world returned</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">     )</a></code></pre></div>
<p>And now we can add the properties to the actor</p>
<h6 id="utilitysrcgamecore.hs-40-to-47">13_utility/src/GameCore.hs (40 to 47)</h6>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">  <span class="co">-- | List of utilities in order of execution</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="co">--    Note that the world is threaded through the utilities and can be updated (i.e. in the ([], World) result)</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="co">--    The array of results has an updated actor and a score. These are speculative, and are only applied</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="co">--    if that utility is selected. The world updates are kept even if nothing is selected</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  ,<span class="ot"> _acUtilities ::</span> <span class="fu">!</span>[<span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)]</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="co">-- | The actor's disposition - the values that define the actors personality</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  ,<span class="ot"> _acDisposition ::</span> <span class="fu">!</span><span class="dt">Disposition</span></a></code></pre></div>
<h1 id="building-a-utility-brain">Building a utility brain</h1>
<h6 id="utilitysrcutilitybrain.hs-2-to-23">13_utility/src/UtilityBrain.hs (2 to 23)</h6>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -fno-warn-type-defaults #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">module</span> <span class="dt">UtilityBrain</span> ( selectTopUtility</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                    , assessUtilities</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">                    , utilityOfInfatuation</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">                    , utilityOfWander</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">                    , utilityOfWanderToExit</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">                    , emptyDisposition</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">                    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="kw">import</span> <span class="dt">Protolude</span> </a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">Lst</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Random</span> <span class="kw">as</span> <span class="dt">Rnd</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Arrow</span> <span class="kw">as</span> <span class="dt">Ar</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="kw">import</span>           <span class="dt">Control.Lens</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20"></a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="kw">import</span>           <span class="dt">GameCore</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">EntityType</span> <span class="kw">as</span> <span class="dt">E</span></a></code></pre></div>
<h2 id="rank-and-select-top-scoring-utility">Rank and select top scoring utility</h2>
<p>As mentioned above this is the type we’ll be working with for utility function results</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)</a></code></pre></div>
<h3 id="rank">Rank</h3>
<p>To rank results we only need to look at the first float</p>
<h6 id="utilitysrcutilitybrain.hs-79-to-81">13_utility/src/UtilityBrain.hs (79 to 81)</h6>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">rankUtility ::</span> [(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)] <span class="ot">-&gt;</span> [(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">rankUtility us <span class="fu">=</span> </a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  Lst.reverse <span class="fu">$</span> Lst.sortOn (\(x, _, _, _, _) <span class="ot">-&gt;</span> x) us</a></code></pre></div>
<p>I could have rather gone with <code>Lst.sortOn (^. _1)</code> but I’ve decided to leave that as is for now.</p>
<h3 id="assess">Assess</h3>
<p><em>assessUtilities</em> will run all the utility functions for an actor and get a ranked list of results</p>
<h6 id="utilitysrcutilitybrain.hs-57-to-74">13_utility/src/UtilityBrain.hs (57 to 74)</h6>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">-- | See the docs on acUtilities</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co">-- | Mainly that the world is threaded through utilities and any updates are kept even if no/other utilities are selected</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="co">-- | The actor in the results are speculative and only the actor for the selected utility gets used</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">assessUtilities ::</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">assessUtilities paths world actor <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    (rs, wNext) <span class="fu">=</span> foldl' assess ([], world) (actor <span class="fu">^.</span> acUtilities)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    ranked <span class="fu">=</span> rankUtility rs</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  (ranked, wNext)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    assess (hist, w) u <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        a <span class="fu">=</span> fromMaybe actor <span class="fu">$</span> w <span class="fu">^.</span> wdActors <span class="fu">^.</span>at (actor <span class="fu">^.</span> acId) </a>
<a class="sourceLine" id="cb11-16" data-line-number="16">        (rs, wNext) <span class="fu">=</span> u w a paths</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">      (hist <span class="fu">&lt;&gt;</span> rs, wNext)</a></code></pre></div>
<ul>
<li>The code starts by folding over the actor’s list of utilities calling <em>assess</em>. This creates a list of utilities and a final updated world</li>
<li>The results are then ranked and returned</li>
<li>The <em>assess</em> function
<ul>
<li>Tries to get an updated actor from the world. Remember that the world is getting updated so it is possible that the actor’s properties were changed. If the actor is not found use the one passed in, this is not ideal but works well enough</li>
<li>The utility function is then called, the results added to the fold’s accumulator and the latest world returned.</li>
</ul></li>
</ul>
<h3 id="select-best">Select best</h3>
<p><em>selectTopUtility</em> gets the highest scoring utility. We could just take the head of the list after <em>rankUtility</em> is called. However its possible for multiple utilities to return the same score. So <em>selectTopUtility</em> will randomly select one of the top scoring utilities. As the scores are floats I’m considering any values within 0.001 of each other to be considered equal.</p>
<h6 id="utilitysrcutilitybrain.hs-34-to-52">13_utility/src/UtilityBrain.hs (34 to 52)</h6>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">selectTopUtility ::</span> [(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">                 <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">selectTopUtility rs <span class="fu">=</span> </a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="kw">case</span> rs <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">      (u<span class="fu">@</span>(v0,a0,_,_,_)<span class="fu">:</span>_) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        <span class="co">-- Get the results with the top scores (fuzzy match)</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">        <span class="kw">let</span> top <span class="fu">=</span> Lst.takeWhile (\(v2,_,_,_,_) <span class="ot">-&gt;</span> v2 <span class="fu">&gt;=</span> v0 <span class="fu">-</span> <span class="fl">0.001</span>) rs </a>
<a class="sourceLine" id="cb12-10" data-line-number="10"></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">        <span class="co">-- Get a random index. Grab a StdGen from the first actor, and ignore the new stdgen, its not important here</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">        <span class="kw">let</span> ((idx, _), rndB) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb12-13" data-line-number="13">              <span class="kw">let</span> (rndA, rndB') <span class="fu">=</span> Rnd.split (a0 <span class="fu">^.</span> acStdGen) <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14">              (Rnd.randomR (<span class="dv">0</span>, length top <span class="fu">-</span> <span class="dv">1</span>) rndA, rndB') </a>
<a class="sourceLine" id="cb12-15" data-line-number="15"></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">        <span class="kw">case</span> atMay top idx <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">          <span class="dt">Just</span> (s, a, i, n, p) <span class="ot">-&gt;</span> <span class="dt">Just</span> (s, a <span class="fu">&amp;</span> acStdGen <span class="fu">.~</span> rndB, i, n, p)</a>
<a class="sourceLine" id="cb12-18" data-line-number="18"></a>
<a class="sourceLine" id="cb12-19" data-line-number="19">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> u</a></code></pre></div>
<h1 id="utilities">Utilities</h1>
<p>We can now start to look at implementing a few utilities.</p>
<h2 id="helpers">Helpers</h2>
<p>But first, some helper functions that will be required</p>
<p><em>path</em> gets the <em>Path</em> from a <em>PathTo</em></p>
<h6 id="utilitysrcutilitybrain.hs-27-to-30-1">13_utility/src/UtilityBrain.hs (27 to 30)</h6>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">path ::</span> <span class="dt">PathTo</span> <span class="ot">-&gt;</span> <span class="dt">Path</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">path (<span class="dt">PathToEntity</span> p _ _) <span class="fu">=</span> p</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">path (<span class="dt">PathToActor</span> p _ _) <span class="fu">=</span> p</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">path (<span class="dt">PathToPlayer</span> p _ _) <span class="fu">=</span> p</a></code></pre></div>
<p><em>clamp</em> constrains a value to the 0..1 range, using <em>clampTo</em></p>
<h6 id="utilitysrcutilitybrain.hs-86-to-91">13_utility/src/UtilityBrain.hs (86 to 91)</h6>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">clamp ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">clamp <span class="fu">=</span> clampTo <span class="fl">0.0</span> <span class="fl">1.0</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="ot">clampTo ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">clampTo vmin vmax <span class="fu">=</span> min vmax <span class="fu">.</span> max vmin</a></code></pre></div>
<p><em>onlyEntitiesOfType</em> filters a list of <em>PathTo</em> entries by entity type</p>
<h6 id="utilitysrcutilitybrain.hs-96-to-101">13_utility/src/UtilityBrain.hs (96 to 101)</h6>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">onlyEntitiesOfType ::</span> [<span class="dt">E.EntityType</span>] <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">onlyEntitiesOfType types <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  filter go</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go (<span class="dt">PathToEntity</span> _ e _) <span class="fu">=</span> e <span class="fu">^.</span> enType <span class="ot">`elem`</span> types</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    go _ <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<h2 id="wanderlust">Wanderlust</h2>
<p>This is the simplest utility, it ignores all paths and returns a single impulse to move randomly. The formula it uses is roughly <code>0.02 * (10 * dsWanderlust))</code>. The level of desire to wander is controlled by <em>dsWanderlust</em> from the actor’s disposition.</p>
<h6 id="utilitysrcutilitybrain.hs-134-to-137">13_utility/src/UtilityBrain.hs (134 to 137)</h6>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">utilityOfWander ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">utilityOfWander world actor _paths <span class="fu">=</span> </a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">let</span> rule <span class="fu">=</span> clamp <span class="fu">$</span> <span class="fl">0.02</span> <span class="fu">*</span> (<span class="dv">10</span> <span class="fu">*</span> clamp (actor <span class="fu">^.</span> acDisposition <span class="fu">^.</span> dsWanderlust)) <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  ([(rule, actor, <span class="dt">ImpMoveRandom</span>, <span class="st">&quot;wander&quot;</span>, <span class="dt">Nothing</span>)], world)</a></code></pre></div>
<h2 id="wander-to-exit">Wander to exit</h2>
<p>Wanderlust is simple but, wandering towards an exit seems more useful/interesting</p>
<h6 id="utilitysrcutilitybrain.hs-142-to-148">13_utility/src/UtilityBrain.hs (142 to 148)</h6>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">utilityOfWanderToExit ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">utilityOfWanderToExit world actor allPaths <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    rule x <span class="fu">=</span> clamp <span class="fu">$</span> <span class="dv">1</span> <span class="fu">-</span> (<span class="fl">0.04</span> <span class="fu">*</span> x <span class="fu">+</span> (<span class="fl">1.24</span> <span class="fu">-</span> clamp (actor <span class="fu">^.</span> acDisposition <span class="fu">^.</span> dsWanderlustToExits))) </a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    clampedResults <span class="fu">=</span> moveTowardsUtil [<span class="dt">E.Door</span>] rule allPaths actor</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  ((\(p, score) <span class="ot">-&gt;</span> (score, actor, <span class="dt">ImpMoveTowards</span> (path p), <span class="st">&quot;wander to exit&quot;</span>, <span class="dt">Just</span> p)) <span class="fu">&lt;$&gt;</span> clampedResults, world)</a></code></pre></div>
<p>The formula is <code>1 - (0.04 * distance_to_exit + (1.24 - dsWanderToExits))</code>. As you can see this utility has two variables, the distance_to_exit value and the dsWanderToExits setting.</p>
<p>The utility call <em>moveTowardsUtil</em> which is discussed below, and then returns an impulse to follow the path to the exit, for each one found.</p>
<h2 id="infatuation">Infatuation</h2>
<h6 id="utilitysrcutilitybrain.hs-153-to-159">13_utility/src/UtilityBrain.hs (153 to 159)</h6>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">utilityOfInfatuation ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> ([(<span class="dt">Float</span>, <span class="dt">Actor</span>, <span class="dt">Impulse</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">PathTo</span>)], <span class="dt">World</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">utilityOfInfatuation world actor allPaths <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    rule x <span class="fu">=</span> clamp <span class="fu">$</span> <span class="fu">-</span>x <span class="fu">**</span> <span class="dv">4</span> <span class="fu">+</span> clamp (actor <span class="fu">^.</span> acDisposition <span class="fu">^.</span> dsSmitten) </a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    clampedResults <span class="fu">=</span> moveTowardsUtil (actor <span class="fu">^.</span> acDisposition <span class="fu">^.</span> dsSmittenWith) rule allPaths actor</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  ((\(p, score) <span class="ot">-&gt;</span> (score, actor, <span class="dt">ImpMoveTowards</span> (path p), <span class="st">&quot;infatuation&quot;</span>, <span class="dt">Just</span> p)) <span class="fu">&lt;$&gt;</span> clampedResults, world)</a></code></pre></div>
<p>The infatuation utility is very similar to the wander to exit utility. The formula here is <code>-(distance_to_dsSmittenWith ^ 4) + dsSmitten</code></p>
<h2 id="moving-towards-an-entity">Moving towards an entity</h2>
<h6 id="utilitysrcutilitybrain.hs-164-to-177">13_utility/src/UtilityBrain.hs (164 to 177)</h6>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">moveTowardsUtil ::</span> [<span class="dt">E.EntityType</span>] <span class="ot">-&gt;</span> (<span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>) <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>] <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [(<span class="dt">PathTo</span>, <span class="dt">Float</span>)]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">moveTowardsUtil es rule paths actor <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    <span class="co">-- Find exits</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    goalPaths <span class="fu">=</span> onlyEntitiesOfType es paths</a>
<a class="sourceLine" id="cb19-6" data-line-number="6"></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">      <span class="co">-- Normalise distances</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">    pathsNormalisedMay <span class="fu">=</span> (\p <span class="ot">-&gt;</span> (p, distanceToRange p (actor <span class="fu">^.</span> acFovDistance))) <span class="fu">&lt;$&gt;</span> goalPaths </a>
<a class="sourceLine" id="cb19-9" data-line-number="9">    pathsNormalised <span class="fu">=</span> catNormalisedMay pathsNormalisedMay </a>
<a class="sourceLine" id="cb19-10" data-line-number="10">    <span class="co">-- Run utility calculation</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">    results <span class="fu">=</span> Ar.second rule <span class="fu">&lt;$&gt;</span> pathsNormalised </a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    clampedResults <span class="fu">=</span> Ar.second clamp <span class="fu">&lt;$&gt;</span> results</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    clampedResults</a></code></pre></div>
<ul>
<li>Find the entities the utility is interested in</li>
<li>Get a normalised distance to the entity using <em>distanceToRange</em></li>
<li>Run the utility calculation given the distance to the entity</li>
<li>Return scores</li>
</ul>
<h6 id="utilitysrcutilitybrain.hs-182-to-188">13_utility/src/UtilityBrain.hs (182 to 188)</h6>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">catNormalisedMay ::</span> [(<span class="dt">PathTo</span>, <span class="dt">Maybe</span> float)] <span class="ot">-&gt;</span> [(<span class="dt">PathTo</span>, float)]</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">catNormalisedMay ps <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  catMaybes <span class="fu">$</span> go <span class="fu">&lt;$&gt;</span> ps</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    go (_, <span class="dt">Nothing</span>) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    go (p, <span class="dt">Just</span> v) <span class="fu">=</span> <span class="dt">Just</span> (p, v) </a></code></pre></div>
<ul>
<li>Get all paths with a score: <code>[(PathTo, Maybe float)] -&gt; [(PathTo, float)]</code></li>
</ul>
<h2 id="getting-a-0..1-value-from-a-distance">Getting a 0..1 value from a distance</h2>
<p>To get a value in the range 0..1 for a distance, we need to calculate how far towards the end of the actor’s fov the entity is. To do this we calculate the cartesian distance to the entity, and the maximum cartesian distance to the edge of the player’s fov. The 0..1 value is then <code>distance / maxDistance</code></p>
<h6 id="utilitysrcutilitybrain.hs-114-to-129">13_utility/src/UtilityBrain.hs (114 to 129)</h6>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">distanceToRange ::</span> <span class="dt">PathTo</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">distanceToRange pt fov <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">let</span> (<span class="dt">Path</span> p) <span class="fu">=</span> path pt <span class="kw">in</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="kw">case</span> (p, Lst.reverse p) <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    ([], _) <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    (_, []) <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    (<span class="dt">WorldPos</span> (fx, fy) <span class="fu">:</span> _, <span class="dt">WorldPos</span> (tx, ty) <span class="fu">:</span> _) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">      <span class="kw">if</span> fx <span class="fu">==</span> tx <span class="fu">&amp;&amp;</span> fy <span class="fu">==</span> ty</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">      <span class="kw">then</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">        <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">      <span class="kw">else</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12">        <span class="co">-- Distance to point</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">        <span class="kw">let</span> distance <span class="fu">=</span> sqrt <span class="fu">.</span> fromIntegral <span class="fu">$</span> ((tx <span class="fu">-</span> fx) <span class="fu">^</span> <span class="dv">2</span>) <span class="fu">+</span> ((ty <span class="fu">-</span> fy) <span class="fu">^</span> <span class="dv">2</span>) <span class="kw">in</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14">        <span class="co">-- Max distance for fov, i.e. cartesian distance to a corner of the fov</span></a>
<a class="sourceLine" id="cb21-15" data-line-number="15">        <span class="kw">let</span> maxDist <span class="fu">=</span> sqrt ((fromIntegral fov <span class="fu">**</span> <span class="dv">2</span>) <span class="fu">*</span> <span class="dv">2</span>) <span class="kw">in</span></a>
<a class="sourceLine" id="cb21-16" data-line-number="16">        <span class="dt">Just</span> <span class="fu">$</span> distance <span class="fu">/</span> maxDist</a></code></pre></div>
<h2 id="graphs-1">Graphs</h2>
<p>So far this is what the three utilities look like. This is assuming that the utility of infatuation is given a distance of 0.5</p>
<p><img src="../../images/rogue_13_graph_utils.png" /></p>
<p>As your utilities get more complex they get harder to graph, but I’ve still found it useful to graph what I can to visualise how they interact. In the next chapter I’ll look at a way to trace what is happening.</p>
<h1 id="using-utility-brains">Using utility brains</h1>
<p>Having built the utility system all that is left is to use it in the engine.</p>
<h2 id="find-everything-in-a-fov">Find everything in a fov</h2>
<p>For every path in a field of view call <em>findPaths</em>, which creates a list of <em>PathTo</em> items.</p>
<h6 id="utilitysrcgameengine.hs-862-to-901">13_utility/src/GameEngine.hs (862 to 901)</h6>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">findPathToAllInFov ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">findPathToAllInFov w a <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="kw">case</span> a <span class="fu">^.</span> acFov <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="dt">Just</span> fov <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">      <span class="kw">let</span> wmap <span class="fu">=</span> addActorsToMap w <span class="kw">in</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">      concat (findPaths wmap <span class="fu">&lt;$&gt;</span> fov)</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10"><span class="ot">    findPaths ::</span> <span class="dt">Map</span> <span class="dt">WorldPos</span> <span class="dt">Entity</span> <span class="ot">-&gt;</span> (<span class="dt">WorldPos</span>, [<span class="dt">WorldPos</span>]) <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>]</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">    findPaths wmap (dest, points) <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-12" data-line-number="12">      snd <span class="fu">$</span> foldl'</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">              (\(trail, paths) atPos <span class="ot">-&gt;</span> (trail <span class="fu">&lt;&gt;</span> [atPos], paths <span class="fu">&lt;&gt;</span> findAt dest wmap (trail <span class="fu">&lt;&gt;</span> [atPos]) atPos))</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">              ([], [])</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">              points</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">      </a>
<a class="sourceLine" id="cb22-17" data-line-number="17"></a>
<a class="sourceLine" id="cb22-18" data-line-number="18"><span class="ot">    findAt ::</span> <span class="dt">WorldPos</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">WorldPos</span> <span class="dt">Entity</span> <span class="ot">-&gt;</span> [<span class="dt">WorldPos</span>] <span class="ot">-&gt;</span> <span class="dt">WorldPos</span> <span class="ot">-&gt;</span> [<span class="dt">PathTo</span>]</a>
<a class="sourceLine" id="cb22-19" data-line-number="19">    findAt dest wmap trail atPos <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">      <span class="kw">let</span> ps <span class="fu">=</span> <span class="kw">if</span> atPos <span class="fu">==</span> w <span class="fu">^.</span> wdPlayer <span class="fu">^.</span> plActor <span class="fu">^.</span> acWorldPos</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">               <span class="kw">then</span> [ <span class="dt">PathToPlayer</span> (<span class="dt">Path</span> trail) (w <span class="fu">^.</span> wdPlayer) dest</a>
<a class="sourceLine" id="cb22-22" data-line-number="22">                    , <span class="dt">PathToActor</span> (<span class="dt">Path</span> trail) (w <span class="fu">^.</span> wdPlayer <span class="fu">^.</span> plActor) dest</a>
<a class="sourceLine" id="cb22-23" data-line-number="23">                    ]</a>
<a class="sourceLine" id="cb22-24" data-line-number="24">               <span class="kw">else</span> []</a>
<a class="sourceLine" id="cb22-25" data-line-number="25">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb22-26" data-line-number="26">      <span class="kw">let</span> es <span class="fu">=</span> <span class="kw">case</span> wmap <span class="fu">^.</span>at atPos <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-27" data-line-number="27">                 <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb22-28" data-line-number="28">                 <span class="dt">Just</span> e <span class="ot">-&gt;</span> <span class="kw">if</span> e <span class="fu">^.</span> enType <span class="fu">==</span> <span class="dt">E.Blank</span></a>
<a class="sourceLine" id="cb22-29" data-line-number="29">                              <span class="kw">then</span> []</a>
<a class="sourceLine" id="cb22-30" data-line-number="30">                              <span class="kw">else</span> [<span class="dt">PathToEntity</span> (<span class="dt">Path</span> trail) e dest]</a>
<a class="sourceLine" id="cb22-31" data-line-number="31">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb22-32" data-line-number="32">      ps <span class="fu">&lt;&gt;</span> es</a>
<a class="sourceLine" id="cb22-33" data-line-number="33"></a>
<a class="sourceLine" id="cb22-34" data-line-number="34">  </a>
<a class="sourceLine" id="cb22-35" data-line-number="35"><span class="ot">addActorsToMap ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">WorldPos</span> <span class="dt">Entity</span></a>
<a class="sourceLine" id="cb22-36" data-line-number="36">addActorsToMap w <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-37" data-line-number="37">  foldr</a>
<a class="sourceLine" id="cb22-38" data-line-number="38">    (\a g <span class="ot">-&gt;</span> Map.insert (a <span class="fu">^.</span> acWorldPos) (a <span class="fu">^.</span> acEntity) g)</a>
<a class="sourceLine" id="cb22-39" data-line-number="39">    (w <span class="fu">^.</span> wdMap)</a>
<a class="sourceLine" id="cb22-40" data-line-number="40">    (getAllActors w)</a></code></pre></div>
<h2 id="act-on-impulse">Act on impulse</h2>
<p>Selecting the top utility gives us the <em>Impulse</em> to act to. <em>actOnImpulse</em> is the function that handles this</p>
<h6 id="utilitysrcgameengine.hs-816-to-851">13_utility/src/GameEngine.hs (816 to 851)</h6>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">actOnImpulse ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">Actor</span> <span class="ot">-&gt;</span> <span class="dt">Impulse</span> <span class="ot">-&gt;</span> <span class="dt">World</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">actOnImpulse cost w actorIfMoved impulse <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">let</span> (dx, dy, nextStdGen) <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">        <span class="kw">let</span> initialStdGen <span class="fu">=</span> (actorIfMoved <span class="fu">^.</span> acStdGen) <span class="kw">in</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        <span class="kw">case</span> impulse <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">          <span class="dt">ImpMoveRandom</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">            <span class="kw">let</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">              (dx', s1) <span class="fu">=</span> Rnd.randomR (<span class="fu">-</span><span class="dv">1</span>, <span class="dv">1</span>) initialStdGen</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">              (dy', s2) <span class="fu">=</span> Rnd.randomR (<span class="fu">-</span><span class="dv">1</span>, <span class="dv">1</span>) s1 </a>
<a class="sourceLine" id="cb23-11" data-line-number="11">            <span class="kw">in</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">            (dx', dy', s2)</a>
<a class="sourceLine" id="cb23-13" data-line-number="13"></a>
<a class="sourceLine" id="cb23-14" data-line-number="14">          <span class="dt">ImpMoveTowards</span> (<span class="dt">Path</span> ps) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">            <span class="kw">case</span> ps <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">              (_<span class="fu">:</span><span class="dt">WorldPos</span> (tx, ty)<span class="fu">:</span>_) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">                <span class="kw">let</span> (<span class="dt">WorldPos</span> (fx, fy)) <span class="fu">=</span> actorIfMoved <span class="fu">^.</span> acWorldPos <span class="kw">in</span></a>
<a class="sourceLine" id="cb23-18" data-line-number="18">                (tx <span class="fu">-</span> fx, ty <span class="fu">-</span> fy, initialStdGen)</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">              _ <span class="ot">-&gt;</span> (<span class="dv">0</span>, <span class="dv">0</span>, initialStdGen)</a>
<a class="sourceLine" id="cb23-20" data-line-number="20"></a>
<a class="sourceLine" id="cb23-21" data-line-number="21">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb23-22" data-line-number="22">  <span class="kw">if</span> dx <span class="fu">/=</span><span class="dv">0</span> <span class="fu">||</span> dy <span class="fu">/=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb23-23" data-line-number="23">  <span class="kw">then</span></a>
<a class="sourceLine" id="cb23-24" data-line-number="24">    <span class="kw">let</span> worldIfMoved <span class="fu">=</span> w <span class="fu">&amp;</span> wdActors <span class="fu">%~</span> Map.insert (actorIfMoved <span class="fu">^.</span> acId) actorIfMoved <span class="kw">in</span></a>
<a class="sourceLine" id="cb23-25" data-line-number="25">     </a>
<a class="sourceLine" id="cb23-26" data-line-number="26">    <span class="kw">case</span> tryMoveActor worldIfMoved actorIfMoved (dx, dy) <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-27" data-line-number="27">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-28" data-line-number="28">        w <span class="fu">&amp;</span> wdActors <span class="fu">%~</span> Map.adjust (\a' <span class="ot">-&gt;</span> a' <span class="fu">&amp;</span> acStdGen <span class="fu">.~</span> nextStdGen) (actorIfMoved <span class="fu">^.</span> acId)</a>
<a class="sourceLine" id="cb23-29" data-line-number="29"></a>
<a class="sourceLine" id="cb23-30" data-line-number="30">      <span class="dt">Just</span> w' <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-31" data-line-number="31">        w' <span class="fu">&amp;</span> wdActors <span class="fu">%~</span> Map.adjust (\a' <span class="ot">-&gt;</span> updateActorFov w' <span class="fu">$</span> a' <span class="fu">&amp;</span> acEnergy <span class="fu">%~</span> B.update (subtract cost)</a>
<a class="sourceLine" id="cb23-32" data-line-number="32">                                                                   <span class="fu">&amp;</span> acStdGen <span class="fu">.~</span> nextStdGen</a>
<a class="sourceLine" id="cb23-33" data-line-number="33">                                    )</a>
<a class="sourceLine" id="cb23-34" data-line-number="34">                                    (actorIfMoved <span class="fu">^.</span> acId)</a>
<a class="sourceLine" id="cb23-35" data-line-number="35">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb23-36" data-line-number="36">    w <span class="fu">&amp;</span> wdActors <span class="fu">%~</span> Map.adjust (\a' <span class="ot">-&gt;</span> a' <span class="fu">&amp;</span> acStdGen <span class="fu">.~</span> nextStdGen) (actorIfMoved <span class="fu">^.</span> acId)</a></code></pre></div>
<ul>
<li>Get a delta (x, y) for a <em>ImpMoveRandom</em> or <em>ImpMoveTowards</em></li>
<li>Try perform the move</li>
</ul>
<h2 id="energy-system-update">Energy system update</h2>
<p>Previously the energy system moved the non-player actors around randomly. Now we can plug in the utility system and get slightly smarter behaviour. <em>moveAllNonPlayers</em> is updated in <em>playerMoving</em> to be</p>
<h6 id="utilitysrcgameengine.hs-755-to-781">13_utility/src/GameEngine.hs (755 to 781)</h6>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">    moveAllNonPlayers w <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">      <span class="kw">let</span> mv aOrig wOrig <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">            <span class="kw">let</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">              inFov <span class="fu">=</span> findPathToAllInFov wOrig aOrig </a>
<a class="sourceLine" id="cb24-5" data-line-number="5">              (utilities, wNext) <span class="fu">=</span> UB.assessUtilities inFov wOrig aOrig </a>
<a class="sourceLine" id="cb24-6" data-line-number="6">            <span class="kw">in</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">            <span class="kw">case</span> UB.selectTopUtility utilities <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">              <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">                <span class="co">-- No utility = no move, skip</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">                updateActorById wNext (aOrig <span class="fu">^.</span> acId) (\a <span class="ot">-&gt;</span> a <span class="fu">&amp;</span> acSkipMove <span class="fu">.~</span> <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb24-12" data-line-number="12"></a>
<a class="sourceLine" id="cb24-13" data-line-number="13">              <span class="dt">Just</span> (_, actorIfMoved, action, _, _) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-14" data-line-number="14">                <span class="kw">let</span> cost <span class="fu">=</span> floor <span class="fu">.</span> fromIntegral <span class="fu">$</span> aOrig <span class="fu">^.</span> acMoveEnergyCost <span class="kw">in</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">                </a>
<a class="sourceLine" id="cb24-16" data-line-number="16">                <span class="kw">if</span> cost <span class="fu">&gt;</span> B.get (aOrig <span class="fu">^.</span> acEnergy)</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">                <span class="kw">then</span></a>
<a class="sourceLine" id="cb24-18" data-line-number="18">                  <span class="co">-- Not enough energy to move, disallow. Set skipMove = True so this is not attempted again before</span></a>
<a class="sourceLine" id="cb24-19" data-line-number="19">                  <span class="co">-- the next actor move (i.e. avoid looping)</span></a>
<a class="sourceLine" id="cb24-20" data-line-number="20">                  wNext <span class="fu">&amp;</span> wdActors <span class="fu">%~</span> Map.insert (aOrig <span class="fu">^.</span> acId) (aOrig <span class="fu">&amp;</span> acSkipMove <span class="fu">.~</span> <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb24-21" data-line-number="21">                <span class="kw">else</span></a>
<a class="sourceLine" id="cb24-22" data-line-number="22">                  actOnImpulse cost wNext actorIfMoved action</a>
<a class="sourceLine" id="cb24-23" data-line-number="23">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb24-24" data-line-number="24"></a>
<a class="sourceLine" id="cb24-25" data-line-number="25">      <span class="kw">let</span> actorsThatCanMove <span class="fu">=</span> filter</a>
<a class="sourceLine" id="cb24-26" data-line-number="26">                                (\a <span class="ot">-&gt;</span> B.get (a <span class="fu">^.</span> acEnergy) <span class="fu">&gt;=</span> (w <span class="fu">^.</span> wdMinMoveEnergy) <span class="fu">&amp;&amp;</span> not (a <span class="fu">^.</span> acSkipMove))</a>
<a class="sourceLine" id="cb24-27" data-line-number="27">                                (Map.elems <span class="fu">$</span> w <span class="fu">^.</span> wdActors)</a></code></pre></div>
<ul>
<li>Assess utilities</li>
<li>Get the top scoring one</li>
<li>Move if the actor has enough energy</li>
</ul>
<h1 id="result">Result</h1>
<p>Here is the final result. You can see the bug following the player and the snake going to the door.</p>
<p><img src="../../images/rogue_13_final.gif" /></p>
<h1 id="chapters">Chapters</h1>
<p><a href="../2018-04-02-haskell-rogue-like.html">start</a> <a href="2018-04-02-haskell-rogue-like_12.html">prev</a> <a href="2018-04-02-haskell-rogue-like_14.html">next</a></p>
<h1 id="changes">Changes</h1>
<div class="wrapper">
<h2 class=".diffh2">
src/GameCore.hs
</h2>
<div class="file-diff">
<pre class="diffpre difffile">diff -w -B -a -d -u -b --new-file 12_energy/src/GameCore.hs 13_utility/src/GameCore.hs</pre>
<pre class="diffpre delete">--- 12_energy/src/GameCore.hs</pre>
<pre class="diffpre insert">+++ 13_utility/src/GameCore.hs</pre>
<pre class="diffpre info">@@ -32,11 +32,20 @@</pre>
<pre class="diffpre context">                    , _acFov :: !(Maybe [(WorldPos, [WorldPos])])</pre>
<pre class="diffpre context">                    , _acFovHistory :: !(Set WorldPos)</pre>
<pre class="diffpre context">                    , _acFovDistance :: !Int</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context">                    , _acEnergy :: !B.BInt -- ^ available energy, bounded</pre>
<pre class="diffpre context">                    , _acMoveEnergyCost :: !Int</pre>
<pre class="diffpre context">                    , _acSkipMove :: !Bool</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+                   -- | List of utilities in order of execution</pre>
<pre class="diffpre insert">+                   --    Note that the world is threaded through the utilities and can be updated (i.e. in the ([], World) result)</pre>
<pre class="diffpre insert">+                   --    The array of results has an updated actor and a score. These are speculative, and are only applied</pre>
<pre class="diffpre insert">+                   --    if that utility is selected. The world updates are kept even if nothing is selected</pre>
<pre class="diffpre insert">+                   , _acUtilities :: ![World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)]</pre>
<pre class="diffpre insert">+                   </pre>
<pre class="diffpre insert">+                   -- | The actor's disposition - the values that define the actors personality</pre>
<pre class="diffpre insert">+                   , _acDisposition :: !Disposition</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">                    }</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> data Player = Player { _plConn :: !Host.Connection</pre>
<pre class="diffpre info">@@ -86,6 +93,39 @@</pre>
<pre class="diffpre context">                    deriving (Show, Eq)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+----------------------------------------------------------------------------------------</pre>
<pre class="diffpre insert">+-- Utility brain types</pre>
<pre class="diffpre insert">+----------------------------------------------------------------------------------------</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+newtype Path = Path [WorldPos] deriving (Show)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+data PathTo = PathToEntity Path Entity WorldPos</pre>
<pre class="diffpre insert">+            | PathToActor Path Actor WorldPos</pre>
<pre class="diffpre insert">+            | PathToPlayer Path Player WorldPos</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+data Impulse = ImpMoveTowards Path</pre>
<pre class="diffpre insert">+             | ImpMoveRandom</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+data Disposition = Disposition { _dsSmitten :: Float</pre>
<pre class="diffpre insert">+                               , _dsWanderlust :: Float</pre>
<pre class="diffpre insert">+                               , _dsWanderlustToExits :: Float</pre>
<pre class="diffpre insert">+                               , _dsSmittenWith :: [E.EntityType]</pre>
<pre class="diffpre insert">+                               } </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+----------------------------------------------------------------------------------------</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+----------------------------------------------------------------------------------------</pre>
<pre class="diffpre insert">+-- UI types</pre>
<pre class="diffpre insert">+----------------------------------------------------------------------------------------</pre>
<pre class="diffpre context"> data UiMessage = UiMessage { umCmd :: !Text</pre>
<pre class="diffpre context">                            , umMessage :: !Text</pre>
<pre class="diffpre context">                            }</pre>
<pre class="diffpre info">@@ -137,7 +177,7 @@</pre>
<pre class="diffpre context">   Txt.unpack . (if toLower then mkLower else identity) . Txt.drop drp . Txt.pack</pre>
<pre class="diffpre context">   where</pre>
<pre class="diffpre context">     mkLower t = Txt.toLower (Txt.take 1 t) &lt;&gt; Txt.drop 1 t</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre insert">+----------------------------------------------------------------------------------------</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> makeLenses ''World</pre>
<pre class="diffpre context"> makeLenses ''Config</pre>
<pre class="diffpre info">@@ -145,3 +185,4 @@</pre>
<pre class="diffpre context"> makeLenses ''Entity</pre>
<pre class="diffpre context"> makeLenses ''Tile</pre>
<pre class="diffpre context"> makeLenses ''Actor</pre>
<pre class="diffpre insert">+makeLenses ''Disposition</pre>
</div>
<h2 class=".diffh2">
src/GameEngine.hs
</h2>
<div class="file-diff">
<pre class="diffpre difffile">diff -w -B -a -d -u -b --new-file 12_energy/src/GameEngine.hs 13_utility/src/GameEngine.hs</pre>
<pre class="diffpre delete">--- 12_energy/src/GameEngine.hs</pre>
<pre class="diffpre insert">+++ 13_utility/src/GameEngine.hs</pre>
<pre class="diffpre info">@@ -1,3 +1,4 @@</pre>
<pre class="diffpre insert">+{-# OPTIONS_GHC -fno-warn-type-defaults #-}</pre>
<pre class="diffpre context"> {-# LANGUAGE NoImplicitPrelude #-}</pre>
<pre class="diffpre context"> {-# LANGUAGE OverloadedStrings #-}</pre>
<pre class="diffpre context"> {-# LANGUAGE MultiWayIf #-}</pre>
<pre class="diffpre info">@@ -27,6 +28,7 @@</pre>
<pre class="diffpre context"> import qualified Entities as E</pre>
<pre class="diffpre context"> import qualified EntityType as E</pre>
<pre class="diffpre context"> import qualified BoundedInt as B</pre>
<pre class="diffpre insert">+import qualified UtilityBrain as UB</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> runGame :: IO ()</pre>
<pre class="diffpre info">@@ -83,8 +85,19 @@</pre>
<pre class="diffpre context"> bootWorld conn screenSize mapData std = </pre>
<pre class="diffpre context">   let</pre>
<pre class="diffpre context">     config = mkConfig</pre>
<pre class="diffpre delete">-    bug = mkEnemyActor "bug1" E.Bug (6, -2)</pre>
<pre class="diffpre delete">-    snake = mkEnemyActor "snake1" E.Snake (8, -4)</pre>
<pre class="diffpre insert">+    bug = mkEnemyActor "bug1" E.Bug (6, -2) &amp; acUtilities .~ [UB.utilityOfInfatuation, UB.utilityOfWander, UB.utilityOfWanderToExit]</pre>
<pre class="diffpre insert">+                                            &amp; acDisposition .~ Disposition { _dsSmitten = 0.8</pre>
<pre class="diffpre insert">+                                                                           , _dsWanderlust = 0.35</pre>
<pre class="diffpre insert">+                                                                           , _dsWanderlustToExits = 0.4</pre>
<pre class="diffpre insert">+                                                                           , _dsSmittenWith = [E.Player]</pre>
<pre class="diffpre insert">+                                                                           }</pre>
<pre class="diffpre insert">+          </pre>
<pre class="diffpre insert">+    snake = mkEnemyActor "snake1" E.Snake (8, -4) &amp; acUtilities .~ [UB.utilityOfWander, UB.utilityOfWanderToExit]</pre>
<pre class="diffpre insert">+                                                  &amp; acDisposition .~ Disposition { _dsSmitten = 0</pre>
<pre class="diffpre insert">+                                                                                 , _dsWanderlust = 0.35</pre>
<pre class="diffpre insert">+                                                                                 , _dsWanderlustToExits = 0.4</pre>
<pre class="diffpre insert">+                                                                                 , _dsSmittenWith = []</pre>
<pre class="diffpre insert">+                                                                                 }</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context">     w1 = World { _wdPlayer = mkPlayer</pre>
<pre class="diffpre context">                , _wdConfig = config</pre>
<pre class="diffpre info">@@ -147,11 +158,11 @@</pre>
<pre class="diffpre context">             , _acFovDistance = 3</pre>
<pre class="diffpre context">             , _acFov = Nothing</pre>
<pre class="diffpre context">             , _acFovHistory = Set.empty</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context">             , _acSkipMove = False</pre>
<pre class="diffpre context">             , _acMoveEnergyCost = 100</pre>
<pre class="diffpre context">             , _acEnergy = B.new 200 100</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre insert">+            , _acUtilities = []</pre>
<pre class="diffpre insert">+            , _acDisposition = UB.emptyDisposition</pre>
<pre class="diffpre context">             }</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context">     mkEnemyActor aid e (x, y) =</pre>
<pre class="diffpre info">@@ -163,11 +174,11 @@</pre>
<pre class="diffpre context">             , _acFovDistance = 2</pre>
<pre class="diffpre context">             , _acFov = Nothing</pre>
<pre class="diffpre context">             , _acFovHistory = Set.empty</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context">             , _acSkipMove = False</pre>
<pre class="diffpre context">             , _acMoveEnergyCost = 150</pre>
<pre class="diffpre context">             , _acEnergy = B.new 180 100</pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre insert">+            , _acUtilities = []</pre>
<pre class="diffpre insert">+            , _acDisposition = UB.emptyDisposition </pre>
<pre class="diffpre context">             }</pre>
<pre class="diffpre context">     </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre info">@@ -754,35 +752,34 @@</pre>
<pre class="diffpre context">         runNonPlayerActorLoop $ updateAllActors w' addEnergy</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context">     moveAllNonPlayers w =</pre>
<pre class="diffpre insert">+      let mv aOrig wOrig =</pre>
<pre class="diffpre context">       let</pre>
<pre class="diffpre delete">-        -- Random directions the actors could move in (no diagonal moves)</pre>
<pre class="diffpre delete">-        directions = [(-1,0), (0,-1), (0,1), (1,0)]</pre>
<pre class="diffpre delete">-  </pre>
<pre class="diffpre delete">-        -- Other actors just try to move in random directions</pre>
<pre class="diffpre delete">-        mv aOrig wOrig =</pre>
<pre class="diffpre delete">-          let</pre>
<pre class="diffpre delete">-            -- Pick a random direction to move</pre>
<pre class="diffpre delete">-            (dir, nextStd) = randomElement (aOrig ^. acStdGen) directions </pre>
<pre class="diffpre delete">-            -- Try move, i.e. if there is no wall / actor in the way</pre>
<pre class="diffpre delete">-            w2 = tryMoveActor wOrig aOrig $ fromMaybe (0, 0) dir</pre>
<pre class="diffpre insert">+              inFov = findPathToAllInFov wOrig aOrig </pre>
<pre class="diffpre insert">+              (utilities, wNext) = UB.assessUtilities inFov wOrig aOrig </pre>
<pre class="diffpre context">           in</pre>
<pre class="diffpre delete">-          case w2 of</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+            case UB.selectTopUtility utilities of</pre>
<pre class="diffpre context">             Nothing -&gt;</pre>
<pre class="diffpre delete">-              -- Unable to move, so skip a turn. This accumulates energy for the next attempt</pre>
<pre class="diffpre delete">-              --  Also update the stdgen for the next time a random number is needed</pre>
<pre class="diffpre delete">-              updateActor wOrig $ aOrig &amp; acSkipMove .~ True</pre>
<pre class="diffpre delete">-                                        &amp; acStdGen .~ nextStd</pre>
<pre class="diffpre insert">+                -- No utility = no move, skip</pre>
<pre class="diffpre insert">+                updateActorById wNext (aOrig ^. acId) (\a -&gt; a &amp; acSkipMove .~ True)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-            Just w2' -&gt;</pre>
<pre class="diffpre delete">-              -- The actor moved, use the new world but remember to update the stdgen</pre>
<pre class="diffpre delete">-              updateActorById w2' (aOrig ^. acId) (\a -&gt; a &amp; acStdGen .~ nextStd)</pre>
<pre class="diffpre insert">+              Just (_, actorIfMoved, action, _, _) -&gt;</pre>
<pre class="diffpre insert">+                let cost = floor . fromIntegral $ aOrig ^. acMoveEnergyCost in</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-        -- All actors that have enough energy to move and are not skipping a turn</pre>
<pre class="diffpre delete">-        actorsThatCanMove = filter</pre>
<pre class="diffpre insert">+                if cost &gt; B.get (aOrig ^. acEnergy)</pre>
<pre class="diffpre insert">+                then</pre>
<pre class="diffpre insert">+                  -- Not enough energy to move, disallow. Set skipMove = True so this is not attempted again before</pre>
<pre class="diffpre insert">+                  -- the next actor move (i.e. avoid looping)</pre>
<pre class="diffpre insert">+                  wNext &amp; wdActors %~ Map.insert (aOrig ^. acId) (aOrig &amp; acSkipMove .~ True)</pre>
<pre class="diffpre insert">+                else</pre>
<pre class="diffpre insert">+                  actOnImpulse cost wNext actorIfMoved action</pre>
<pre class="diffpre insert">+      in</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      let actorsThatCanMove = filter</pre>
<pre class="diffpre context">                             (\a -&gt; B.get (a ^. acEnergy) &gt;= (w ^. wdMinMoveEnergy) &amp;&amp; not (a ^. acSkipMove))</pre>
<pre class="diffpre context">                             (Map.elems $ w ^. wdActors)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context">       in</pre>
<pre class="diffpre context">       -- Are the any actors that could still move?</pre>
<pre class="diffpre context">       if null actorsThatCanMove</pre>
<pre class="diffpre info">@@ -814,16 +808,95 @@</pre>
<pre class="diffpre context">       else</pre>
<pre class="diffpre context">         w</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre delete">-      </pre>
<pre class="diffpre delete">-</pre>
<pre class="diffpre context">     disableSkip w =</pre>
<pre class="diffpre context">       updateAllActors w (\_ a -&gt; a &amp; acSkipMove .~ False)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+actOnImpulse :: Int -&gt; World -&gt; Actor -&gt; Impulse -&gt; World</pre>
<pre class="diffpre insert">+actOnImpulse cost w actorIfMoved impulse =</pre>
<pre class="diffpre insert">+  let (dx, dy, nextStdGen) =</pre>
<pre class="diffpre insert">+        let initialStdGen = (actorIfMoved ^. acStdGen) in</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+        case impulse of</pre>
<pre class="diffpre insert">+          ImpMoveRandom -&gt;</pre>
<pre class="diffpre insert">+            let</pre>
<pre class="diffpre insert">+              (dx', s1) = Rnd.randomR (-1, 1) initialStdGen</pre>
<pre class="diffpre insert">+              (dy', s2) = Rnd.randomR (-1, 1) s1 </pre>
<pre class="diffpre insert">+            in</pre>
<pre class="diffpre insert">+            (dx', dy', s2)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+          ImpMoveTowards (Path ps) -&gt;</pre>
<pre class="diffpre insert">+            case ps of</pre>
<pre class="diffpre insert">+              (_:WorldPos (tx, ty):_) -&gt;</pre>
<pre class="diffpre insert">+                let (WorldPos (fx, fy)) = actorIfMoved ^. acWorldPos in</pre>
<pre class="diffpre insert">+                (tx - fx, ty - fy, initialStdGen)</pre>
<pre class="diffpre insert">+              _ -&gt; (0, 0, initialStdGen)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+  in</pre>
<pre class="diffpre insert">+  if dx /=0 || dy /= 0</pre>
<pre class="diffpre insert">+  then</pre>
<pre class="diffpre insert">+    let worldIfMoved = w &amp; wdActors %~ Map.insert (actorIfMoved ^. acId) actorIfMoved in</pre>
<pre class="diffpre insert">+     </pre>
<pre class="diffpre insert">+    case tryMoveActor worldIfMoved actorIfMoved (dx, dy) of</pre>
<pre class="diffpre insert">+      Nothing -&gt;</pre>
<pre class="diffpre insert">+        w &amp; wdActors %~ Map.adjust (\a' -&gt; a' &amp; acStdGen .~ nextStdGen) (actorIfMoved ^. acId)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      Just w' -&gt;</pre>
<pre class="diffpre insert">+        w' &amp; wdActors %~ Map.adjust (\a' -&gt; updateActorFov w' $ a' &amp; acEnergy %~ B.update (subtract cost)</pre>
<pre class="diffpre insert">+                                                                   &amp; acStdGen .~ nextStdGen</pre>
<pre class="diffpre insert">+                                    )</pre>
<pre class="diffpre insert">+                                    (actorIfMoved ^. acId)</pre>
<pre class="diffpre insert">+  else</pre>
<pre class="diffpre insert">+    w &amp; wdActors %~ Map.adjust (\a' -&gt; a' &amp; acStdGen .~ nextStdGen) (actorIfMoved ^. acId)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre context"> randomElement :: Rnd.StdGen -&gt; [a] -&gt; (Maybe a, Rnd.StdGen)</pre>
<pre class="diffpre context"> randomElement g as =</pre>
<pre class="diffpre context">   let (i, next) = Rnd.randomR (0, length as - 1) g in</pre>
<pre class="diffpre context">   (atMay as i, next)</pre>
<pre class="diffpre context"> </pre>
<pre class="diffpre insert">+  </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+findPathToAllInFov :: World -&gt; Actor -&gt; [PathTo]</pre>
<pre class="diffpre insert">+findPathToAllInFov w a =</pre>
<pre class="diffpre insert">+  case a ^. acFov of</pre>
<pre class="diffpre insert">+    Nothing -&gt; []</pre>
<pre class="diffpre insert">+    Just fov -&gt;</pre>
<pre class="diffpre insert">+      let wmap = addActorsToMap w in</pre>
<pre class="diffpre insert">+      concat (findPaths wmap &lt;$&gt; fov)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+  where</pre>
<pre class="diffpre insert">+    findPaths :: Map WorldPos Entity -&gt; (WorldPos, [WorldPos]) -&gt; [PathTo]</pre>
<pre class="diffpre insert">+    findPaths wmap (dest, points) =</pre>
<pre class="diffpre insert">+      snd $ foldl'</pre>
<pre class="diffpre insert">+              (\(trail, paths) atPos -&gt; (trail &lt;&gt; [atPos], paths &lt;&gt; findAt dest wmap (trail &lt;&gt; [atPos]) atPos))</pre>
<pre class="diffpre insert">+              ([], [])</pre>
<pre class="diffpre insert">+              points</pre>
<pre class="diffpre insert">+      </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+    findAt :: WorldPos -&gt; Map WorldPos Entity -&gt; [WorldPos] -&gt; WorldPos -&gt; [PathTo]</pre>
<pre class="diffpre insert">+    findAt dest wmap trail atPos =</pre>
<pre class="diffpre insert">+      let ps = if atPos == w ^. wdPlayer ^. plActor ^. acWorldPos</pre>
<pre class="diffpre insert">+               then [ PathToPlayer (Path trail) (w ^. wdPlayer) dest</pre>
<pre class="diffpre insert">+                    , PathToActor (Path trail) (w ^. wdPlayer ^. plActor) dest</pre>
<pre class="diffpre insert">+                    ]</pre>
<pre class="diffpre insert">+               else []</pre>
<pre class="diffpre insert">+      in</pre>
<pre class="diffpre insert">+      let es = case wmap ^.at atPos of</pre>
<pre class="diffpre insert">+                 Nothing -&gt; []</pre>
<pre class="diffpre insert">+                 Just e -&gt; if e ^. enType == E.Blank</pre>
<pre class="diffpre insert">+                              then []</pre>
<pre class="diffpre insert">+                              else [PathToEntity (Path trail) e dest]</pre>
<pre class="diffpre insert">+      in</pre>
<pre class="diffpre insert">+      ps &lt;&gt; es</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+  </pre>
<pre class="diffpre insert">+addActorsToMap :: World -&gt; Map WorldPos Entity</pre>
<pre class="diffpre insert">+addActorsToMap w =</pre>
<pre class="diffpre insert">+  foldr</pre>
<pre class="diffpre insert">+    (\a g -&gt; Map.insert (a ^. acWorldPos) (a ^. acEntity) g)</pre>
<pre class="diffpre insert">+    (w ^. wdMap)</pre>
<pre class="diffpre insert">+    (getAllActors w)</pre>
<pre class="diffpre insert">+</pre>
</div>
<h2 class=".diffh2">
src/UtilityBrain.hs
</h2>
<div class="file-diff">
<pre class="diffpre difffile">diff -w -B -a -d -u -b --new-file 12_energy/src/UtilityBrain.hs 13_utility/src/UtilityBrain.hs</pre>
<pre class="diffpre delete">--- 12_energy/src/UtilityBrain.hs</pre>
<pre class="diffpre insert">+++ 13_utility/src/UtilityBrain.hs</pre>
<pre class="diffpre info">@@ -0,0 +1,190 @@</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+{-# OPTIONS_GHC -fno-warn-type-defaults #-}</pre>
<pre class="diffpre insert">+{-# LANGUAGE NoImplicitPrelude #-}</pre>
<pre class="diffpre insert">+{-# LANGUAGE OverloadedStrings #-}</pre>
<pre class="diffpre insert">+{-# LANGUAGE ScopedTypeVariables #-}</pre>
<pre class="diffpre insert">+{-# LANGUAGE FlexibleContexts #-}</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+module UtilityBrain ( selectTopUtility</pre>
<pre class="diffpre insert">+                    , assessUtilities</pre>
<pre class="diffpre insert">+                    , utilityOfInfatuation</pre>
<pre class="diffpre insert">+                    , utilityOfWander</pre>
<pre class="diffpre insert">+                    , utilityOfWanderToExit</pre>
<pre class="diffpre insert">+                    , emptyDisposition</pre>
<pre class="diffpre insert">+                    ) where</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+import Protolude </pre>
<pre class="diffpre insert">+import qualified Data.List as Lst</pre>
<pre class="diffpre insert">+import qualified System.Random as Rnd</pre>
<pre class="diffpre insert">+import qualified Control.Arrow as Ar</pre>
<pre class="diffpre insert">+import           Control.Lens</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+import           GameCore</pre>
<pre class="diffpre insert">+import qualified EntityType as E</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+path :: PathTo -&gt; Path</pre>
<pre class="diffpre insert">+path (PathToEntity p _ _) = p</pre>
<pre class="diffpre insert">+path (PathToActor p _ _) = p</pre>
<pre class="diffpre insert">+path (PathToPlayer p _ _) = p</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+selectTopUtility :: [(Float, Actor, Impulse, Text, Maybe PathTo)]</pre>
<pre class="diffpre insert">+                 -&gt; Maybe (Float, Actor, Impulse, Text, Maybe PathTo)</pre>
<pre class="diffpre insert">+selectTopUtility rs = </pre>
<pre class="diffpre insert">+  case rs of</pre>
<pre class="diffpre insert">+      [] -&gt; Nothing</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      (u@(v0,a0,_,_,_):_) -&gt; do</pre>
<pre class="diffpre insert">+        -- Get the results with the top scores (fuzzy match)</pre>
<pre class="diffpre insert">+        let top = Lst.takeWhile (\(v2,_,_,_,_) -&gt; v2 &gt;= v0 - 0.001) rs </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+        -- Get a random index. Grab a StdGen from the first actor, and ignore the new stdgen, its not important here</pre>
<pre class="diffpre insert">+        let ((idx, _), rndB) = </pre>
<pre class="diffpre insert">+              let (rndA, rndB') = Rnd.split (a0 ^. acStdGen) in</pre>
<pre class="diffpre insert">+              (Rnd.randomR (0, length top - 1) rndA, rndB') </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+        case atMay top idx of</pre>
<pre class="diffpre insert">+          Just (s, a, i, n, p) -&gt; Just (s, a &amp; acStdGen .~ rndB, i, n, p)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+          Nothing -&gt; Just u</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+  </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+-- | See the docs on acUtilities</pre>
<pre class="diffpre insert">+-- | Mainly that the world is threaded through utilities and any updates are kept even if no/other utilities are selected</pre>
<pre class="diffpre insert">+-- | The actor in the results are speculative and only the actor for the selected utility gets used</pre>
<pre class="diffpre insert">+assessUtilities :: [PathTo] -&gt; World -&gt; Actor -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+assessUtilities paths world actor =</pre>
<pre class="diffpre insert">+  let</pre>
<pre class="diffpre insert">+    (rs, wNext) = foldl' assess ([], world) (actor ^. acUtilities)</pre>
<pre class="diffpre insert">+    ranked = rankUtility rs</pre>
<pre class="diffpre insert">+  in</pre>
<pre class="diffpre insert">+  (ranked, wNext)</pre>
<pre class="diffpre insert">+  </pre>
<pre class="diffpre insert">+  where</pre>
<pre class="diffpre insert">+    assess (hist, w) u =</pre>
<pre class="diffpre insert">+      let</pre>
<pre class="diffpre insert">+        a = fromMaybe actor $ w ^. wdActors ^.at (actor ^. acId) </pre>
<pre class="diffpre insert">+        (rs, wNext) = u w a paths</pre>
<pre class="diffpre insert">+      in</pre>
<pre class="diffpre insert">+      (hist &lt;&gt; rs, wNext)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+rankUtility :: [(Float, Actor, Impulse, Text, Maybe PathTo)] -&gt; [(Float, Actor, Impulse, Text, Maybe PathTo)]</pre>
<pre class="diffpre insert">+rankUtility us = </pre>
<pre class="diffpre insert">+  Lst.reverse $ Lst.sortOn (\(x, _, _, _, _) -&gt; x) us</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+clamp :: Float -&gt; Float</pre>
<pre class="diffpre insert">+clamp = clampTo 0.0 1.0</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+clampTo :: Float -&gt; Float -&gt; Float -&gt; Float</pre>
<pre class="diffpre insert">+clampTo vmin vmax = min vmax . max vmin</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+onlyEntitiesOfType :: [E.EntityType] -&gt; [PathTo] -&gt; [PathTo]</pre>
<pre class="diffpre insert">+onlyEntitiesOfType types =</pre>
<pre class="diffpre insert">+  filter go</pre>
<pre class="diffpre insert">+  where</pre>
<pre class="diffpre insert">+    go (PathToEntity _ e _) = e ^. enType `elem` types</pre>
<pre class="diffpre insert">+    go _ = False</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+emptyDisposition :: Disposition</pre>
<pre class="diffpre insert">+emptyDisposition = Disposition { _dsSmitten = 0</pre>
<pre class="diffpre insert">+                               , _dsWanderlust = 0</pre>
<pre class="diffpre insert">+                               , _dsWanderlustToExits = 0</pre>
<pre class="diffpre insert">+                               , _dsSmittenWith = []</pre>
<pre class="diffpre insert">+                               } </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+distanceToRange :: PathTo -&gt; Int -&gt; Maybe Float</pre>
<pre class="diffpre insert">+distanceToRange pt fov =</pre>
<pre class="diffpre insert">+  let (Path p) = path pt in</pre>
<pre class="diffpre insert">+  case (p, Lst.reverse p) of</pre>
<pre class="diffpre insert">+    ([], _) -&gt; Nothing</pre>
<pre class="diffpre insert">+    (_, []) -&gt; Nothing</pre>
<pre class="diffpre insert">+    (WorldPos (fx, fy) : _, WorldPos (tx, ty) : _) -&gt;</pre>
<pre class="diffpre insert">+      if fx == tx &amp;&amp; fy == ty</pre>
<pre class="diffpre insert">+      then</pre>
<pre class="diffpre insert">+        Nothing</pre>
<pre class="diffpre insert">+      else</pre>
<pre class="diffpre insert">+        -- Distance to point</pre>
<pre class="diffpre insert">+        let distance = sqrt . fromIntegral $ ((tx - fx) ^ 2) + ((ty - fy) ^ 2) in</pre>
<pre class="diffpre insert">+        -- Max distance for fov, i.e. cartesian distance to a corner of the fov</pre>
<pre class="diffpre insert">+        let maxDist = sqrt ((fromIntegral fov ** 2) * 2) in</pre>
<pre class="diffpre insert">+        Just $ distance / maxDist</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+utilityOfWander :: World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+utilityOfWander world actor _paths = </pre>
<pre class="diffpre insert">+  let rule = clamp $ 0.02 * (10 * clamp (actor ^. acDisposition ^. dsWanderlust)) in</pre>
<pre class="diffpre insert">+  ([(rule, actor, ImpMoveRandom, "wander", Nothing)], world)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+utilityOfWanderToExit :: World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+utilityOfWanderToExit world actor allPaths =</pre>
<pre class="diffpre insert">+  let</pre>
<pre class="diffpre insert">+    rule x = clamp $ 1 - (0.04 * x + (1.24 - clamp (actor ^. acDisposition ^. dsWanderlustToExits))) </pre>
<pre class="diffpre insert">+    clampedResults = moveTowardsUtil [E.Door] rule allPaths actor</pre>
<pre class="diffpre insert">+  in</pre>
<pre class="diffpre insert">+  ((\(p, score) -&gt; (score, actor, ImpMoveTowards (path p), "wander to exit", Just p)) &lt;$&gt; clampedResults, world)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+  </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+utilityOfInfatuation :: World -&gt; Actor -&gt; [PathTo] -&gt; ([(Float, Actor, Impulse, Text, Maybe PathTo)], World)</pre>
<pre class="diffpre insert">+utilityOfInfatuation world actor allPaths =</pre>
<pre class="diffpre insert">+  let</pre>
<pre class="diffpre insert">+    rule x = clamp $ -x ** 4 + clamp (actor ^. acDisposition ^. dsSmitten) </pre>
<pre class="diffpre insert">+    clampedResults = moveTowardsUtil (actor ^. acDisposition ^. dsSmittenWith) rule allPaths actor</pre>
<pre class="diffpre insert">+  in</pre>
<pre class="diffpre insert">+  ((\(p, score) -&gt; (score, actor, ImpMoveTowards (path p), "infatuation", Just p)) &lt;$&gt; clampedResults, world)</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+moveTowardsUtil :: [E.EntityType] -&gt; (Float -&gt; Float) -&gt; [PathTo] -&gt; Actor -&gt; [(PathTo, Float)]</pre>
<pre class="diffpre insert">+moveTowardsUtil es rule paths actor =</pre>
<pre class="diffpre insert">+  let</pre>
<pre class="diffpre insert">+    -- Find exits</pre>
<pre class="diffpre insert">+    goalPaths = onlyEntitiesOfType es paths</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+      -- Normalise distances</pre>
<pre class="diffpre insert">+    pathsNormalisedMay = (\p -&gt; (p, distanceToRange p (actor ^. acFovDistance))) &lt;$&gt; goalPaths </pre>
<pre class="diffpre insert">+    pathsNormalised = catNormalisedMay pathsNormalisedMay </pre>
<pre class="diffpre insert">+    -- Run utility calculation</pre>
<pre class="diffpre insert">+    results = Ar.second rule &lt;$&gt; pathsNormalised </pre>
<pre class="diffpre insert">+    clampedResults = Ar.second clamp &lt;$&gt; results</pre>
<pre class="diffpre insert">+  in</pre>
<pre class="diffpre insert">+    clampedResults</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+catNormalisedMay :: [(PathTo, Maybe float)] -&gt; [(PathTo, float)]</pre>
<pre class="diffpre insert">+catNormalisedMay ps =</pre>
<pre class="diffpre insert">+  catMaybes $ go &lt;$&gt; ps</pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+  where</pre>
<pre class="diffpre insert">+    go (_, Nothing) = Nothing</pre>
<pre class="diffpre insert">+    go (p, Just v) = Just (p, v) </pre>
<pre class="diffpre insert">+</pre>
<pre class="diffpre insert">+</pre>
</div>
</div>
<h1 id="chapters-1">Chapters</h1>
<p><a href="../2018-04-02-haskell-rogue-like.html">start</a> <a href="2018-04-02-haskell-rogue-like_12.html">prev</a> <a href="2018-04-02-haskell-rogue-like_14.html">next</a></p>


        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          
          ga('create', 'UA-78428674-1', 'auto');
          ga('send', 'pageview');
        </script>
    </body>
</html>
