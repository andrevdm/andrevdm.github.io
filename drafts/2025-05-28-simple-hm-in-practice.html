<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Andre's Blog</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
      <div id="bodyInner">
        <div id="header">
            <div id="logo">
                <a href="../">Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <!-- <a href="/about.html">About</a> -->
            </div>
        </div>

        <div id="content">
            <h1><a href="#top">Simple Hindley-Milner in Practice</a></h1>

            <div class="info">
    Posted on May 28, 2025
    
</div>

<div id="post_content" class="post-content">
  <p><a href="/drafts/2025-05-28-simple-hm-in-practice.pdf">üìÑ Download as PDF</a></p>
<div class="toc">
<ul>
<li>
<a href="#part-1---introduction" id="toc-part-1---introduction">Part
1 - Introduction</a>
<ul>
<li>
<a href="#structure-of-this-document" id="toc-structure-of-this-document">Structure of this Document</a>
</li>
<li>
<a href="#conventions" id="toc-conventions">Conventions</a>
</li>
<li>
<a href="#scope" id="toc-scope">Scope</a>
</li>
<li>
<a href="#why-lisp" id="toc-why-lisp">Why LISP?</a>
</li>
<li>
<a href="#quick-lisp-primer" id="toc-quick-lisp-primer">Quick Lisp
Primer</a>
</li>
</ul>
</li>
<li>
<a href="#part-2---type-systems" id="toc-part-2---type-systems">Part
2 - Type Systems</a>
<ul>
<li>
<a href="#hindley-milner-type-system" id="toc-hindley-milner-type-system">Hindley-Milner Type System</a>
</li>
<li>
<a href="#the-type-checker" id="toc-the-type-checker">The Type
Checker</a>
</li>
<li>
<a href="#unification" id="toc-unification">Unification</a>
<ul>
<li>
<a href="#longer-unification-example" id="toc-longer-unification-example">üß© Longer unification
Example</a>
</li>
</ul>
</li>
<li>
<a href="#generalisation" id="toc-generalisation">Generalisation</a>
<ul>
<li>
<a href="#instantiation" id="toc-instantiation">Instantiation</a>
</li>
<li>
<a href="#longer-generalisation-example" id="toc-longer-generalisation-example">üß© Longer Generalisation
Example</a>
</li>
<li>
<a href="#infinite-types" id="toc-infinite-types">Infinite
Types</a>
</li>
</ul>
</li>
<li>
<a href="#summary" id="toc-summary">Summary</a>
</li>
</ul>
</li>
<li>
<a href="#part-3---introduction-to-the-code" id="toc-part-3---introduction-to-the-code">Part 3 - Introduction to the
Code</a>
<ul>
<li>
<a href="#implementation-overview" id="toc-implementation-overview">Implementation Overview</a>
</li>
<li>
<a href="#compiler-high-level-flow" id="toc-compiler-high-level-flow">Compiler High Level Flow</a>
</li>
<li>
<a href="#code-conventions" id="toc-code-conventions">Code
Conventions</a>
</li>
<li>
<a href="#monad-transformers" id="toc-monad-transformers">Monad-Transformers</a>
</li>
</ul>
</li>
<li>
<a href="#part-4---code-walk-through" id="toc-part-4---code-walk-through">Part 4 - Code Walk-Through</a>
<ul>
<li>
<a href="#parser" id="toc-parser">Parser</a>
<ul>
<li>
<a href="#errors" id="toc-errors">Errors</a>
</li>
</ul>
</li>
<li>
<a href="#resolver" id="toc-resolver">Resolver</a>
</li>
<li>
<a href="#type-checker" id="toc-type-checker">Type Checker</a>
<ul>
<li>
<a href="#type-check-if-expression" id="toc-type-check-if-expression">Type Check: If Expression</a>
</li>
<li>
<a href="#type-check-do-expression" id="toc-type-check-do-expression">Type Check: Do Expression</a>
</li>
<li>
<a href="#type-check-lists" id="toc-type-check-lists">Type Check:
Lists</a>
<ul>
<li>
<a href="#non-empty-lists" id="toc-non-empty-lists">Non-empty
Lists</a>
</li>
<li>
<a href="#empty-lists" id="toc-empty-lists">Empty Lists</a>
</li>
</ul>
</li>
<li>
<a href="#type-checking-progress-so-far" id="toc-type-checking-progress-so-far">Type Checking: Progress So
Far</a>
</li>
<li>
<a href="#generating-fresh-type-variables" id="toc-generating-fresh-type-variables">Generating Fresh Type
Variables</a>
</li>
<li>
<a href="#occurs-check---preventing-infinite-types" id="toc-occurs-check---preventing-infinite-types">Occurs Check -
Preventing Infinite Types</a>
</li>
<li>
<a href="#the-substitution-map" id="toc-the-substitution-map">The
Substitution Map</a>
</li>
<li>
<a href="#binding-type-variables---updating-the-substitution-map" id="toc-binding-type-variables---updating-the-substitution-map">Binding
Type Variables - Updating the Substitution Map</a>
</li>
<li>
<a href="#finding-free-type-variables" id="toc-finding-free-type-variables">Finding Free Type
Variables</a>
</li>
<li>
<a href="#instantiating-polymorphic-types" id="toc-instantiating-polymorphic-types">Instantiating Polymorphic
Types</a>
</li>
<li>
<a href="#type-checking-another-progress-check" id="toc-type-checking-another-progress-check">Type Checking: Another
Progress Check</a>
</li>
<li>
<a href="#generalise" id="toc-generalise">Generalise</a>
</li>
<li>
<a href="#unification-1" id="toc-unification-1">Unification</a>
</li>
<li>
<a href="#type-check-define-expression" id="toc-type-check-define-expression">üß© Type Check: Define
Expression</a>
</li>
<li>
<a href="#type-check-function-call" id="toc-type-check-function-call">üß© Type Check: Function Call</a>
</li>
<li>
<a href="#type-check-let-expression" id="toc-type-check-let-expression">üß© Type Check: Let
Expression</a>
</li>
<li>
<a href="#type-check-lambda-expression" id="toc-type-check-lambda-expression">üß© Type Check: Lambda
Expression</a>
</li>
<li>
<a href="#type-check-atom-expression" id="toc-type-check-atom-expression">üß© Type Check: Atom
Expression</a>
</li>
<li>
<a href="#limitations-future-work" id="toc-limitations-future-work">Limitations &amp; Future Work</a>
<ul>
<li>
<a href="#quick-wins" id="toc-quick-wins">Quick Wins</a>
</li>
<li>
<a href="#advanced-features" id="toc-advanced-features">Advanced
Features</a>
</li>
</ul>
</li>
<li>
<a href="#type-checking-summary" id="toc-type-checking-summary">Type
Checking: Summary</a>
</li>
</ul>
</li>
<li>
<a href="#lowering" id="toc-lowering">Lowering</a>
</li>
<li>
<a href="#evaluating" id="toc-evaluating">Evaluating</a>
<ul>
<li>
<a href="#interaction-with-the-external-world" id="toc-interaction-with-the-external-world">Interaction with the
external world</a>
</li>
<li>
<a href="#primitive-functions" id="toc-primitive-functions">Primitive Functions</a>
</li>
<li>
<a href="#standard-library" id="toc-standard-library">Standard
Library</a>
</li>
</ul>
</li>
<li>
<a href="#repl" id="toc-repl">REPL</a>
<ul>
<li>
<a href="#startup" id="toc-startup">Startup</a>
</li>
<li>
<a href="#repl-features" id="toc-repl-features">REPL Features</a>
<ul>
<li>
<a href="#commands" id="toc-commands">Commands</a>
</li>
<li>
<a href="#multi-line-mode" id="toc-multi-line-mode">Multi-Line
Mode</a>
</li>
<li>
<a href="#known-types-with-ts" id="toc-known-types-with-ts">Known
Types with <code>:ts</code></a>
</li>
</ul>
</li>
<li>
<a href="#repl-example" id="toc-repl-example">REPL Example</a>
</li>
<li>
<a href="#types-at-runtime" id="toc-types-at-runtime">Types at
Runtime?</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#conclusion" id="toc-conclusion">Conclusion</a>
<ul>
<li>
<a href="#further-reading" id="toc-further-reading">Further
Reading</a>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="part-1---introduction">Part 1 - Introduction</h1>
<p>In this post, you‚Äôll learn how to build a lightweight Hindley‚ÄìMilner type checker in Haskell. No advanced theory is required.
We‚Äôll apply it to a tiny, LISP-inspired language so you can focus on how inference works.</p>
<p>Hindley-Milner inference may seem intimidating, but I believe that it is much more approachable than it first appears.
Each concept is quite understandable. It is just a matter of working through them and building up to the full picture.</p>
<p>Hopefully, you‚Äôll find this post useful if you want to implement a type system of your own, or if you wish to understand how Hindley-Milner works.</p>
<h2 id="structure-of-this-document">Structure of this Document</h2>
<p>This document is structured as follows:</p>
<ol type="1">
<li><a href="#part-1---introduction">Part 1: Introduction and overview.</a></li>
<li><a href="#part-2---type-systems">Part 2: Hindley-Milner type system introduction.</a></li>
<li><a href="#part-3---introduction-to-the-code">Part 3: Introduction to the code.</a></li>
<li><a href="#part-4---code-walk-through">Part 4: Code walk-through.</a></li>
<li><a href="#conclusion">Conclusion.</a></li>
</ol>
<p>The code is available on <a href="https://github.com/andrevdm/hmLispTypeSystem">GitHub</a>.</p>
<h2 id="conventions">Conventions</h2>
<ul>
<li>üìù is used to introduce a new term or concept.</li>
<li>üí° introduces a tip or reminder.</li>
<li>üß© starts a block that goes into more detail about a specific topic.</li>
</ul>
<h2 id="scope">Scope</h2>
<p>The explanation and code focus on a practical introduction to the Hindley-Milner type system.
This is not meant to be production grade, no consideration given to performance or optimisations for real-world languages.</p>
<p>This post is about implementing a Hindley-Milner type system in Haskell, not about LISP itself.
Many of the features that make LISP interesting are not implemented or discussed in this context. It is just the S-Expression syntax being used.</p>
<p>I believe that it‚Äôs often easier to start with a lightweight practical approach, and then decide whether you want to dive into the theory.
I hope that this post will give you enough of a practical understanding of Hindley-Milner type systems that you can then go on to learn more about the theory if you want to.</p>
<p>It should demonstrate that implementing the basics for a small DSL is entirely possible, and not as hard as it may seem at first glance.</p>
<h2 id="why-lisp">Why LISP?</h2>
<p>I‚Äôm using a LISP-like language because it is a small language. Using a small subset of LISP means that we can focus on the type system, rather than language itself.</p>
<p>To keep the language minimal, I‚Äôm not implementing many of the features of LISP. There are no macros, quoting etc.</p>
<p>Despite this simplicity it is still enough to demonstrate how the type system works. It could also be a starting point for a more complete language if you want to extend it.</p>
<p>If you are interested in seeing a fully-fledged statically typed LISP, take a look at <a href="https://docs.racket-lang.org/ts-guide/">Typed Racket</a>.</p>
<p>For the remainder of this post, I will refer to the language being implemented as ‚ÄúLISP‚Äù.</p>
<h2 id="quick-lisp-primer">Quick Lisp Primer</h2>
<p>LISP has a uniform, minimal syntax:</p>
<ul>
<li>Code and data are written as parenthesised lists.</li>
<li>Prefix notation is used: <code>(func arg1 arg2 ...)</code>.</li>
<li>Functions are first-class values.</li>
<li><code>(+ 10 12)</code> results in <code>22</code>.</li>
<li><code>(prn "Hello, World!")</code>
<ul>
<li>same as <code>print("Hello, World!")</code> in Python</li>
<li>or <code>putStrLn "Hello, World!"</code> in Haskell</li>
</ul></li>
</ul>
<p>There are many good resources to learn LISP, so I won‚Äôt go into more detail here.</p>
<div class="warning">
<p>‚ö†Ô∏è You do not need to learn LISP to understand this post. The basic concepts of LISP are simple and can be grasped quickly from the context of the code examples.</p>
</div>
<h1 id="part-2---type-systems">Part 2 - Type Systems</h1>
<p>If you are reading this, you are probably already familiar with types and why you might want them, so I won‚Äôt cover that here. Instead, we‚Äôll dive straight into how Hindley‚ÄìMilner inference works.</p>
<p>In short, for the LISP being implemented, we want to ensure that user code is well-typed.</p>
<ul>
<li><code>(+ 10 12)</code> is well-typed.</li>
<li><code>(+ 10 "Hello")</code> is not.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (<span class="op">+</span> <span class="dv">10</span> <span class="st">&quot;Hello&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Type Error: Unification <span class="kw">mismatch</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>expected: Int, but found: String.</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   <span class="dv">1</span>: (<span class="op">+</span> <span class="dv">10</span> <span class="st">&quot;Hello&quot;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      ^</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      |</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      +----------</span></code></pre></div>
<p>You may find that switching between the theory (<a href="#part-2---type-systems">Part 2</a>) and the code (<a href="#part-4---code-walk-through">Part 4</a>) helps you understand the concepts better.</p>
<h2 id="hindley-milner-type-system">Hindley-Milner Type System</h2>
<p>From Wikipedia:</p>
<blockquote>
<p>A classical type system for the lambda calculus with parametric polymorphism.
It deduces types automatically across entire modules, not just local expressions, making it the backbone of ML-style languages.
- <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Wikipedia</a></p>
</blockquote>
<h2 id="the-type-checker">The Type Checker</h2>
<p><img src="../images/hm_lisp_type_check.png" /></p>
<p>The type checker being discussed here implements the Hindley-Milner type inference algorithm.</p>
<p><strong>What Hindley-Milner Gives You:</strong></p>
<ul>
<li>Type inference ‚Äì no annotations needed (but supported).</li>
<li>Unification ‚Äì the workhorse that solves equality between types.</li>
<li>Let-generalisation ‚Äì automatic polymorphism from monomorphic type bindings.</li>
<li>Principal types ‚Äì you get the most general type, so your functions remain reusable.</li>
</ul>
<h2 id="unification">Unification</h2>
<div class="note">
<p>üìù <strong>Unification</strong> is the algorithm that, given two type expressions,</p>
<ol type="1">
<li>Determines whether they can be made equal</li>
<li>And if so, constructs the most general substitution for type variables that makes the expressions identical.</li>
</ol>
</div>
<p>For example, calling increment on an integer:</p>
<ul>
<li>Suppose <code>inc</code> is a function with type <code>Int -&gt; Int</code>.</li>
<li>When you write <code>(inc 1)</code>:
<ol type="1">
<li>The type checker sees that <code>inc</code> expects an argument of type <code>Int</code>.</li>
<li>It sees that <code>1</code> is of type <code>Int</code>.</li>
<li>It tries to <strong>unify</strong> the argument type of <code>inc</code> (<code>Int</code>) with the type of <code>1</code> (<code>Int</code>).</li>
<li>Since both are <code>Int</code>, the unification succeeds, and the expression type checks.</li>
</ol></li>
</ul>
<p>Calling increment on a string:</p>
<ul>
<li>If you try <code>(inc "hello")</code>
<ol type="1">
<li>The checker sees that <code>inc</code> expects <code>Int</code>.</li>
<li>It sees <code>"hello"</code> is a <code>String</code>.</li>
<li>Unification of <code>Int</code> with <code>String</code> fails.</li>
<li>A type error is reported.</li>
</ol></li>
</ul>
<p><img src="../images/hm_lisp_unificiation1.svg" /></p>
<div class="note">
<p>üìù A <strong>type variable</strong> is a placeholder that stands for any type. E.g. <code>a</code> or <code>U0</code>.</p>
<p>üìù A <strong>substitution map</strong> tracks which type variables should be replaced by other types or variables, enabling recursive resolution to the final, most specific type during type inference.</p>
</div>
<ul>
<li>The <em>substitution map</em> maps a type variable name (like <code>U0</code>, <code>U1</code>) to another type variable or concrete type.</li>
<li>This can be type variable to type e.g.¬†<code>U0 -&gt; Int</code>, or one type variable to another, e.g.¬†<code>U1 -&gt; U0</code>.</li>
</ul>
<p>During unification, the algorithm uses the substitution map to replace type variables with their mapped types.
(recursively resolving chains like <code>U1 -&gt; U0 -&gt; Int</code>).</p>
<ul>
<li>Lookup <code>U1</code> =&gt; <code>U0</code></li>
<li>Lookup <code>U0</code> =&gt; <code>Int</code></li>
<li>Result: <code>Int</code></li>
</ul>
<div class="warning">
<p>‚ö†Ô∏è The code will prevent infinite types by checking that a type variable never appears within the structure it‚Äôs being unified with.
See <a href="#infinite-types">Infinite Types</a> for more details.</p>
</div>
<h3 id="longer-unification-example">üß© Longer unification Example</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(concat3 () () (<span class="kw">list</span> <span class="dv">1</span>))</span></code></pre></div>
<ul>
<li>Assume <code>concat3</code> is <code>concat3 :: [a] -&gt; [a] -&gt; [a] -&gt; [a]</code>.</li>
<li>That is, it takes three lists of the same type and returns a concatenated list of that type.</li>
<li><code>(list 1)</code>: <code>list</code> creates a list, so this function creates a list containing the integer <code>1</code></li>
<li>In this LISP implementation, lists are homogeneous, meaning all elements must be of the same type.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(concat3</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>   ()        <span class="co">; arg1</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>   ()        <span class="co">; arg2</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">list</span> <span class="dv">1</span>)  <span class="co">; arg3</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Type checking:</p>
<ol type="1">
<li><dl>
<dt><strong>arg1</strong>: <code>() :: [U1]</code></dt>
<dd>
The first <code>()</code> is inferred as an empty list with element type <code>U1</code> i.e.¬†type <code>[U1]</code>, where <code>U1</code> is a fresh type variable.
</dd>
</dl></li>
<li><dl>
<dt><strong>arg2</strong>: <code>() :: [U2]</code></dt>
<dd>
The second <code>()</code> is also inferred as an empty list of type <code>[U2]</code>, where <code>U2</code> is a another fresh type variable.
</dd>
</dl></li>
<li><dl>
<dt><strong>arg3</strong>: <code>(list 1) :: [Int]</code></dt>
<dd>
arg3: The third argument <code>(list 1)</code> is type-checked and inferred as a list of <code>Int</code>, i.e.¬†<code>[Int]</code>.
</dd>
</dl></li>
</ol>
<div class="tip">
<p>üí° A <strong>fresh type variable</strong> is a new unique type variable that has not been used before in the current type environment.</p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(concat3</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>   ()        <span class="co">; :: [U1]</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>   ()        <span class="co">; :: [U2]</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">list</span> <span class="dv">1</span>)  <span class="co">; :: [Int]</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Unification:</p>
<ol type="1">
<li><dl>
<dt>Homogeneous list</dt>
<dd>
All the arguments must be of the same type, so we need to unify <code>U1</code>, <code>U2</code>, and <code>Int</code>.
</dd>
</dl></li>
<li><dl>
<dt>Unify <code>U1 ~ U2</code></dt>
<dd>
This gives us <code>U1 = U2</code> because the types match structurally (They are both fresh type variables and can unify with any type).
</dd>
</dl></li>
<li><dl>
<dt><code>U1 ~ Int</code></dt>
<dd>
Next unify <code>U1</code> with <code>Int</code>, yielding <code>U1 = Int</code>.
</dd>
<dd>
Because <code>U2</code> was already equated to <code>U1</code>, it too becomes <code>Int</code>.
</dd>
</dl></li>
<li><dl>
<dt>Unify with the function type</dt>
<dd>
<code>concat3</code> has type <code>[a] -&gt; [a] -&gt; [a] -&gt; [a]</code>.
</dd>
<dd>
Unify each argument‚Äôs inferred type (<code>[U1]</code>, <code>[U2]</code>, <code>[Int]</code>) with <code>[a]</code>, which after substitution becomes <code>[Int]</code> for all three.
</dd>
<dd>
In other words, solve <code>[a] ~ [U1], [a] ~ [U2], [a] ~ [Int]</code>
</dd>
<dd>
After applying our substitutions (<code>U1 = Int</code>, <code>U2 = Int</code>)
</dd>
<dd>
the signature specializes to <code>[Int] -&gt; [Int] -&gt; [Int] -&gt; [Int]</code>.
</dd>
<dd>
Everything matches
</dd>
</dl></li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(concat3     <span class="co">; :: [Int] -&gt; [Int] -&gt; [Int] -&gt; [Int]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>   ()        <span class="co">; :: [Int]</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>   ()        <span class="co">; :: [Int]</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">list</span> <span class="dv">1</span>)  <span class="co">; :: [Int]</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>)            <span class="co">; :: [Int]</span></span></code></pre></div>
<p>‚úÖ And so the unification and type checking succeeds, resulting in the final type of the expression being <code>[Int]</code>.</p>
<h2 id="generalisation">Generalisation</h2>
<div class="note">
<p>üìù <strong>Generalisation</strong> in Hindley-Milner, is the process of turning a monomorphic type into a polymorphic type (forall type) by quantifying its free type variables when binding a value with let.</p>
<p>üìù The <strong>principal type</strong> is sometimes informally called the final inferred type, but technically it refers to the most general type from which all others can be derived by substitution.</p>
</div>
<p>Generalisation is the key to Hindley-Milner‚Äôs polymorphism. The type system can determine when a type can be made polymorphic.</p>
<p>If you write a function like <code>(Œª (x) x)</code></p>
<ul>
<li>In the <strong>unification</strong> step, the type checker will infer this to have the type <code>U0 -&gt; U0</code>, where <code>U0</code> is a fresh type variable.</li>
<li><strong>Generalisation</strong> will then turn this into a polymorphic type <code>‚àÄ U0. U0 -&gt; U0</code>, meaning it can work with any type.</li>
<li>The <code>forall</code> quantifier <code>‚àÄ U0</code> indicates that <code>U0</code> can be any type, making the function polymorphic.</li>
</ul>
<p>Even though the example is trivial, this mechanism underlies powerful polymorphism in real-world languages like ML and Haskell.</p>
<p>In our checker, we generalise at let-bindings and top-level defines.</p>
<div class="tip">
<p>üí° Generalisation picks the type variables in the inferred type that are not already ‚Äúin scope‚Äù in the environment</p>
<p>Or in Haskell terms: <code>getFreeTypeVars inferedType `Set.difference` getFreeTypeVarsFromEnvironment</code></p>
</div>
<h3 id="instantiation">Instantiation</h3>
<div class="note">
<p>üìù <strong>Instantiation</strong> Replaces all quantified variables in a polymorphic type with fresh type variables.</p>
</div>
<ul>
<li>That is it replaces type variables in a <strong>polymorphic type</strong> (one with a <code>forall</code> quantifier) with fresh type variables.</li>
<li>For example <code>‚àÄ a b. a -&gt; b -&gt; String</code> would be instantiated to <code>U0 -&gt; U1 -&gt; String</code>, where <code>U0</code> and <code>U1</code> are fresh type variables.</li>
<li>This ensures that each use of a polymorphic value remains independent in type inference</li>
<li>We cannot assume that one type of variable is the same as another simply because they share a name in different contexts.</li>
</ul>
<p>Instantiation ensures that each type variable is unique so that there is no accidental type sharing.</p>
<div class="note">
<p>üìù We instantiate every polymorphic type at every variable use.
For example, when you refer to a top‚Äêlevel identity function or a let‚Äêbound polymorphic value.</p>
</div>
<h3 id="longer-generalisation-example">üß© Longer Generalisation Example</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((<span class="kw">identity</span> (Œª (z) z)))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ( (x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">identity</span> <span class="dv">10</span>))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>         (y</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">identity</span> <span class="st">&quot;Hello&quot;</span>))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    (prn y)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Without generalisation, a single monomorphic binding of identity would lock its type to the first use.
This would make the second call fail.</p>
<p>Here is a look at how generalisation solves this problem.</p>
<ul>
<li>We have a nested <code>let</code> expression.</li>
<li>The outer <code>let</code> binds an <code>identity</code> function.</li>
<li>The inner <code>let</code> binds two variables <code>x</code> and <code>y</code>, both using the <code>identity</code> function.</li>
</ul>
<p>Using what we know from the previous section, we can infer the types step by step.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((<span class="kw">identity</span> (Œª (z) z)))      <span class="co">; identity :: U0 -&gt; U0</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ( (x</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">identity</span> <span class="dv">10</span>))        <span class="co">; 10 :: Int,  identity :: Int -&gt; Int</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>         (y</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">identity</span> <span class="st">&quot;Hello&quot;</span>))   <span class="co">; &quot;Hello&quot; :: String, ...</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    (prn y)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<ul>
<li>‚ùå While unifying <code>x</code> the type checker sees that <code>identity</code> must be <code>Int -&gt; Int</code> because <code>10</code> is an <code>Int</code>.</li>
<li>‚ùå When checking <code>(identity "Hello")</code>, unification attempts <code>Int ~ String</code> and fails.</li>
</ul>
<p>That is not going to work. This is exactly what generalisation is for.</p>
<p>Instead:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((<span class="kw">identity</span> (Œª (z) z)))      <span class="co">; identity :: ‚àÄ U0. U0 -&gt; U0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ( (x</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">identity</span> <span class="dv">10</span>))        <span class="co">; 10 :: Int,  identity :: Int -&gt; Int</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>         (y</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">identity</span> <span class="st">&quot;Hello&quot;</span>))   <span class="co">; &quot;Hello&quot; :: String, identity :: String -&gt; String</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    (prn y)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<ul>
<li>‚úÖ The type checker generalises <code>identity</code> to <code>‚àÄ U0. U0 -&gt; U0</code>.</li>
<li>‚úÖ Now <code>identity</code> can be used with any type, so it can be applied to both <code>10</code> and <code>"Hello"</code> without issue.</li>
</ul>
<h3 id="infinite-types">Infinite Types</h3>
<div class="note">
<p>üìù <strong>Infinite types</strong> are types that are defined in terms of themselves, leading to recursive type definitions that cannot be resolved.</p>
</div>
<p>The Hindley‚ÄìMilner type checker detects infinite types, using the <strong>occurs</strong> check and rejects them.
Without an occurs check, you could write nonsensical types that make no sense (lead to infinite recursion).</p>
<p>For example:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((x (<span class="kw">list</span> x)))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  x)</span></code></pre></div>
<ol type="1">
<li>Infer: In <code>(list x)</code>, if <code>x :: U0</code>, then <code>list x :: [U0]</code>.</li>
<li>Unify: Attempt to solve <code>U0 = [U0]</code>.</li>
<li>Detect: Because <code>U0</code> occurs within <code>[U0]</code>, unification would recurse indefinitely.</li>
</ol>
<h2 id="summary">Summary</h2>
<p>So far you have seen what to expect from a Hindley-Milner type system, and you‚Äôve been introduced to</p>
<ul>
<li>Unification.</li>
<li>The substitution map.</li>
<li>Generalisation.</li>
<li>Instantiation.</li>
<li>Infinite types and the occurs check.</li>
</ul>
<h1 id="part-3---introduction-to-the-code">Part 3 - Introduction to the Code</h1>
<p>With an introduction to the theory handled, let‚Äôs look at <a href="https://github.com/andrevdm/hmLispTypeSystem">the code</a> to implement the type system in Haskell.</p>
<h2 id="implementation-overview">Implementation Overview</h2>
<p>As a reminder, here is what this LISP implementation handles:</p>
<ul>
<li>Data types: <code>Int</code>, <code>Bool</code>, <code>String</code>, <code>nil</code>, and lists of these types.</li>
<li>A small set of special forms: <code>lambda</code>, <code>let</code>, <code>define</code>, <code>if</code>, <code>function application</code>.</li>
<li>A small set of primitive functions like <code>+</code>, <code>-</code>, <code>*</code>, <code>and</code>, <code>or</code>, etc.</li>
<li>A tiny standard library.</li>
<li><code>let</code> for defining local variables.</li>
<li><code>define</code> for defining global variables and functions.</li>
</ul>
<h2 id="compiler-high-level-flow">Compiler High Level Flow</h2>
<p>The LISP implementation is quite shallow as discussed, but I‚Äôve also tried to keep it relatively broad.
It could have been only a parser, the type checker and a REPL.
This would miss some interesting parts of actually implementing a type system, so I‚Äôve implemented a few more real-world aspects of the pipeline.</p>
<p>Instead, it looks like this:</p>
<p><img src="../images/hm_lisp_compiler_flow.png" /></p>
<ol type="1">
<li><strong>Parsing</strong>: <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/LispParser.hs">LispParser.hs</a>
<ul>
<li>Converts source code into a simple Abstract Syntax Tree (AST).</li>
<li>No special form recognition. Just simple s-expressions</li>
</ul></li>
<li><strong>Resolver</strong>: <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/Resolver.hs">Resolver.hs</a>
<ul>
<li>Recognizes special forms</li>
<li>Create a more structured AST.</li>
</ul></li>
<li><strong>Type Checking</strong>: <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/TypeChecker.hs">TypeChecker.hs</a>
<ul>
<li>Implements the Hindley-Milner type inference algorithm.</li>
<li>Handles unification, generalisation, and instantiation.</li>
<li>Type checks the resolved AST.</li>
<li>Produces a typed AST with type annotations.</li>
</ul></li>
<li><strong>Lowering</strong>: <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/Eval/Lower.hs">Eval/Lower.hs</a>
<ul>
<li>Converts the typed AST into a lower-level representation.</li>
<li>In this implementation, its effectively just type erasure</li>
</ul></li>
<li><strong>Evaluation</strong>: <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/Eval/Evaluator.hs">Eval/Evaluator.hs</a>
<ul>
<li>Evaluates the lowered AST.</li>
<li>Implements a simple interpreter for the LISP language.</li>
</ul></li>
</ol>
<p>Finally, a REPL (<a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/Repl.hs">Repl.hs</a>) that ties everything together, allowing you to interactively enter LISP code and see the results.</p>
<p>In <a href="#part-4---code-walk-through">Part 4</a> I‚Äôll walk through each of these components in more detail, explaining how they work and fit together.</p>
<h2 id="code-conventions">Code Conventions</h2>
<ul>
<li>I‚Äôve tried to keep the Haskell relatively simple, but what counts as simple is very subjective.</li>
<li>I have a preference for qualified imports, so you‚Äôll see many <code>import xxx as qualified yyy</code> statements.</li>
<li>I am using a custom prelude (<code>Verset</code>) which I prefer because it also encourages qualified imports (not surprisingly, as I created it). Switching to <code>protolude</code> or even the standard prelude should be easy enough.</li>
<li>I‚Äôve used GHC 12.2 but it should work with 9.8 and later.</li>
<li>I‚Äôve tried to add a reasonable amount of code comments. Hopefully you‚Äôll be able to follow the code without too much trouble.</li>
<li><code>pass</code> = <code>pure ()</code></li>
<li>Record fields are made strict using <code>!</code>.</li>
<li>I‚Äôm using overloaded-record-dot syntax, so you can use <code>x.field</code> instead of <code>field x</code> for record field access.</li>
<li>Rather than using multiple <code>'</code> (prime) suffixes, I‚Äôll use <code>1</code>, <code>2</code>, etc. So <code>name1 =&gt; name2 =&gt; name3</code> instead of <code>name =&gt; name' =&gt; name''</code>.</li>
</ul>
<h2 id="monad-transformers">Monad-Transformers</h2>
<div class="warning">
<p>‚ö†Ô∏èIf you are not familiar with monad transformers, do not let this discourage or distract you.</p>
</div>
<p>The type-checker runs in <code>StateT TcState (Except TypeError)</code>.
Think of it as mutable state and early exit in a pure setting. Everything inside is just <code>modify'</code> for state and <code>throwE</code> for errors.
You can safely ignore the plumbing and focus on the core logic.</p>
<p>You could remove the monad transformer entirely, e.g.
- Run entirely in IO, use a TVar for state and throwing actual exceptions for errors.
- Then the type signature would look something like <code>IO (TypeEnv, TypedLispVal)</code>.</p>
<h1 id="part-4---code-walk-through">Part 4 - Code Walk-Through</h1>
<h2 id="parser">Parser</h2>
<p><img src="../images/hm_lisp_parser.png" /></p>
<p>The code for the parser is in <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/LispParser.hs">LispParser.hs</a>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ParsedLispVal</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">PlNil</span> <span class="op">!</span><span class="dt">Pos</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PlAtom</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Text</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PlInt</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Int</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PlString</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Text</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PlBool</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Bool</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PlList</span> <span class="op">!</span><span class="dt">Pos</span> [<span class="dt">ParsedLispVal</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p><img src="../images/hm_lisp_parse1.png" /></p>
<p>The parser is intentionally minimal. It only generates low-level s-expressions.
No form recognition is done here.</p>
<p>For example, the following LISP code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> <span class="dv">#t</span> <span class="dv">1</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Would be parsed into the following AST (position elided):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">PlList</span> (<span class="dt">Pos</span> <span class="op">...</span>) [</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PlAtom</span> (<span class="dt">Pos</span> <span class="op">...</span>) <span class="st">&quot;if&quot;</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PlBool</span> (<span class="dt">Pos</span> <span class="op">...</span>) <span class="dt">True</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PlInt</span> (<span class="dt">Pos</span> <span class="op">...</span>) <span class="dv">1</span>,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PlInt</span> (<span class="dt">Pos</span> <span class="op">...</span>) <span class="dv">2</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>At this stage, there is no difference between special forms, lists, definitions, or function applications.
That is all handled in the resolver.</p>
<p>There are tradeoffs here. A simple parser is easy to implement and understand. You might keep the parser simple like this even in a much more complete LISP implementation.</p>
<p>The simpler parser AST may be the homoiconic AST that you‚Äôd want the user to see and manipulate (e.g.¬†for macros). But you might alternatively opt to recognise more forms in the parser itself.</p>
<h3 id="errors">Errors</h3>
<p>Even a basic language can benefit from readable error messages.
By tagging each <code>ParsedLispVal</code> with a <code>Pos</code> we can track the exact line and column that the node was parsed from.</p>
<p><code>getSourcePos</code> from <a href="https://hackage.haskell.org/package/megaparsec">megaparsec</a> makes this easy.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atPos ::</span> <span class="dt">LispParser</span> <span class="dt">Pos</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>atPos <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> M.getSourcePos</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Pos</span> (M.unPos <span class="op">$</span> M.sourceLine p) (M.unPos <span class="op">$</span> M.sourceColumn p)</span></code></pre></div>
<p>This allows us to report errors nicely since we know the line and column of the node:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a> Type Error: Unbound variable `z`</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>:   (<span class="kw">let</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>:     ((x <span class="dv">1</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>:      (y z))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>               ^</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>               |</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>               +----------</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>:      <span class="dv">#t</span>)</span></code></pre></div>
<p>The various error types (for the parser, resolver, type checker and evaluator) all implement the <code>LispError</code> type class.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">LispError</span> a <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  showLispError ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> <span class="dt">Pos</span>, <span class="dt">Text</span>, <span class="dt">Text</span>, <span class="dt">Text</span>) <span class="co">-- (position, type, name, error message)</span></span></code></pre></div>
<p>This allows us to format errors in a consistent way, regardless of the exact error type.</p>
<p>The formatting of errors is done in <code>Printer/PrintError.hs</code> using the <a href="https://hackage.haskell.org/package/prettyprinter">prettyprinter</a>
and <a href="https://hackage.haskell.org/package/prettyprinter-ansi-terminal">prettyprinter-ansi-terminal</a> libraries.</p>
<h2 id="resolver">Resolver</h2>
<p><img src="../images/hm_lisp_resolver.png" /></p>
<p>The parser produces raw lists, but we want a structured AST to work with. The resolver walks each <code>ParsedLispVal</code> and generates structured <code>ResolvedLispVal</code> nodes.</p>
<p>The code for the resolver is in <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/Resolver.hs">Resolver.hs</a>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ResolvedLispVal</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">RlAtom</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Text</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlBool</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Bool</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlDefine</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">Text</span> <span class="op">!</span><span class="dt">ResolvedLispVal</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlDo</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span>[<span class="dt">ResolvedLispVal</span>]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlFuncCall</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">ResolvedLispVal</span> <span class="op">!</span>[<span class="dt">ResolvedLispVal</span>]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlIf</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">ResolvedLispVal</span> <span class="op">!</span><span class="dt">ResolvedLispVal</span> <span class="op">!</span><span class="dt">ResolvedLispVal</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlInt</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Int</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlLambda</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span>[(<span class="dt">Pos</span>, <span class="dt">Text</span>)] <span class="op">!</span>[<span class="dt">ResolvedLispVal</span>]</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlLet</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LetStyle</span> <span class="op">!</span>[((<span class="dt">Pos</span>, <span class="dt">Text</span>), (<span class="dt">Pos</span>, <span class="dt">ResolvedLispVal</span>))] <span class="op">!</span>[<span class="dt">ResolvedLispVal</span>]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlList</span> <span class="op">!</span><span class="dt">Pos</span> [<span class="dt">ResolvedLispVal</span>]</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlNil</span> <span class="op">!</span><span class="dt">Pos</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RlString</span> <span class="op">!</span><span class="dt">Pos</span> <span class="dt">Text</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p><img src="../images/hm_lisp_resolve1.png" /></p>
<ul>
<li>The resolver is responsible for creating a more structured AST from the parsed s-expressions.</li>
<li>It recognizes special forms, and converts the parsed s-expressions into AST nodes that are easier to work with in the type checker and evaluator.</li>
<li>E.g. it is much simpler to work with a <code>RlIf</code> than just a <code>PlList</code> with an <code>if</code> atom and three arguments that you would then need to check each time.</li>
</ul>
<p>The main resolver function is <code>resolveImpl</code>, and it looks like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">resolveImpl ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">P.ParsedLispVal</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ResolverError</span> <span class="dt">ResolvedLispVal</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>resolveImpl isTopLevel lv <span class="ot">=</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lv <span class="kw">of</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- No change</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">P.PlNil</span> p <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlNil</span> p</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">P.PlInt</span> p v <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlInt</span> p v</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">P.PlString</span> p v <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlString</span> p v</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">P.PlBool</span> p v <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlBool</span> p v</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">P.PlAtom</span> p v <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlAtom</span> p v</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">P.PlList</span> p allVs <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> allVs <span class="kw">of</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        (h<span class="op">:</span> vs) <span class="ot">-&gt;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> h <span class="kw">of</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">P.PlAtom</span> _ <span class="st">&quot;let&quot;</span> <span class="ot">-&gt;</span> resolveLet p <span class="dt">L.LetParallel</span> vs</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">P.PlAtom</span> _ <span class="st">&quot;lambda&quot;</span> <span class="ot">-&gt;</span> resolveLambda p vs</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">P.PlAtom</span> _ <span class="st">&quot;Œª&quot;</span> <span class="ot">-&gt;</span> resolveLambda p vs</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">P.PlAtom</span> _ <span class="st">&quot;if&quot;</span> <span class="ot">-&gt;</span> resolveIf p vs</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">P.PlAtom</span> _ <span class="st">&quot;define&quot;</span> <span class="ot">-&gt;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>              <span class="kw">if</span> isTopLevel</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> resolveDefine p vs</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> <span class="dt">Left</span> <span class="op">.</span> <span class="dt">ReResolverError</span> (<span class="dt">Just</span> p) <span class="op">$</span> <span class="st">&quot;define can only be used at top level&quot;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- (list 1 2 3) =&gt; (1 2 3)</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">P.PlAtom</span> _ <span class="st">&quot;list&quot;</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>              vs' <span class="ot">&lt;-</span> <span class="fu">traverse</span> (resolveImpl <span class="dt">False</span>) vs</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlList</span> p vs'</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>            <span class="dt">P.PlAtom</span> _ <span class="st">&quot;do&quot;</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>              vs' <span class="ot">&lt;-</span> <span class="fu">traverse</span> (resolveImpl <span class="dt">False</span>) vs</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlDo</span> p vs'</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- Everything else is a function call</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>              f <span class="ot">&lt;-</span> resolveImpl <span class="dt">False</span> h</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>              args <span class="ot">&lt;-</span> <span class="fu">traverse</span> (resolveImpl <span class="dt">False</span>) vs</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlFuncCall</span> p f args</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Empty list is empty list not nil</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Right</span> <span class="op">$</span> <span class="dt">RlList</span> p []</span></code></pre></div>
<p>A few things to note here:</p>
<ul>
<li>It recognizes the <code>let</code>, <code>lambda</code>, <code>if</code>, <code>define</code>, and <code>do</code>, special forms as well as function application.</li>
<li>The resolver is recursive, it walks the parsed AST and resolves each node recursively.</li>
<li>We need to track whether we are at the top-level or not, because <code>define</code> can only be used at the top-level.</li>
<li>Lambda can be written as <code>lambda</code> or <code>Œª</code>.</li>
<li>There is no type-checking here.</li>
<li>Unlike many (most?) LISP implementations we don‚Äôt substitute <code>nil</code> for empty lists or vice versa.</li>
</ul>
<p>Let‚Äôs look at <code>resolveDefine</code> to see how that works.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">resolveDefine ::</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> [<span class="dt">P.ParsedLispVal</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ResolverError</span> <span class="dt">ResolvedLispVal</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>resolveDefine pos vs' <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> err <span class="ot">=</span> <span class="st">&quot;expected define in form (define name expr)\n&quot;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> vs' <span class="kw">of</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>     [name1, val1] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        name2 <span class="ot">&lt;-</span> as' asAtom <span class="st">&quot;atom&quot;</span> name1 <span class="op">$</span> <span class="dt">Just</span> (err <span class="op">&lt;&gt;</span> <span class="st">&quot;expected atom for name of define&quot;</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        val2 <span class="ot">&lt;-</span> resolveImpl <span class="dt">False</span> val1</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> <span class="op">$</span> <span class="dt">RlDefine</span> pos name2 val2</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>     _ <span class="ot">-&gt;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>       <span class="dt">Left</span> <span class="op">.</span> <span class="dt">ReResolverError</span> (<span class="dt">Just</span> pos) <span class="op">$</span> err <span class="op">&lt;&gt;</span> <span class="st">&quot;Invalid number of arguments for define&quot;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="ot">asAtom ::</span> <span class="dt">P.ParsedLispVal</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>asAtom (<span class="dt">P.PlAtom</span> _ a) <span class="ot">=</span> <span class="dt">Just</span> a</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>asAtom _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="ot">as' ::</span> (<span class="dt">P.ParsedLispVal</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">P.ParsedLispVal</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ResolverError</span> a</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>as' f n v e' <span class="ot">=</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> f v <span class="kw">of</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> v' <span class="ot">-&gt;</span> <span class="dt">Right</span> v'</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> e <span class="ot">=</span> <span class="fu">maybe</span> <span class="st">&quot;&quot;</span> (<span class="st">&quot;\n&quot;</span> <span class="op">&lt;&gt;</span>) e' <span class="kw">in</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Left</span> <span class="op">$</span> <span class="dt">ReResolverError</span> (<span class="dt">Just</span> <span class="op">$</span> P.getPos v) <span class="op">$</span> <span class="st">&quot;Expected &quot;</span> <span class="op">&lt;&gt;</span> n <span class="op">&lt;&gt;</span> <span class="st">&quot;, but got &quot;</span> <span class="op">&lt;&gt;</span> P.nameOf v <span class="op">&lt;&gt;</span> e</span></code></pre></div>
<p>The resolve functions are all fairly similar. They need to check the s-expression and see if it matches the expected form.</p>
<ul>
<li>The various <code>asXXX</code> functions are used to match the expected type of the node.</li>
<li>The <code>as'</code> function wraps an <code>asXXX</code> call, and converts a mismatch (<code>Nothing</code>) into an error (<code>ResolverError</code>).</li>
<li>The <code>asXXX</code> functions return an <code>Either</code> type. Using <code>as'</code> means that an error will short-circuit the resolution and return an error immediately.</li>
<li><code>P.nameOf</code> is the <code>nameOf</code> function imported from the <code>LispParser</code> module. It gets a human-readable name for the node.</li>
<li><code>let</code> only supports parallel bindings, so it does not support sequential or recursive bindings.</li>
</ul>
<p>With every <code>ParsedLispVal</code> now a <code>ResolvedLispVal</code> complete with structure and positions, we‚Äôre ready to feed these into our type checker.</p>
<h2 id="type-checker">Type Checker</h2>
<p><img src="../images/hm_lisp_type_check.png" /></p>
<p>The type checker traverses the <code>ResolvedLispVal</code> tree, threading an environment and substitution state through unification, generalisation, and instantiation to produce a fully typed AST.</p>
<p>The code for the type checker is in <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/TypeChecker.hs">TypeChecker.hs</a>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypedLispVal</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TvAtom</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LispType</span> <span class="op">!</span><span class="dt">Text</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvBool</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvDefine</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.PolyType</span> <span class="op">!</span><span class="dt">Text</span> <span class="op">!</span><span class="dt">TypedLispVal</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvDo</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LispType</span> <span class="op">!</span>[<span class="dt">TypedLispVal</span>]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvFuncCall</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LispType</span> <span class="op">!</span><span class="dt">TypedLispVal</span> <span class="op">!</span>[<span class="dt">TypedLispVal</span>]  <span class="co">-- ^ TvFuncCall pos returnType functionVal argVals</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvIf</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LispType</span> <span class="op">!</span><span class="dt">TypedLispVal</span> <span class="op">!</span><span class="dt">TypedLispVal</span> <span class="op">!</span><span class="dt">TypedLispVal</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvInt</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvLambda</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LispType</span> <span class="op">!</span>[(<span class="dt">Pos</span>, <span class="dt">Text</span>)] <span class="op">!</span>[<span class="dt">TypedLispVal</span>]</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvLet</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LispType</span> <span class="op">!</span><span class="dt">L.LetStyle</span> <span class="op">!</span>[(<span class="dt">Pos</span>, <span class="dt">Text</span>, <span class="dt">TypedLispVal</span>)] <span class="op">!</span>[<span class="dt">TypedLispVal</span>]</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvList</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">L.LispType</span> <span class="op">!</span>[<span class="dt">TypedLispVal</span>]</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvNil</span> <span class="op">!</span><span class="dt">Pos</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TvString</span> <span class="op">!</span><span class="dt">Pos</span> <span class="op">!</span><span class="dt">Text</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TcState</span> <span class="ot">=</span> <span class="dt">TcState</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tsTypeVarCounter ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsSubst ::</span> <span class="op">!</span>(<span class="dt">Map</span> <span class="dt">Text</span> <span class="dt">L.LispType</span>)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<ul>
<li><code>TypedLispVal</code> is the type of the AST after type checking. It is very similar to <code>ResolvedLispVal</code>, just with type information added.</li>
<li><dl>
<dt>Primitive types like <code>Int</code>, <code>Bool</code>, <code>String</code>, and <code>nil</code> are not annotated with their type, since this is obvious from their constructor.</dt>
<dd>
<code>TvInt {}</code> is <code>TyInt</code> etc.
</dd>
</dl></li>
</ul>
<p>The main type checking function is <code>typeCheckVal'</code> in <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/TypeChecker.hs">TypeChecker.hs</a>, which looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>typeCheckVal'</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">TypeEnv</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">R.ResolvedLispVal</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">Except</span> <span class="dt">TypeError</span>) (<span class="dt">TypeEnv</span>, <span class="dt">TypedLispVal</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>typeCheckVal' env1 rv <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
<p>It takes an initial type environment and a <code>ResolvedLispVal</code>, and returns a new type environment and a <code>TypedLispVal</code> on success.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypeEnv</span> <span class="ot">=</span> <span class="dt">TypeEnv</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> teTypes ::</span> <span class="op">!</span>(<span class="dt">Map.Map</span> <span class="dt">Text</span> <span class="dt">L.PolyType</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> teParent ::</span> <span class="op">!</span>(<span class="dt">Maybe</span> <span class="dt">TypeEnv</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Here is the top of <code>typeCheckVal'</code></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>typeCheckVal'</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">TypeEnv</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">R.ResolvedLispVal</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">Except</span> <span class="dt">TypeError</span>) (<span class="dt">TypeEnv</span>, <span class="dt">TypedLispVal</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>typeCheckVal' env1 rv <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Type check</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  (envFinal, topT1) <span class="ot">&lt;-</span> go</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  topFinal <span class="ot">&lt;-</span> applyValSubstitutions topT1</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (envFinal, topFinal)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    go <span class="ot">=</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> rv <span class="kw">of</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Simple cases, no extra type checking needed</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlNil</span> p <span class="ot">-&gt;</span> <span class="fu">pure</span> (env1, <span class="dt">TvNil</span> p)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlInt</span> p v <span class="ot">-&gt;</span> <span class="fu">pure</span> (env1, <span class="dt">TvInt</span> p v)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlString</span> p v <span class="ot">-&gt;</span> <span class="fu">pure</span> (env1, <span class="dt">TvString</span> p v)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlBool</span> p v <span class="ot">-&gt;</span> <span class="fu">pure</span> (env1, <span class="dt">TvBool</span> p v)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Type check the more complex cases</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlAtom</span> p v <span class="ot">-&gt;</span> typeCheckAtom p v</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlDefine</span> p name val <span class="ot">-&gt;</span> typeCheckDefine p name val</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlDo</span> p vs <span class="ot">-&gt;</span> typeCheckDo p vs</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlFuncCall</span> p f as <span class="ot">-&gt;</span> typeCheckFuncCall p f as</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlIf</span> p cond then' else' <span class="ot">-&gt;</span> typeCheckIf p cond then' else'</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlLambda</span> p bindings body <span class="ot">-&gt;</span> typeCheckLambda p bindings body</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlLet</span> p style bindings body <span class="ot">-&gt;</span> typeCheckLet p style bindings body</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">R.RlList</span> p vs <span class="ot">-&gt;</span> typeCheckList p vs</span></code></pre></div>
<ul>
<li>The functions returns a <code>TypedLispVal</code> i.e.¬†the result of type checking the <code>ResolvedLispVal</code>.</li>
<li>It also returns the <code>TypeEnv</code>, which is the type environment after type checking. E.g. it is updated by a <code>(defined ...)</code> form</li>
<li>For the simple cases like <code>TvInt</code> it simply returns the corresponding <code>TypedLispVal</code></li>
</ul>
<p>Now, let us look at how those typeCheckXXX calls are implemented.</p>
<h3 id="type-check-if-expression">Type Check: If Expression</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (if cond then else)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    typeCheckIf pos cond1 then1 else1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Type check the `condition`, `then`, and `else` expressions.</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>      (env2, cond2) <span class="ot">&lt;-</span> typeCheckVal' env1 cond1</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>      (env3, then2) <span class="ot">&lt;-</span> typeCheckVal' env2 then1</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>      (env4, else2) <span class="ot">&lt;-</span> typeCheckVal' env3 else1</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Check that the condition is a boolean.</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>      unify (L.getPos cond2, getValType cond2) (pos, <span class="dt">L.TyBool</span>)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Unify the types of the then and else branches.</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- I.e. the then and else branches must have the same result type.</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>      unify (L.getPos then2, getValType then2) (L.getPos else2, getValType else2)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Get the final type of the body of the if expression.</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> finalType <span class="ot">=</span> getValType then2</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> (env4, <span class="dt">TvIf</span> pos finalType cond2 then2 else2)</span></code></pre></div>
<p>Looking at that superficially, it is not that complicated.</p>
<ul>
<li>Type check the <code>condition</code>, <code>then</code>, and <code>else</code> expressions.</li>
<li>Check (<strong>unify</strong>) that the condition is a boolean.</li>
<li>Check (<strong>unify</strong>) that the types of the <code>then</code> and <code>else</code> branches are the same. I.e. that the final expression in each has the same type.</li>
<li>Get that final type and make it the type of the <code>TvIf</code> expression.</li>
</ul>
<p>The <code>unify</code> function will be discussed in more detail below.</p>
<p>For now:</p>
<div class="tip">
<p>üí° <strong>Unification</strong> is the algorithm that, given two type expressions,</p>
<ol type="1">
<li>Determines whether they can be made equal</li>
<li>And if so, constructs the most general substitution for type variables that makes the expressions identical.</li>
</ol>
</div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>unify</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">Pos</span>, <span class="dt">L.LispType</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="dt">Pos</span>, <span class="dt">L.LispType</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">ExceptT</span> <span class="dt">TypeError</span> <span class="dt">Identity</span>) ()</span></code></pre></div>
<p>So for the <code>if</code> expression that was roughly</p>
<ol type="1">
<li>Type-check all the child expressions.</li>
<li>Unify child expressions to ensure the meet expectations</li>
<li>Get the final type of the expression.</li>
<li>Construct the <code>TvIf</code>.</li>
</ol>
<h3 id="type-check-do-expression">Type Check: Do Expression</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (do ...)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    typeCheckDo pos vs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Type check all expressions in the do block.</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>      (env2, vs2) <span class="ot">&lt;-</span> foldTypeCheckVals env1 vs</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- The type of the block is the type of the last expression or nil if empty.</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> lastType <span class="ot">=</span> <span class="kw">case</span> lastMay vs2 <span class="kw">of</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">L.TyNil</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> x <span class="ot">-&gt;</span> getValType x</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> (env2, <span class="dt">TvDo</span> pos lastType vs2)</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>TvDo pos lastType vs2</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  ^   ^      ^     ^</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  |   |      |     <span class="op">+</span><span class="co">------- typed children</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  |   |      <span class="op">+</span><span class="co">------------- result type of the block</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  |   <span class="op">+</span><span class="co">-------------------- source position</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span><span class="co">------------------------ ‚Äúdo‚Äù node</span></span></code></pre></div>
<p>This is very similar to the <code>if</code> expression.</p>
<ol type="1">
<li>Type check child expressions.</li>
<li>Get the type of the body (last expression).</li>
<li>Construct the <code>TvDo</code>.</li>
</ol>
<h3 id="type-check-lists">Type Check: Lists</h3>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (list v...)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Type check a list of values.</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- In this implementation, lists are always homogeneous (all elements must have the same type).</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    typeCheckList pos vs <span class="ot">=</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> vs <span class="kw">of</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- An empty list can have any element type. Create a fresh type variable for the element type.</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Note that nil and the empty list `()` are not synonymous in this system (in most lisps they are).</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>          u <span class="ot">&lt;-</span> nextTypeVar</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> (env1, <span class="dt">TvList</span> pos (<span class="dt">L.TyList</span> <span class="op">$</span> <span class="dt">L.TyVar</span> u) [])</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Lists at this point are just vectors of values, never function calls.</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- The only requirement is that all elements have the same type.</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        (h<span class="op">:</span>t) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Type check the head element to get its type.</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>          (env2, headVal) <span class="ot">&lt;-</span> typeCheckVal' env1 h</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Type check the tail elements to get their types.</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>          (env3, tailVals) <span class="ot">&lt;-</span> foldTypeCheckVals env2 t</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- Type and position of the first element.</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>              headType <span class="ot">=</span> (L.getPos headVal, getValType headVal)</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- Type and position the tail elements.</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>              tailTypes <span class="ot">=</span> tailVals <span class="op">&lt;&amp;&gt;</span> \v <span class="ot">-&gt;</span> (L.getPos v, getValType v)</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Unify the type of each tail element with the head element's type,</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- to ensure all elements in the list have the same type.</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>          forM_ tailTypes <span class="op">$</span> \tt <span class="ot">-&gt;</span> unify headType tt</span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- If no type mismatch is found, the list is homogeneous.</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> (env3, <span class="dt">TvList</span> pos (<span class="dt">L.TyList</span> <span class="op">$</span> <span class="fu">snd</span> headType) (headVal <span class="op">:</span> tailVals))</span></code></pre></div>
<p>A bit more happening there, but still nothing too complicated.</p>
<ul>
<li>Infer before unify.</li>
<li>Unify takes a <code>Pos</code> and a <code>L.LispType</code>, so it can report errors with the position of any type mismatch.</li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>TvList pos                      <span class="co">-- the list node</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>       (TyList $ snd headType)  <span class="co">-- type of the homogeneous list</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>       (headVal : tailVals)     <span class="co">-- the typed list elements</span></span></code></pre></div>
<div class="tip">
<p>üí° Remember that lists are homogeneous in this implementation.</p>
</div>
<h4 id="non-empty-lists">Non-empty Lists</h4>
<p>For non-empty lists, the code looks similar to the <code>if</code> expression‚Äôs code.</p>
<ol type="1">
<li>Infer the head‚Äôs type by checking the first element.</li>
<li>Infer each tail element‚Äôs type with <code>foldTypeCheckVals</code>.</li>
<li>Unify each tail‚Äôs type with the head‚Äôs to enforce homogeneity.</li>
<li>Construct a <code>TvList pos (TyList headType) [headVal ‚Ä¶]</code> node.</li>
</ol>
<h4 id="empty-lists">Empty Lists</h4>
<p>This does mean that when the type checker first sees an empty list it can‚Äôt know what the final concrete type will be.
So we say that the empty list can be of any type, i.e.¬†in Haskell we say it has the type <code>[a]</code>.
<code>a</code> will be unified later when the list is used.</p>
<p>As noted in the code, the empty list is not the same as <code>nil</code> in this implementation.</p>
<h3 id="type-checking-progress-so-far">Type Checking: Progress So Far</h3>
<p>In the examples above, you will have seen at a high level how some of the LISP forms are type-checked.
You many want to go back and forth between the code and the theory in <a href="#part-2---type-systems">Part 2</a> to get a better feel for what its trying to achieve.</p>
<p>Next we‚Äôll look at some important helper functions before moving on to the core type-checking code.</p>
<h3 id="generating-fresh-type-variables">Generating Fresh Type Variables</h3>
<div class="tip">
<p>üí° A <strong>fresh type variable</strong> is a new unique type variable that has not been used before in the current type environment.</p>
</div>
<p>From the <a href="#unification">unification section</a> above, we saw that the type checker needs to be able to generate fresh type variables.
Let look at the implementation of that in the type checker.</p>
<p>The type checker carries its state in <code>TcState</code></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TcState</span> <span class="ot">=</span> <span class="dt">TcState</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tsTypeVarCounter ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsSubst ::</span> <span class="op">!</span>(<span class="dt">Map</span> <span class="dt">Text</span> <span class="dt">L.LispType</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<ul>
<li><code>tsTypeVarCounter</code> is used to generate fresh type variables.</li>
<li><code>tsSubst</code> is the substitution map.</li>
</ul>
<p>Generating a fresh type variable is done in the <code>nextTypeVar</code> function, which looks like this:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeVarPrefix ::</span> <span class="dt">Text</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>typeVarPrefix <span class="ot">=</span> <span class="st">&quot;U&quot;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">nextTypeVar ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> m <span class="dt">Text</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>nextTypeVar <span class="ot">=</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  state <span class="op">$</span> \st <span class="ot">-&gt;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c' <span class="ot">=</span> tsTypeVarCounter st <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        name <span class="ot">=</span> typeVarPrefix <span class="op">&lt;&gt;</span> <span class="fu">show</span> c'</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        st' <span class="ot">=</span> st { tsTypeVarCounter <span class="ot">=</span> c' }</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> (name, st')</span></code></pre></div>
<p>It generates a fresh type variable by incrementing the counter and returning a new type variable name.
Since there is only one <code>TcState</code> for the entire type-checking process, this ensures that all generated type variables are unique.</p>
<p>I‚Äôm using <code>U</code> as the prefix for type variables. This is entirely arbitrary as the name will always be unique thanks to substitution.</p>
<h3 id="occurs-check---preventing-infinite-types">Occurs Check - Preventing Infinite Types</h3>
<div class="tip">
<p>üí° <strong>Infinite types</strong> are types that are defined in terms of themselves, leading to recursive type definitions that cannot be resolved.</p>
</div>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Check if a type variable occurs in a type</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is used to prevent infinite types</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- For example, if you this haskell type is infinite: a = [a]</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">occurs ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>occurs name lt <span class="ot">=</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lt <span class="kw">of</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyNil</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyInt</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyString</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyBool</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyVar</span> v <span class="ot">-&gt;</span> v <span class="op">==</span> name</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyList</span> vs <span class="ot">-&gt;</span> occurs name vs</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyFunc</span> fnArgsType1 fnRetType1 <span class="ot">-&gt;</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">any</span> (occurs name) (fnArgsType1 <span class="op">&lt;&gt;</span> [fnRetType1])</span></code></pre></div>
<ul>
<li>Recursively checks if a type variable already occurs in a type.</li>
<li>From above, we saw that bindVar calls occur before binding. Then throwing an infinite‚Äêtype error if it returns True.</li>
</ul>
<h3 id="the-substitution-map">The Substitution Map</h3>
<div class="tip">
<p>üí° A <strong>substitution map</strong> tracks which type variables should be replaced by other types or variables, enabling recursive resolution to the final, most specific type during type inference.</p>
</div>
<p>After the <a href="#unification">unification section</a> process binds e.g.¬†<code>U1 = Int</code> and <code>U2 = U1</code>, we need to walk every type and replace <code>U2 -&gt; U1 -&gt; Int</code>.
The substitution map is where we store the information to track which type variables have been unified with which types.</p>
<p>The substitution map is stored in the <code>tsSubst</code> of <code>TcState</code>.</p>
<p>The <code>applySubstitutions</code> function and variants are used to apply the substitutions to types and values.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applySubstitutions ::</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">Except</span> <span class="dt">TypeError</span>) <span class="dt">L.LispType</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>applySubstitutions lt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lt <span class="kw">of</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyNil</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyInt</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyString</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyBool</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyList</span> lt1 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>      lt2 <span class="ot">&lt;-</span> applySubstitutions lt1</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">L.TyList</span> lt2</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyFunc</span> targs tret <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>      targs2 <span class="ot">&lt;-</span> <span class="fu">traverse</span> applySubstitutions targs</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>      tret2 <span class="ot">&lt;-</span> applySubstitutions tret</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">L.TyFunc</span> targs2 tret2</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.TyVar</span> v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>      st <span class="ot">&lt;-</span> get</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> Map.lookup v st<span class="op">.</span>tsSubst <span class="kw">of</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> lt2 <span class="ot">-&gt;</span> applySubstitutions lt2</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt</span></code></pre></div>
<ul>
<li><code>Nil</code>, <code>Int</code>, <code>String</code>, and <code>Bool</code> have no substitutions, so they are returned as is.</li>
<li>For lists, functions and other complex types, it recursively applies substitutions to their components and child components.</li>
<li><code>TyVar</code> is the interesting case
<ul>
<li>Look up the type variable in the substitution map.</li>
<li>If it exists:
<ul>
<li>apply substitutions to the found type. I.e. recursively apply substitutions to the type.</li>
<li>This is how we resolved <code>U2 ~ U1 ~ Int</code> above.</li>
</ul></li>
<li>If it does not exist in the substitution map, it is returned as is.
<ul>
<li>Remember that in the recursive case, this means that all available substitutions have been applied to the type variable.</li>
</ul></li>
</ul></li>
</ul>
<p>You can look at the <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/TypeChecker.hs">code</a> to see</p>
<ul>
<li><code>applyPolyTypeSubstitutions</code>: calls <code>applySubstitutions</code> on child components of <code>PolyType</code></li>
<li><code>applyValSubstitutions</code>: calls <code>applySubstitutions</code> on child components of a <code>TypedLispVal</code></li>
</ul>
<h3 id="binding-type-variables---updating-the-substitution-map">Binding Type Variables - Updating the Substitution Map</h3>
<div class="tip">
<p>üí° <strong>Binding a type variable</strong> means associating a type variable with a specific type, allowing the type checker to resolve that variable to the bound type during type inference.</p>
<p>Unification is both a lookup and a binding operation.</p>
</div>
<p>You‚Äôll see <code>bindVar</code> invoked in the <code>unify</code> function‚Äôs <code>TyVar</code> cases.
This is where two types unify a variable to a concrete type (or another variable).</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Bind a variable to a type</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is done during type unification as part of the type inference process.</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bindVar ::</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">Except</span> <span class="dt">TypeError</span>) ()</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>bindVar pos name lt</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- If trying to bind a type variable to itself, do nothing.</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">--  E.g. `U1 = U1`</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> getTVarName lt <span class="op">==</span> <span class="dt">Just</span> name <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Prevent infinite types. See `occurs`</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> occurs name lt <span class="ot">=</span> lift <span class="op">.</span> throwE <span class="op">$</span> <span class="dt">TcInfiniteType</span> pos name lt</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Record the substitution</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- i.e. record that `name` is now bound to `lt`</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> modify' <span class="op">$</span> \st <span class="ot">-&gt;</span> st { tsSubst <span class="ot">=</span> Map.insert name lt st<span class="op">.</span>tsSubst }</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    getTVarName ::</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    getTVarName (<span class="dt">L.TyVar</span> v) <span class="ot">=</span> <span class="dt">Just</span> v</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    getTVarName _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<ul>
<li><code>bindVar</code> is used to bind a type variable to a type.</li>
<li>Check if being a variable to itself.</li>
<li>Check for infinite types using <code>occurs</code> (see above).</li>
<li>Otherwise, it updates the substitution map in <code>TcState</code> using <code>StateT</code>‚Äôs <code>modify'</code> to record that the type variable is now bound to the type.</li>
</ul>
<h3 id="finding-free-type-variables">Finding Free Type Variables</h3>
<p>To generalise a type we quantify variables that are not already in scope.
Getting free type variables in a type and in the environment is the first step.</p>
<p>In the unification process above, it was said:</p>
<blockquote>
<p>Generalisation picks the type variables in the inferred type that are not already ‚Äúin scope‚Äù in the environment</p>
</blockquote>
<p>In the code this is done by <code>freeTypeVars</code> and variants.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A free type variable in a type is a type variable that is not bound by a forall in that type,</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- nor already assigned a meaning in the current environment.</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ot">freeTypeVars ::</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">Text</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>freeTypeVars (<span class="dt">L.TyVar</span> v) <span class="ot">=</span> Set.singleton v</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>freeTypeVars (<span class="dt">L.TyList</span> t) <span class="ot">=</span> freeTypeVars t</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>freeTypeVars (<span class="dt">L.TyFunc</span> args ret) <span class="ot">=</span> Set.unions <span class="op">$</span> freeTypeVars ret <span class="op">:</span> (freeTypeVars <span class="op">&lt;$&gt;</span> args)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>freeTypeVars <span class="dt">L.TyNil</span> <span class="ot">=</span> Set.empty</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>freeTypeVars <span class="dt">L.TyInt</span> <span class="ot">=</span> Set.empty</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>freeTypeVars <span class="dt">L.TyString</span> <span class="ot">=</span> Set.empty</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>freeTypeVars <span class="dt">L.TyBool</span> <span class="ot">=</span> Set.empty</span></code></pre></div>
<ul>
<li>This uses <code>Set</code> from the <code>containers</code> package to track free type variables.</li>
<li>Unsurprisingly, sets make set logic easy.</li>
<li>Here we use <code>union :: Set a -&gt; Set a -&gt; Set a</code> to combine two sets</li>
<li>And <code>unions :: [Set a] -&gt; Set a</code> to combine multiple sets.</li>
</ul>
<p>Let‚Äôs look at the <code>TyFunc</code> case</p>
<p><code>freeTypeVars (L.TyFunc args ret) = Set.unions (freeTypeVars ret : (freeTypeVars &lt;$&gt; args))</code></p>
<ul>
<li><code>freeTypeVars ret</code> - finds the free variables in the return type.</li>
<li><code>freeTypeVars &lt;$&gt; args</code> - create a list of the free variables from each argument type.</li>
<li><code>freeTypeVars ret</code> : ‚Ä¶ - prepends the return type‚Äôs free variables to the argument types‚Äô free variables, making a list of sets.</li>
<li><code>Set.unions ...</code> - combines all those sets into one set, containing all free variables from the whole function type.</li>
</ul>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | For PtMono, the free variables are just those of the underlying monotype.</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- For PtForall vs t, the free variables are those in t excluding the ones quantified in vs.</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="ot">freeTypeVarsInPoly ::</span> <span class="dt">L.PolyType</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">Text</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>freeTypeVarsInPoly (<span class="dt">L.PtMono</span> t) <span class="ot">=</span> freeTypeVars t</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>freeTypeVarsInPoly (<span class="dt">L.PtForall</span> vs t) <span class="ot">=</span> freeTypeVars t <span class="ot">`Set.difference`</span> Set.fromList vs</span></code></pre></div>
<p>The <code>PtForall</code> case is interesting, as it excludes the type variables that are quantified in the <code>vs</code> list.</p>
<ul>
<li>In other words, it finds the free type variables in a polymorphic type, excluding those that are bound by the <code>forall</code> quantifier.</li>
</ul>
<p>Finally <code>freeTypeVarsEnv</code> is used to find free type variables in the environment.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | traverses the environment hierarchy and accumulates free type variables</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">freeTypeVarsEnv ::</span> <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">Text</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>freeTypeVarsEnv env <span class="ot">=</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    freeParents <span class="ot">=</span> fromMaybe <span class="fu">mempty</span> (freeTypeVarsEnv <span class="op">&lt;$&gt;</span> env<span class="op">.</span>teParent)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    freeInThis <span class="ot">=</span> freeTypeVarsInPoly <span class="op">&lt;$&gt;</span> (Map.elems env<span class="op">.</span>teTypes)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  Set.unions (freeParents <span class="op">:</span> freeInThis)</span></code></pre></div>
<p>To get the free type variables for the whole environment, you:</p>
<ul>
<li>Collect all free type variables in the parent environment (if there is one).
<ul>
<li>This is done recursively.</li>
<li>So it will traverse the entire environment hierarchy upwards.</li>
<li>Note that the fmap here (<code>&lt;$&gt;</code>) is mapping over the <code>Maybe</code> type, so it gets a <code>Maybe (Set Text)</code> and the <code>fromMaybe</code> handles the <code>Nothing</code> case.</li>
</ul></li>
<li>Collect all free type variables in the current environment.
<ul>
<li>Map <code>freeTypeVarsInPoly</code> over each of the values in the environment‚Äôs type map.</li>
</ul></li>
<li>Take the union of these sets to get all the free type variables in scope.</li>
</ul>
<p>Note that although <code>Set.unions</code> and recursive environment traversals are fine for small programs, larger codebases might require caching or a more incremental approach.</p>
<h3 id="instantiating-polymorphic-types">Instantiating Polymorphic Types</h3>
<div class="tip">
<p>üí° <strong>Instantiating a polymorphic type</strong> means replacing each quantified variable in a polymorphic type with a fresh type variable.</p>
</div>
<p>For example</p>
<ul>
<li><code>‚àÄ a b. a -&gt; b -&gt; a</code> becomes <code>U0 -&gt; U1 -&gt; U0</code></li>
<li>Where <code>U0</code> and <code>U1</code> are fresh type variables.</li>
</ul>
<p>This must be done recursively so that all nested polymorphic types are instantiated.</p>
<p>It must also be done recursively for monomorphic types. If we supported more complex types, you could have a monomorphic type that contains polymorphic.
(<em>E.g. in Haskell a monomorphic record with a polymorphic field type</em>).</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">instantiate ::</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">L.PolyType</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">Except</span> <span class="dt">TypeError</span>) <span class="dt">L.LispType</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>instantiate _pos pt1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> pt1 <span class="kw">of</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.PtMono</span> lt1 <span class="ot">-&gt;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>      instantiate' Map.empty lt1</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">L.PtForall</span> vars1 lt1 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>      isubsts1 <span class="ot">&lt;-</span> for vars1 <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        c <span class="ot">&lt;-</span> nextTypeVar</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> (v, c)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> isubsts2 <span class="ot">=</span> Map.fromList isubsts1</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>      instantiate' isubsts2 lt1</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    instantiate' ::</span> <span class="dt">Map</span> <span class="dt">Text</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">Except</span> <span class="dt">TypeError</span>) <span class="dt">L.LispType</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>    instantiate' isubst lt1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> lt1 <span class="kw">of</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">L.TyNil</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt1</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">L.TyInt</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt1</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">L.TyString</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt1</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">L.TyBool</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> lt1</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">L.TyList</span> lt2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>          lt3 <span class="ot">&lt;-</span> instantiate' isubst lt2</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> <span class="op">$</span> <span class="dt">L.TyList</span> lt3</span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">L.TyVar</span> v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> Map.lookup v isubst <span class="kw">of</span></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> v2 <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">L.TyVar</span> v2</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- No substitution found, so return the original type variable</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>              <span class="fu">pure</span> <span class="op">$</span> <span class="dt">L.TyVar</span> v</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">L.TyFunc</span> targs tret <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>          targs2 <span class="ot">&lt;-</span> <span class="fu">traverse</span> (instantiate' isubst) targs</span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>          tret2 <span class="ot">&lt;-</span> instantiate' isubst tret</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> <span class="op">$</span> <span class="dt">L.TyFunc</span> targs2 tret2</span></code></pre></div>
<h3 id="type-checking-another-progress-check">Type Checking: Another Progress Check</h3>
<p>You have now seen all the building blocks required for us to move on to <code>generalisation</code> and <code>unify</code>.
With all the pieces in place, they should be reasonably understandable.</p>
<h3 id="generalise">Generalise</h3>
<div class="tip">
<p>üí° <strong>Generalisation</strong> in Hindley-Milner, is the process of turning a monomorphic into a polymorphic type.</p>
</div>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generalise ::</span> <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">L.PolyType</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>generalise env t <span class="ot">=</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- 1. Collect all free type variables appearing in the environment.</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>      envVars <span class="ot">=</span> freeTypeVarsEnv env</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- 2. Collect all free type variables in the type being generalised.</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>      typeVars <span class="ot">=</span> freeTypeVars t</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- 3. Find variables that appear in the type, but not in the environment.</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- These are the variables that can be generalised (quantified over).</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>      toGen <span class="ot">=</span> Set.toList (typeVars <span class="ot">`Set.difference`</span> envVars)</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 4. If there are no variables to generalise, return a monomorphic type.</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="fu">null</span> toGen</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dt">L.PtMono</span> t</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">L.PtForall</span> toGen t</span></code></pre></div>
<ul>
<li>The comments in the code explain the steps pretty well.</li>
</ul>
<p>Paraphrasing from above</p>
<ul>
<li>Generalisation picks the type variables in the inferred type that are not already ‚Äúin scope‚Äù in the environment</li>
<li>(free in type) - (free in type environment)</li>
</ul>
<h3 id="unification-1">Unification</h3>
<div class="tip">
<p>üí° <strong>Unification</strong> is the algorithm that, given two type expressions,</p>
<ol type="1">
<li>Determines whether they can be made equal</li>
<li>And if so, constructs the most general substitution for type variables that makes the expressions identical.</li>
</ol>
</div>
<p>Finally, we get to the unification function, which is the core of the type inference algorithm.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>unify</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">Pos</span>, <span class="dt">L.LispType</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="dt">Pos</span>, <span class="dt">L.LispType</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">ExceptT</span> <span class="dt">TypeError</span> <span class="dt">Identity</span>) ()</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>unify (lhsPos, lhs1) (rhsPos, rhs1) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 1) Substitute</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  lhs2 <span class="ot">&lt;-</span> applySubstitutions lhs1</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  rhs2 <span class="ot">&lt;-</span> applySubstitutions rhs1</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  unify' lhs2 rhs2</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    unify' ::</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">L.LispType</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">TcState</span> (<span class="dt">Except</span> <span class="dt">TypeError</span>) ()</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- 2) Equal?</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    unify' l r <span class="op">|</span> l <span class="op">==</span> r <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- 3) Type variable?</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    unify' (<span class="dt">L.TyVar</span> name) r <span class="ot">=</span> bindVar lhsPos name r</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    unify' l (<span class="dt">L.TyVar</span> name) <span class="ot">=</span> bindVar rhsPos name l</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- 4) Lists?</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    unify' (<span class="dt">L.TyList</span> a1) (<span class="dt">L.TyList</span> b1) <span class="ot">=</span> unify' a1 b1</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- 5) Functions?</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    unify' (<span class="dt">L.TyFunc</span> fnArgsType1 fnRetType1) (<span class="dt">L.TyFunc</span> fnArgsType2 fnRetType2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>      unless (<span class="fu">length</span> fnArgsType1 <span class="op">==</span> <span class="fu">length</span> fnArgsType2) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>        lift <span class="op">.</span> throwE <span class="op">$</span> <span class="dt">TcArityError</span> (<span class="dt">Just</span> <span class="op">$</span> lhsPos) (<span class="fu">length</span> fnArgsType1) (<span class="fu">length</span> fnArgsType2)</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- unify the argument types</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>      zipWithM_ (\a1 a2 <span class="ot">-&gt;</span> unify (lhsPos, a1) (rhsPos, a2)) fnArgsType1 fnArgsType2</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- unify the return types</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>      unify (lhsPos, fnRetType1) (rhsPos, fnRetType2)</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- 6) Mismatch</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    unify' l r <span class="ot">=</span> lift <span class="op">.</span> throwE <span class="op">$</span> <span class="dt">TcTypeMismatch</span> <span class="st">&quot;Unification mismatch&quot;</span> lhsPos (<span class="dt">L.PtMono</span> l) (<span class="dt">Just</span> rhsPos) (<span class="dt">L.PtMono</span> r)</span></code></pre></div>
<p>Main steps</p>
<ol type="1">
<li>Apply all substitutions to both types. (see <code>applySubstitutions</code>)</li>
<li>If they are equal, do nothing</li>
<li>If one is a type variable, bind it to the other type (unless this creates an infinite type)</li>
<li>If both are lists, unify their elements</li>
<li>If both are functions, unify their argument types and return types</li>
<li>Otherwise, throw a type mismatch error</li>
</ol>
<p>With all the leg work done, the unification algorithm is concise and straightforward.</p>
<p>We can now look at a couple of the more complex cases from <code>typeCheckVal'</code> to see how they use unification and generalisation.</p>
<h3 id="type-check-define-expression">üß© Type Check: Define Expression</h3>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (define name val)</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>typeCheckDefine pos name val1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Type check the value being defined.</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  (_env2, val2) <span class="ot">&lt;-</span> typeCheckVal' env1 val1</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Apply substitutions before generalising. This gets the final (possibly concrete) type of the value.</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- This step resolves all type variables to their current bindings.</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  tFinal <span class="ot">&lt;-</span> applySubstitutions (getValType val2)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Generalise the type of the value to create a polymorphic type if possible.</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- See `generalise` for details.</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pt <span class="ot">=</span> generalise env1 tFinal</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Update the *current* environment with the new binding.</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Note: this does not create a new env layer, it is an in-place update.</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> env3 <span class="ot">=</span> env1 { teTypes <span class="ot">=</span> Map.insert name pt env1<span class="op">.</span>teTypes }</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (env3, <span class="dt">TvDefine</span> pos pt name val2)</span></code></pre></div>
<ul>
<li>The resolver already restricted <code>define</code>s to the top-level. No need to check again.</li>
<li>Type-check the value being defined.</li>
<li>Substitute</li>
<li>Generalise. We generalise for <code>define</code> and for <code>let</code> bindings.</li>
<li>In-place environment update with the new binding.</li>
</ul>
<h3 id="type-check-function-call">üß© Type Check: Function Call</h3>
<p>To type an application like <code>(+ 1 2)</code>, we infer the function‚Äôs type, infer each argument‚Äôs type, and then unify against a fresh type-var return type.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (func args...)</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Type check a function call (application).</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Note that this is for when a function is called, not when it is defined.</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>typeCheckFuncCall pos funcVal' args' <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Type check the function being called and all argument expressions.</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  (_, funcVal) <span class="ot">&lt;-</span> typeCheckVal' env1 funcVal'</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  (_, argVals) <span class="ot">&lt;-</span> foldTypeCheckVals env1 args'</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Collect the types of all the arguments.</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> argTypes <span class="ot">=</span> getValType <span class="op">&lt;$&gt;</span> argVals</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Create a fresh type variable for the return type.</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>  retType <span class="ot">&lt;-</span> <span class="dt">L.TyVar</span> <span class="op">&lt;$&gt;</span> nextTypeVar</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Unify the type of the function value with a function type: (argTypes -&gt; retType).</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- This means the value being called must be a function taking the argument types and returning the return type.</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- I.e. the value being called is a function whose type unifies with a function type constructed from the argument</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- types and a fresh return type variable.</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>  unify (L.getPos funcVal, getValType funcVal) (pos, <span class="dt">L.TyFunc</span> argTypes retType)</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- After unification, apply substitutions to get the final (possibly concrete) return type.</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>  retTypeSubst <span class="ot">&lt;-</span> applySubstitutions retType</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (env1, <span class="dt">TvFuncCall</span> pos retTypeSubst funcVal argVals)</span></code></pre></div>
<ul>
<li>This is for function application, not function definition. E.g. <code>(+ 1 2)</code>.</li>
<li>There are no explicit types, so the return type always starts as a fresh type variable.</li>
<li><code>unify</code> is called to ensure that the thing being called is a function with the expected argument types and return type.</li>
<li>Don‚Äôt forget to apply substitutions to the return type after unification.</li>
</ul>
<h3 id="type-check-let-expression">üß© Type Check: Let Expression</h3>
<p>A <code>let</code> introduces local bindings whose definitions may themselves be polymorphic.
To support polymorphism, we must type‚Äêcheck each binding, generalise its monotype,
and put all new ones into a fresh environment before checking the body.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (let ( (n1 v1) (n2 v2)...) body...)</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>typeCheckLet pos style bindings1 body1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  (bindings2', env2') <span class="ot">&lt;-</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> style <span class="kw">of</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Parallel let bindings:</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">--  * All bindings are evaluated in the same outer environment.</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">--  * No binding can refer to any other binding in the same let.</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">--  * Only the body sees all new bindings.</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">--</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Sequential let bindings, where a binding may refer to a previous binding,</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- are not supported, but should be easy to add.</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">L.LetParallel</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Type check each binding in the let form.</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>        ls <span class="ot">&lt;-</span> <span class="fu">traverse</span> typeCheckLetBinding bindings1</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> bindings2 <span class="ot">=</span> ls <span class="op">&lt;&amp;&gt;</span> \(_, p, name, val) <span class="ot">-&gt;</span> (p, name, val)</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- Generalise the types of the bindings to allow polymorphism.</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>            bindings3 <span class="ot">=</span> bindings2 <span class="op">&lt;&amp;&gt;</span> \(_, name, val) <span class="ot">-&gt;</span> (name, generalise env1 <span class="op">$</span> getValType val)</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- Create a new environment layer for the let body, containing the new bindings as local variables.</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>            env2 <span class="ot">=</span> <span class="dt">TypeEnv</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>               { teParent <span class="ot">=</span> <span class="dt">Just</span> env1</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>               , teTypes <span class="ot">=</span> Map.fromList bindings3</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>               }</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> (bindings2, env2)</span></code></pre></div>
<ul>
<li>In LISP, there are several styles of <code>let</code> bindings.
<ul>
<li><strong>parallel</strong>: all bindings are evaluated in the same outer environment.</li>
<li><strong>sequential</strong>: bindings are evaluated one after the other, and can refer to previous bindings.</li>
<li><strong>recursive</strong>: bindings are evaluated in the same environment but can refer to each other.</li>
</ul></li>
<li>This implementation only supports <strong>parallel</strong> <code>let</code> bindings, but it should be easy to add the others.</li>
<li>Generalise and create a new environment layer for the body of the <code>let</code> expression.</li>
</ul>
<h3 id="type-check-lambda-expression">üß© Type Check: Lambda Expression</h3>
<p>To type-check <code>(Œª (x y) ...)</code>, we assign each parameter a fresh type variable, extend the environment with those bindings, type‚Äêcheck the body, and then assemble a function type from the parameter and return types.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (Œª (param1 param2 ...) body..)</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>typeCheckLambda pos params1 body1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Create new (fresh) monomorphic type variables for each of the parameters.</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  params2 <span class="ot">&lt;-</span> for params1 <span class="op">$</span> \(p, name) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    u <span class="ot">&lt;-</span> nextTypeVar</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> (p, name, <span class="dt">L.PtMono</span> <span class="op">$</span> <span class="dt">L.TyVar</span> u)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Create a new environment layer for this function.</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- containing the parameter bindings as local variables.</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> env2 <span class="ot">=</span> <span class="dt">TypeEnv</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        { teParent <span class="ot">=</span> <span class="dt">Just</span> env1</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>        , teTypes <span class="ot">=</span> Map.fromList <span class="op">$</span> params2 <span class="op">&lt;&amp;&gt;</span> \(_, name, pt) <span class="ot">-&gt;</span> (name, pt)</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Type check the lambda body in the new environment.</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>  (_tenv2, body2) <span class="ot">&lt;-</span> foldTypeCheckVals env2 body1</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Apply substitutions to each parameter type to resolve any type variables.</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Use `getMonoType` to extract the monomorphic type from a PolyType.</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">--  This is required here because we only ever bind parameters to monotypes,</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">--  so it is safe to extract without ambiguity.</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>  params3 <span class="ot">&lt;-</span> for params2 <span class="op">$</span> \(_p, _name, pt) <span class="ot">-&gt;</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>    applySubstitutions (getMonoType pt)</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Get the return type of the lambda by looking at the last expression in the body.</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Apply substitutions to get the fully resolved type.</span></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>  retType <span class="ot">&lt;-</span> <span class="kw">case</span> lastMay body2 <span class="kw">of</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">L.TyNil</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> l <span class="ot">-&gt;</span> applySubstitutions (getValType l)</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Construct the final function type for the lambda.</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lambdaType <span class="ot">=</span> <span class="dt">L.TyFunc</span> params3 retType</span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (env1, <span class="dt">TvLambda</span> pos lambdaType params1 body2)</span></code></pre></div>
<ul>
<li>There are no explicit types in the lambda expression, so we create fresh type variables for each parameter and return type.</li>
<li>A lambda captures its environment, so we create a new environment layer for the lambda body.</li>
<li>The body is type-checked in this new environment.</li>
<li>Get the return type and apply substitutions to resolve any type variables.</li>
</ul>
<p>The way that this implementation handles the type environment naturally supports lexical scoping and variable capture which are the foundations of closures in functional languages.</p>
<p>When type-checking a lambda, we construct a new <code>TypeEnv</code> (<code>env2</code>) that contains just the lambda‚Äôs parameters. <code>teParent = Just env1</code> then links it to the parent scope.
<code>env1</code> is the environment at the point <strong>where the lambda is defined</strong>.
That is we return <code>(env1, TvLambda...)</code>, not <code>(env2, ...)</code>. The new bindings are scoped only within the lambda body, preserving the outer environment unmodified.</p>
<p>This mirrors how most functional languages implement closures.</p>
<div class="note">
<p>üìù Lambdas capture the environment where they are defined, not where they are called from.</p>
</div>
<h3 id="type-check-atom-expression">üß© Type Check: Atom Expression</h3>
<p>Atoms are our only form of name lookup.
We fetch their polymorphic type from the environment and instantiate them to fresh monotypes for use.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>typeCheckAtom pos v <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Try to look up the variable in the type environment.</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> tlookup v env1 <span class="kw">of</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- If found, instantiate the value (see `instantiate`).</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> pt <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>      lt <span class="ot">&lt;-</span> instantiate pos pt</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> (env1, <span class="dt">TvAtom</span> pos lt v)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- If not found, throw an unbound type variable error.</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> lift <span class="op">.</span> throwE <span class="op">$</span> <span class="dt">TcUnboundVariable</span> pos v</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a><span class="ot">tlookup ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">L.PolyType</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>tlookup name env <span class="ot">=</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> Map.lookup name env<span class="op">.</span>teTypes <span class="kw">of</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> v <span class="ot">-&gt;</span> <span class="dt">Just</span> v</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> env<span class="op">.</span>teParent <span class="kw">of</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> parent <span class="ot">-&gt;</span> tlookup name parent</span></code></pre></div>
<ul>
<li><code>tlookup</code> is a utility function that looks recursively up a variable in the current type environment or it‚Äôs parents etc.</li>
<li>Instantiate if found otherwise throw an unbound variable error.</li>
</ul>
<h3 id="limitations-future-work">Limitations &amp; Future Work</h3>
<h4 id="quick-wins">Quick Wins</h4>
<ul>
<li><dl>
<dt><strong>Type signatures for let and define</strong></dt>
<dd>
Useful for documentation and guiding inference
</dd>
<dd>
Would require parsing an extra annotation form and a simple unify call in the resolver.
</dd>
</dl></li>
<li><dl>
<dt><strong>Sequential let bindings</strong></dt>
<dd>
Evaluate bindings one by one, each seeing previous ones
</dd>
<dd>
Easy to implement by threading the environment through each binding in order.
</dd>
<dd>
The <code>LetType</code> sum type and case statements are already in place.
</dd>
</dl></li>
<li><dl>
<dt><strong>Floating point type support</strong></dt>
<dd>
Adds <code>TyDouble</code>
</dd>
<dd>
Could be handled either by overloading or numeric promotion.
</dd>
</dl></li>
</ul>
<h4 id="advanced-features">Advanced Features</h4>
<ul>
<li>Recursive let and mutual recursion</li>
<li>User‚Äêdefined algebraic data types</li>
<li><dl>
<dt>Type classes and constraints</dt>
<dd>
Another way to deal with <code>double</code> vs <code>int</code>.
</dd>
</dl></li>
<li><dl>
<dt>Performance optimisations</dt>
<dd>
Current substitution and environment operations are naive
</dd>
<dd>
Large programs would benefit from incremental or cached substitution and more efficient environment lookups.
</dd>
</dl></li>
<li>Improved error messages</li>
</ul>
<h3 id="type-checking-summary">Type Checking: Summary</h3>
<p>In just a few hundred lines, we have built a complete Hindley-Milner pipeline in <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/TypeChecker.hs">TypeChecker.hs</a>.
From parser through evaluator for a minimal Lisp.</p>
<p>We support unification, generalisation, instantiation, polymorphic let bindings, and fresh-variable generation.
The code is modular and clear, making it easy to extend.</p>
<h2 id="lowering">Lowering</h2>
<p><img src="../images/hm_lisp_lower.png" /></p>
<div class="tip">
<p>üí° Lowering is the process of transforming a complex AST into a simpler form</p>
</div>
<p>Real-world compilers often perform optimisations, desugaring, bytecode generation, etc during lowering. In our pipeline, lowering simply erases all type and position annotations.</p>
<p>Including a lowering phase mirrors a full compiler architecture and sets the stage for REPL features such as runtime type queries.</p>
<p>Since the AST has already passed every type check, removing annotations <strong>cannot introduce runtime errors</strong>.</p>
<p>In GHC, types are erased before code generation, our lowering step follows the same approach.</p>
<p>With annotations removed, the resulting <code>EvalVar</code> nodes become the input to our interpreter (see the <code>EvalVar</code> type in the <a href="#evaluator">Evaluator</a> next section.).</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Lower a typed value to 'EvalVar m'.</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- In this implementation, lowering does little other than type erasure.</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- In a more complex implementation, lowering could also perform optimisations or additional transformations.</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Compling to bytecode or transpiling to another language would typically operate on lowered representation.</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="ot">lowerToEvalVar' ::</span> <span class="dt">T.TypedLispVal</span> <span class="ot">-&gt;</span> <span class="dt">Except</span> <span class="dt">E.EvalError</span> (<span class="dt">EvalVar</span> m)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>lowerToEvalVar' tv <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> tv <span class="kw">of</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvNil</span> _ <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">EvNil</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvInt</span> _ v <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvInt</span> v</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvBool</span> _ v <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvBool</span> v</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvString</span> _ v <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvString</span> v</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvAtom</span> _ _ a <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvVar</span> a</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvList</span> _ _ vs <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> lowerToEvalVar vs <span class="kw">of</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwE err</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> vs' <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvList</span> vs'</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvFuncCall</span> _p _t fv' argvs' <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>      fv <span class="ot">&lt;-</span> lowerToEvalVar' fv'</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>      argvs <span class="ot">&lt;-</span> <span class="fu">traverse</span> lowerToEvalVar' argvs'</span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvFuncCall</span> fv argvs</span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvDo</span> _ _ vs <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> lowerToEvalVar vs <span class="kw">of</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwE err</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> vs' <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvDo</span> vs'</span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvLet</span> _ _ style bindings1 body1 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>      bindings2 <span class="ot">&lt;-</span> for bindings1 <span class="op">$</span> \(_, n, v) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a>        v2 <span class="ot">&lt;-</span> lowerToEvalVar' v</span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>        <span class="fu">pure</span> (n, v2)</span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>      body2 <span class="ot">&lt;-</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> lowerToEvalVar body1 <span class="kw">of</span></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwE err</span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Right</span> body' <span class="ot">-&gt;</span> <span class="fu">pure</span> body'</span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvLet</span> style bindings2 body2</span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvLambda</span> _pos _typ args body1 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a>      body2 <span class="ot">&lt;-</span> <span class="fu">traverse</span> lowerToEvalVar' body1</span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvLambdaForm</span> (<span class="fu">snd</span> <span class="op">&lt;$&gt;</span> args) body2</span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvIf</span> _pos _typ cond then' else' <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true" tabindex="-1"></a>      cond2 <span class="ot">&lt;-</span> lowerToEvalVar' cond</span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true" tabindex="-1"></a>      then2 <span class="ot">&lt;-</span> lowerToEvalVar' then'</span>
<span id="cb45-49"><a href="#cb45-49" aria-hidden="true" tabindex="-1"></a>      else2 <span class="ot">&lt;-</span> lowerToEvalVar' else'</span>
<span id="cb45-50"><a href="#cb45-50" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvIf</span> cond2 then2 else2</span>
<span id="cb45-51"><a href="#cb45-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-52"><a href="#cb45-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-53"><a href="#cb45-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">T.TvDefine</span> _pos _typ n v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb45-54"><a href="#cb45-54" aria-hidden="true" tabindex="-1"></a>      v2 <span class="ot">&lt;-</span> lowerToEvalVar' v</span>
<span id="cb45-55"><a href="#cb45-55" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> <span class="op">$</span> <span class="dt">EvDefine</span> n v2</span></code></pre></div>
<h2 id="evaluating">Evaluating</h2>
<p><img src="../images/hm_lisp_eval.png" /></p>
<p>Having erased types, our evaluator walks the EvalVar tree, executing primitives and user-defined functions.
We know that the code is well-typed, so we can safely evaluate it without worrying about type errors.</p>
<p>Here is the lowered AST</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">EvalVar</span> m</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">EvBool</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvDefine</span> <span class="op">!</span><span class="dt">Text</span> <span class="op">!</span>(<span class="dt">EvalVar</span> m)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvDo</span> <span class="op">!</span>[<span class="dt">EvalVar</span> m]</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvFuncCall</span> <span class="op">!</span>(<span class="dt">EvalVar</span> m) <span class="op">!</span>[(<span class="dt">EvalVar</span> m)]</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvFunction</span> <span class="op">!</span>(<span class="dt">EvFunc</span> m)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvIf</span> <span class="op">!</span>(<span class="dt">EvalVar</span> m) <span class="op">!</span>(<span class="dt">EvalVar</span> m) <span class="op">!</span>(<span class="dt">EvalVar</span> m)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvInt</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvLambdaForm</span> <span class="op">!</span>[<span class="dt">Text</span>] <span class="op">!</span>[<span class="dt">EvalVar</span> m]</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvLet</span> <span class="dt">L.LetStyle</span> <span class="op">!</span>[(<span class="dt">Text</span>, <span class="dt">EvalVar</span> m)] <span class="op">!</span>[<span class="dt">EvalVar</span> m]</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvList</span> <span class="op">!</span>[<span class="dt">EvalVar</span> m]</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvNil</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvString</span> <span class="op">!</span><span class="dt">Text</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EvVar</span> <span class="op">!</span><span class="dt">Text</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">EvFunc</span> m <span class="ot">=</span> <span class="dt">EvFunc</span> ([<span class="dt">EvalVar</span> m] <span class="ot">-&gt;</span> <span class="dt">EvalEnv</span> m <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">EvalError</span> m (<span class="dt">EvalVar</span> m))</span></code></pre></div>
<p>This is very similar to <code>TypedLispVal</code>, but without the type information and positions.
Unlike previous types, it is parameterised by a monad <code>m</code>. All the types in the evaluator and the evaluator itself follow this pattern.</p>
<p>The core evaluator remains pure, all IO is delegated to an <code>EvalIO m</code> record. By abstracting over m, we can run in IO or swap in a pure test runner.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">EvalEnv</span> m <span class="ot">=</span> <span class="dt">EvalEnv</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> eeParent ::</span> <span class="op">!</span>(<span class="dt">Maybe</span> (<span class="dt">EvalEnv</span> m))</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eeVars ::</span> <span class="op">!</span>(<span class="dt">Map</span> <span class="dt">Text</span> (<span class="dt">EvalVar</span> m))</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p><code>EvFunc</code> is newtype wrapper for a function type. That is a function that can be applied.
<code>EvalEnv</code> is the environment that the function is evaluated in, it contains the variable bindings and other state needed for evaluation. <code>EvalEnv</code> is hierarchical, i.e.¬†a stack of environments.</p>
<h3 id="interaction-with-the-external-world">Interaction with the external world</h3>
<p>The evaluator itself is pure, it has no direct way to perform and side effects.
Instead it uses <code>EvalIO m</code> which provides a way to interact with the external world, assuming <code>m</code> is an <code>IO</code>-like monad.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">EvalIO</span> m <span class="ot">=</span> <span class="dt">EvalIO</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> eiPrnLn ::</span> <span class="op">!</span>(<span class="kw">forall</span> s<span class="op">.</span> (<span class="dt">Show</span> s) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> m ())</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eiPrnTextLn ::</span> <span class="op">!</span>(<span class="dt">Text</span> <span class="ot">-&gt;</span> m ())</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eiPrnErrorInCode ::</span> <span class="op">!</span>(<span class="kw">forall</span> e<span class="op">.</span> (<span class="dt">L.LispError</span> e) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> m ())</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eiLog ::</span> <span class="op">!</span>(<span class="dt">Lg.Logger</span> m)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Of course you could also implement <code>EvalIO</code> without using <code>IO</code> e.g.¬†if you wanted to use it from a pure context.</p>
<h3 id="primitive-functions">Primitive Functions</h3>
<p>Primitive functions provide built-in operations implemented in Haskell but whose types are checked in our HM engine.</p>
<p><a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/PrimFns.hs">PrimFns.hs</a> contains the primitive function‚Äôs implementation.
It is very small and incomplete but does demonstrate how the host language can provide functions to the LISP language.</p>
<p>E.g.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">PrimitiveFunctions</span> m <span class="ot">=</span> <span class="dt">PrimitiveFunctions</span> (<span class="dt">Map</span> <span class="dt">Text</span> (<span class="dt">EvFunc</span> m, <span class="dt">L.PolyType</span>))</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>getPrimitiveFunctions</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> m<span class="op">.</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>     (<span class="dt">Monad</span> m)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">E.EvalIO</span> m</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> m (<span class="dt">E.PrimitiveFunctions</span> m)</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>getPrimitiveFunctions eio <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> intIntInt <span class="ot">=</span> <span class="dt">L.PtMono</span> <span class="op">$</span> <span class="dt">L.TyFunc</span> [<span class="dt">L.TyInt</span>, <span class="dt">L.TyInt</span>] <span class="dt">L.TyInt</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">.</span> <span class="dt">E.PrimitiveFunctions</span> <span class="op">.</span> Map.fromList <span class="op">$</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    [ (<span class="st">&quot;+&quot;</span>, (<span class="dt">E.EvFunc</span> <span class="op">$</span> eMathsBin (<span class="op">+</span>), intIntInt))</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    , (<span class="st">&quot;-&quot;</span>, (<span class="dt">E.EvFunc</span> <span class="op">$</span> eMathsBin (<span class="op">-</span>), intIntInt))</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    , ( <span class="st">&quot;prn&quot;</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>      , ( <span class="dt">E.EvFunc</span> ePrn</span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        , <span class="dt">L.PtMono</span> <span class="op">$</span> <span class="dt">L.TyFunc</span> [<span class="dt">L.TyString</span>] <span class="dt">L.TyNil</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a><span class="ot">    ePrn ::</span> [<span class="dt">E.EvalVar</span> m] <span class="ot">-&gt;</span> <span class="dt">E.EvalEnv</span> m <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">E.EvalError</span> m (<span class="dt">E.EvalVar</span> m)</span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>    ePrn args _eenv <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> args <span class="kw">of</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        [v] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>          s <span class="ot">&lt;-</span> E.as' E.asString <span class="st">&quot;string&quot;</span> <span class="op">$</span> v</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>          lift <span class="op">.</span> E.eiPrnTextLn eio <span class="op">$</span> s</span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> <span class="dt">E.EvNil</span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>          throwE <span class="op">.</span> <span class="dt">E.EeRuntimeError</span> <span class="dt">Nothing</span> <span class="op">$</span> <span class="st">&quot;prn: wrong number of arguments calling prn: expected 1 argument, got: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> (<span class="fu">length</span> args)</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a><span class="ot">    eMathsBin ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> [<span class="dt">E.EvalVar</span> m] <span class="ot">-&gt;</span> <span class="dt">E.EvalEnv</span> m <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">E.EvalError</span> m (<span class="dt">E.EvalVar</span> m)</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>    eMathsBin op args _eenv <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> args <span class="kw">of</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>        [v1, v2] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>          i1 <span class="ot">&lt;-</span> E.as' E.asInt <span class="st">&quot;int&quot;</span> <span class="op">$</span> v1</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>          i2 <span class="ot">&lt;-</span> E.as' E.asInt <span class="st">&quot;int&quot;</span> <span class="op">$</span> v2</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> <span class="op">.</span> <span class="dt">E.EvInt</span> <span class="op">$</span> op i1 i2</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>          throwE <span class="op">.</span> <span class="dt">E.EeRuntimeError</span> <span class="dt">Nothing</span> <span class="op">$</span> <span class="st">&quot;Wrong number of arguments calling integer binary function: expected 2 arguments, got: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> (<span class="fu">length</span> args)</span></code></pre></div>
<p><code>getPrimitiveFunctions</code> returns a map of primitive functions and their types.
The types are used during type checking to ensure that the arguments passed to the functions are of the correct type.
The evaluator will get only the <code>EvFunc</code> from the <code>(EvFunc m, L.PolyType)</code> pair for use in evaluation.</p>
<p>Typically you‚Äôd want to have as few primitive functions as possible. Then you‚Äôd provide a standard library of functions written in the target language.</p>
<h3 id="standard-library">Standard Library</h3>
<p>The REPL loads a small LISP standard library at startup.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">; identity function</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>(define <span class="kw">identity</span> (Œª (x) x))</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">; create a list with two elements</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>(define pair (Œª (x y) (<span class="kw">list</span> x y)))</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="co">; square a number</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>(define square (Œª (x) (<span class="op">*</span> x x)))</span></code></pre></div>
<h2 id="repl">REPL</h2>
<p><img src="../images/hm_lisp_repl.png" /></p>
<p>The REPL ties together parsing, type checking, lowering, and evaluation into an interactive loop.
It is implemented in <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/Repl.hs">Repl.hs</a> using the
<a href="https://hackage.haskell.org/package/haskeline">haskline</a> library for line editing, history, and simple completion</p>
<p>The REPL is not the focus of this post, so I won‚Äôt go into too much detail here.</p>
<h3 id="startup">Startup</h3>
<p>On launch, the REPL:</p>
<ul>
<li>Loads <code>stdLib.lisp</code> (the standard library).</li>
<li>Initializes the parser, type checker, evaluator, and environment with primitives.</li>
<li>Enters a loop reading user input.</li>
</ul>
<div class="warning">
<p>‚ö†Ô∏è In this prototype, <code>stdLib.lisp</code> must reside in the current directory.</p>
</div>
<h3 id="repl-features">REPL Features</h3>
<h4 id="commands">Commands</h4>
<ul>
<li><dl>
<dt>Expression Evaluation</dt>
<dd>
Typing any valid Lisp expression parses, type-checks, and evaluates it, printing the result.
</dd>
</dl></li>
<li><dl>
<dt><code>:t &lt;expr&gt;</code></dt>
<dd>
Show the inferred type of <code>&lt;expr&gt;</code> after evaluating it.
</dd>
</dl></li>
<li><dl>
<dt><code>:ts</code></dt>
<dd>
List all known top-level names and their types (primitives, library definitions, and user defines).
</dd>
</dl></li>
<li><dl>
<dt><code>+t &lt;expr&gt;</code></dt>
<dd>
Toggle printing of types after evaluation.
</dd>
<dd>
This is on by default, but can be toggled with <code>+t</code>.
</dd>
</dl></li>
<li><dl>
<dt><code>:quit</code> or <code>Ctrl-D</code></dt>
<dd>
Exit the REPL.
</dd>
</dl></li>
<li><dl>
<dt><code>+m</code></dt>
<dd>
Toggle multi-line mode. End a block with a line containing only ..
</dd>
</dl></li>
</ul>
<h4 id="multi-line-mode">Multi-Line Mode</h4>
<p>When multi-line mode is on, you can enter a block over several lines:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> +m</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>Multiline <span class="op">=</span> on.</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>&gt;&gt;&gt; (<span class="kw">let</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>...    ( (x <span class="dv">10</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>...      (y <span class="dv">20</span>)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>...    )</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>...    (<span class="op">*</span> x y)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>... )</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>... .</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="dv">200</span></span></code></pre></div>
<h4 id="known-types-with-ts">Known Types with <code>:ts</code></h4>
<p><code>:ts</code> shows all known types, which is useful for debugging and understanding the types in the program.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> :ts</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">*</span> (: Int -&gt; Int -&gt; Int)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">+</span> (: Int -&gt; Int -&gt; Int)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>   <span class="op">-</span> (: Int -&gt; Int -&gt; Int)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">/</span> (: Int -&gt; Int -&gt; Int)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>   <span class="op">&lt;</span> (: Int -&gt; Int -&gt; Bool)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">&gt;</span> (: Int -&gt; Int -&gt; Bool)</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">and</span> (: Bool -&gt; Bool -&gt; Bool)</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>   eq_bool (: Bool -&gt; Bool -&gt; Bool)</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>   eq_int (: Int -&gt; Int -&gt; Bool)</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>   eq_string (: String -&gt; String -&gt; Bool)</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">identity</span> (‚àÄ [U0] (: U0 -&gt; U0))</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">not</span> (: Bool -&gt; Bool)</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>   <span class="kw">or</span> (: Bool -&gt; Bool -&gt; Bool)</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>   pair (‚àÄ [U2] (: U2 -&gt; U2 -&gt; (List U2)))</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>   prn (: String -&gt; Nil)</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>   square (: Int -&gt; Int)</span></code></pre></div>
<h3 id="repl-example">REPL Example</h3>
<div class="sourceCode" id="cb53"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (define <span class="kw">identity</span> (Œª (x) x))</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> :t <span class="kw">identity</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="kw">identity</span> : ‚àÄ [U0]. U0 -&gt; U0</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (<span class="kw">identity</span> <span class="dv">123</span>)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="dv">123</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (<span class="kw">identity</span> <span class="st">&quot;hello&quot;</span>)</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello&quot;</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (<span class="kw">identity</span> (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> ((Œª (x) (<span class="op">+</span> x x)) <span class="dv">10</span>)</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span></code></pre></div>
<h3 id="types-at-runtime">Types at Runtime?</h3>
<p>Since <a href="#lowering">Lowering</a> erases types from the AST, you might wonder how the REPL is able to show types for <code>:t</code> and <code>:ts</code>.
The answer is that <a href="https://github.com/andrevdm/hmLispTypeSystem/blob/blog/src/Eval/Evaluator.hs">evaluation</a> returns both a value and a type environment.
The REPL retains this and is then able to display type information even after erasure.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>m (<span class="dt">Either</span> <span class="dt">EvalError</span> (<span class="dt">T.TypeEnv</span>, <span class="dt">T.TypedLispVal</span>, <span class="dt">EvalEnv</span> m, <span class="dt">EvalVar</span> m))</span></code></pre></div>
<p>The REPL stores (and updates) this in its state</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">REnv</span> <span class="ot">=</span> <span class="dt">REnv</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> ePrintType ::</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eEvalEnv ::</span> <span class="op">!</span>(<span class="dt">Maybe</span> (<span class="dt">E.EvalEnv</span> <span class="dt">IO</span>))</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eEio ::</span> <span class="op">!</span>(<span class="dt">E.EvalIO</span> <span class="dt">IO</span>)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> ePrimFns ::</span> <span class="op">!</span>(<span class="dt">E.PrimitiveFunctions</span> <span class="dt">IO</span>)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eTypeEnv ::</span> <span class="op">!</span>(<span class="dt">T.TypeEnv</span>)   ; <span class="op">&lt;&lt;-----------</span> <span class="dt">HERE</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> eMultiLine ::</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>This approach separates runtime execution (<code>EvalVar</code>) from type bookkeeping, while still allowing full type introspection in the interactive REPL.</p>
<h1 id="conclusion">Conclusion</h1>
<ul>
<li>In this post, we walked through a Hindley‚ÄìMilner type system implementation in Haskell for a minimal Lisp.</li>
<li>You saw the core theory of unification, generalisation, instantiation, and principal types.</li>
<li>You also explored a working code pipeline, from parsing and resolution through type checking, lowering, and evaluation.</li>
<li>A key takeaway is that HM-style inference need not be daunting to implement.</li>
<li>Although minimal, this example provides a solid foundation for further extensions.</li>
</ul>
<p>I hope you‚Äôve found this walk-through both practical and inspiring.</p>
<p>Please feel free to clone the <a href="https://github.com/andrevdm/hmLispTypeSystem">GitHub repo</a>, experiment with the code, and share your improvements or questions.</p>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><dl>
<dt><strong>The Typed Racket Guide</strong></dt>
<dd>
<a href="https://docs.racket-lang.org/ts-guide/">Typed Racket</a>
</dd>
</dl></li>
<li><dl>
<dt><strong>Robert Nystrom</strong></dt>
<dd>
<a href="https://craftinginterpreters.com/">Crafting Interpreters</a>
</dd>
</dl></li>
<li><dl>
<dt><strong>Wikipedia</strong>:</dt>
<dd>
<a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley‚ÄìMilner type system</a>
</dd>
</dl></li>
<li><dl>
<dt><strong>Jeremy Siek</strong></dt>
<dd>
<a href="https://siek.blogspot.com/2012/07/crash-course-on-notation-in-programming.html">Crash Course on Notation in Programming Language Theory</a>
</dd>
</dl></li>
<li><dl>
<dt><strong>Pierce, Benjamin C.</strong> (2002). <em>Types and Programming Languages</em>. MIT Press.</dt>
<dd>
<a href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a>
</dd>
</dl></li>
<li><dl>
<dt><strong>Milner, R.</strong> (1978). <em>A theory of type polymorphism in programming</em>.</dt>
<dd>
<a href="https://www.sciencedirect.com/science/article/pii/0022000078900144">Journal of Computer and System Sciences, 17(3), 348-375.</a>
</dd>
</dl></li>
<li><dl>
<dt><strong>Damas, L. &amp; Milner, R.</strong> (1982). <em>Principal type-schemes for functional programs</em>.</dt>
<dd>
<a href="https://dl.acm.org/doi/10.1145/582153.582176">Principal type-schemes for functional programs</a>
</dd>
</dl></li>
</ul>
</div>

        </div>
        <div id="footer">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
      </div>

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-78428674-1', 'auto');
          ga('send', 'pageview');
        </script>
        <script src="../js/site.js"></script>
    </body>
</html>
