<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Andre's Blog</title>
    <link href="http://www.andrevdm.com/atom.xml" rel="self" />
    <link href="http://www.andrevdm.com" />
    <id>http://www.andrevdm.com/atom.xml</id>
    <author>
        <name>Andre Van Der Merwe</name>
        <email>blog@andrevdm.com</email>
    </author>
    <updated>2018-04-02T00:00:00Z</updated>
    <entry>
    <title>Haskell roguelike</title>
    <link href="http://www.andrevdm.com/posts/2018-04-02-haskell-rogue-like.html" />
    <id>http://www.andrevdm.com/posts/2018-04-02-haskell-rogue-like.html</id>
    <published>2018-04-02T00:00:00Z</published>
    <updated>2018-04-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on April  2, 2018
    
</div>

<h1 id="introduction">Introduction</h1>
<p>In this series of posts I’m going to discuss some of the major design decisions that you will need to consider when making a Haskell roguelike game. I’ll be talking about how the code is implemented as well as the decisions I took along the way and why.</p>
<p>See the chapter list below to get an idea of what topics I’ll be covering.</p>
<h2 id="what-is-a-roguelike">What is a roguelike?</h2>
<p><img src="../images/rogue_full_view.png" /></p>
<p><a href="http://www.roguebasin.com/index.php?title=Main_Page">RogueBasin</a> defines a roguelike as</p>
<blockquote>
<p>A Roguelike is usually described as a free turn-based computer game with a strong focus on intricate gameplay and replayability, and an abstract world representation using ASCII-based display, as opposed to 3D graphics. Of course, as with any genre, there are deviations from the norm.</p>
</blockquote>
<h2 id="other-roguelike-tutorials-and-engines">Other roguelike tutorials and engines</h2>
<p>There are several good Haskell roguelike tutorials and tools. The ones I know about are</p>
<ul>
<li><a href="https://github.com/LambdaHack/LambdaHack/blob/master/README.md">Haskell game engine library for ASCII roguelike games</a></li>
<li><a href="http://jamiltron.com/2012/07/Code_Us_Some_Roguelike_in_Haskell.html">Code Us Some Roguelike in Haskell!</a></li>
<li><a href="https://lokathor.gitbooks.io/using-haskell/content/roguelike/">Complete Roguelike Tutorial</a></li>
<li><a href="http://www.roguebasin.com/index.php?title=Haskell">Haskell category on rogue basin</a></li>
<li><a href="http://haskellroguelike.com/">Haskell roguelike</a></li>
</ul>
<p>Each of the tutorials takes a different approach, cover different topics and address different levels of familiarity with haskell. The more the merrier! If you are interested in building a roguelike, or just looking for ideas for writing games in Haskell, then looking at the links above as well as this series seems like a good idea.</p>
<p><a href="https://github.com/LambdaHack/LambdaHack/blob/master/README.md">LambdaHack</a> is a game engine for making ASCII roguelike games. It is definitely worth taking a look at. For this series I decided not to use LambdaHack as it already implements many of the things I was interested in learning about. This is a trade-off you’ll have to make. Are you currently more interested in learning how to build the game or more interested in getting a robust game together? I’d suggest learning with a small roguelike first as you’ll then have a much better idea of what a game engine offers or how it may constrain you.</p>
<p><a href="http://www.roguebasin.com/index.php?title=Articles">RogueBasin</a> has a vast amount of detail on creating roguelike games. Its well worth your time to look at for ideas. I’ll be referring to articles from roguebasin throughout the series</p>
<h1 id="the-series">The series</h1>
<h2 id="why-read-this-series">Why read this series?</h2>
<p>Apart from just being another perspective, I think that these are some reasons you may want to continue reading</p>
<ul>
<li>Discussion of all the basics since I’m not using a game engine</li>
<li>UI style</li>
<li>Reasonably simple Haskell (I hope!)</li>
<li>In total the game is under 1500 lines of haskell with all the features mentioned below</li>
<li>AI implementation</li>
<li>Decisions about energy systems, viewport scrolling, levels and managing a plot</li>
</ul>
<p>Also I’m not a gamer and this is the first game I’ve ever written, so that should bring a slightly different perspective ;)</p>
<h2 id="structure">Structure</h2>
<p>There are 20 “chapters”. Each chapter builds on the previous one. Each chapter’s code is available on <a href="https://github.com/andrevdm/haskellRogueLike">github</a> and has a working example. At the end of each chapter is a patch file that shows what was added/changed.</p>
<h2 id="notes-on-the-code">Notes on the code</h2>
<p>I’ve tried to keep the Haskell code simple, hopefully it is easy to follow even if you don’t have much experience. E.g. There is only one transformer used (chapter 14) and that is entirely optional.</p>
<p>I am using <a href="https://github.com/sdiehl/protolude/">Protolude</a> as my prelude. It should be fairly easy to switch to something else. Note that protolude defines <code>&lt;&lt;$&gt;&gt;</code> which is the same as <code>(fmap . fmap)</code> or <code>&lt;$$&gt;</code> from <a href="https://hackage.haskell.org/package/composition-extra">composition-extra</a></p>
<h3 id="lenses">Lenses</h3>
<p>I am using lenses, since there are several nested record types I use. If you have not used <a href="https://hackage.haskell.org/package/lens">lens</a> before it may seem odd. I’m mostly using only three lenses, so you should be able to follow along without worrying about them too much.</p>
<p>If you are unfamiliar with lenses here are some links that may help get you started quickly,</p>
<ul>
<li><a href="http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html">Program imperatively using Haskell lenses</a></li>
<li><a href="https://artyom.me/lens-over-tea-1">Lens over tea</a></li>
<li><a href="https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html">Control.Lens.Tutorial</a></li>
</ul>
<p>And here are a few quick examples that may help you get a sense for what they do.</p>
<p>Given this definition</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Txt</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Control.Lens</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span>           <span class="dt">Control.Lens.TH</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">data</span> <span class="dt">Parent</span> <span class="fu">=</span> <span class="dt">Parent</span> {<span class="ot"> _pName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                     ,<span class="ot"> _pChild ::</span> <span class="dt">Child</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">                     } <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">            </a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Child</span> <span class="fu">=</span> <span class="dt">Child</span> {<span class="ot"> _cName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">                   } <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">makeLenses <span class="ch">&#39;&#39;</span><span class="dt">Parent</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">makeLenses <span class="ch">&#39;&#39;</span><span class="dt">Child</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  <span class="kw">let</span> parent <span class="fu">=</span> <span class="dt">Parent</span> { _pName <span class="fu">=</span> <span class="st">&quot;parent1&quot;</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">                      , _pChild <span class="fu">=</span> <span class="dt">Child</span> { _cName <span class="fu">=</span> <span class="st">&quot;child1&quot;</span> }</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">                      }</a></code></pre></div>
<h4 id="section">^.</h4>
<p>The <code>^.</code> lens acts as a field getter</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">  <span class="fu">#</span> <span class="dt">With</span> lens</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  putText <span class="fu">$</span> parent <span class="fu">^.</span> pName</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  putText <span class="fu">$</span> parent <span class="fu">^.</span> pChild <span class="fu">^.</span> cName</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="fu">#</span> <span class="dt">Without</span> lens</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  putText <span class="fu">$</span> _pName parent</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  putText <span class="fu">$</span> _cName <span class="fu">.</span> _pChild <span class="fu">$</span> parent</a></code></pre></div>
<p>Which both print</p>
<pre><code>parent1
child1</code></pre>
<p>There is not too much difference between the two styles, yet.</p>
<h4 id="section-1">.~</h4>
<p>The <code>.~</code> lens acts as a field setter</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">  <span class="fu">#</span> <span class="dt">With</span> lens</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  print <span class="fu">$</span> parent <span class="fu">&amp;</span> pName <span class="fu">.~</span> <span class="st">&quot;newName&quot;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  print <span class="fu">$</span> parent <span class="fu">&amp;</span> (pChild <span class="fu">.</span> cName) <span class="fu">.~</span> <span class="st">&quot;new childName&quot;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="fu">#</span> <span class="dt">Without</span> lens</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  print <span class="fu">$</span> parent { _pName <span class="fu">=</span> <span class="st">&quot;newName&quot;</span> }</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  print <span class="fu">$</span> parent { _pChild <span class="fu">=</span> (_pChild parent) { _cName <span class="fu">=</span> <span class="st">&quot;new childName&quot;</span> } }</a></code></pre></div>
<p>Which both print</p>
<pre><code>Parent {_pName = &quot;newName&quot;, _pChild = Child {_cName = &quot;child1&quot;}}
Parent {_pName = &quot;parent1&quot;, _pChild = Child {_cName = &quot;new childName&quot;}}</code></pre>
<p>Once you start updating nested records, I think the lens code is much easier to read. The deeper the nesting the more true this is.</p>
<h4 id="section-2">%~</h4>
<p>The <code>%~</code> lens acts as a field updater that works by sending the current value through a function</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">  <span class="fu">#</span> <span class="dt">With</span> lens</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  print <span class="fu">$</span> parent <span class="fu">&amp;</span> pName <span class="fu">%~</span> Txt.toUpper</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  print <span class="fu">$</span> parent <span class="fu">&amp;</span> (pChild <span class="fu">.</span> cName) <span class="fu">%~</span> Txt.toUpper</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="fu">#</span> <span class="dt">Without</span> lens</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  print <span class="fu">$</span> parent { _pName <span class="fu">=</span> Txt.toUpper <span class="fu">.</span> _pName <span class="fu">$</span> parent }</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  print <span class="fu">$</span> parent { _pChild <span class="fu">=</span> (_pChild parent) { _cName <span class="fu">=</span> Txt.toUpper <span class="fu">.</span> _cName <span class="fu">.</span> _pChild <span class="fu">$</span> parent  } }</a></code></pre></div>
<p>Which both print</p>
<pre><code>Parent {_pName = &quot;PARENT1&quot;, _pChild = Child {_cName = &quot;child1&quot;}}
Parent {_pName = &quot;parent1&quot;, _pChild = Child {_cName = &quot;CHILD1&quot;}}</code></pre>
<p>Here I’d say the lens code is significantly easier to read, i.e. the intent is much clearer.</p>
<p>Quite often you’ll end up combining these three lenses and the alternative, in my view, is way too noisy. There are some tradeoffs using lens, e.g. template haskell but I feel that it is justified by the resulting code. Obviously if you prefer not to use lens you can do everything reasonably easily without it.</p>
<h1 id="chapters">Chapters</h1>
<ul>
<li><a href="multi/2018-04-02-haskell-rogue-like_01.html">01 - UI &amp; tiles</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_02.html">02 - UI Code</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_03.html">03 - Entities &amp; Drawing</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_04.html">04 - Map loading</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_05.html">05 - Actors</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_06.html">06 - Moving the player</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_07.html">07 - Collisions</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_08.html">08 - Layers</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_09.html">09 - Viewport scrolling</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_10.html">10 - Field of view</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_11.html">11 - Sticky light</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_12.html">12 - Energy</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_13.html">13 - Utility AI</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_14.html">14 - Utility AI annotations</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_15.html">15 - Memory</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_16.html">16 - Debugging</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_17.html">17 - Levels</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_18.html">18 - Mutliple levels</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_19.html">19 - Story</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_20.html">20 - Structure</a></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_fin.html">21 - Conclusion</a></li>
</ul>
<h2 id="bonus">Bonus</h2>
<ul>
<li><a href="multi/2018-04-02-haskell-rogue-like_21.html">22 - ASCII terminal GUI</a></li>
</ul>
<h1 id="links">Links</h1>
<ul>
<li><p><a href="https://www.reddit.com/r/haskell/comments/89et9d/building_a_haskell_roguelike_game/">Comments thread on /r/haskell subreddit</a></p></li>
<li><a href="multi/2018-04-02-haskell-rogue-like_01.html">Chapter 1 - UI &amp; tiles</a></li>
<li><p><a href="https://github.com/andrevdm/haskellRogueLike">Code on github</a></p></li>
<li><a href="https://github.com/LambdaHack/LambdaHack/blob/master/README.md">Haskell game engine library for ASCII roguelike games</a></li>
<li><a href="http://jamiltron.com/2012/07/Code_Us_Some_Roguelike_in_Haskell.html">Code Us Some Roguelike in Haskell!</a></li>
<li><a href="https://lokathor.gitbooks.io/using-haskell/content/roguelike/">Complete Roguelike Tutorial</a></li>
<li><a href="http://www.roguebasin.com/index.php?title=Haskell">Haskell category on rogue basin</a></li>
<li><a href="http://haskellroguelike.com/">Haskell roguelike</a></li>
<li><p><a href="http://www.roguebasin.com/index.php?title=How_to_Write_a_Roguelike_in_15_Steps">How to Write a Roguelike in 15 Steps</a></p></li>
</ul>

]]></summary>
</entry>
<entry>
    <title>Hakyll compiler to include working code samples</title>
    <link href="http://www.andrevdm.com/posts/2018-02-05-hakyll-code-build-include-compiler.html" />
    <id>http://www.andrevdm.com/posts/2018-02-05-hakyll-code-build-include-compiler.html</id>
    <published>2018-02-05T00:00:00Z</published>
    <updated>2018-02-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on February  5, 2018
    
</div>

<p><em>(updated: 09/March/2018 - includes, local path &amp; html, css and js support)</em></p>
<p>Ensuring that the code you include in a blog post is up to date and works can be a bit of a pain. Often I’ll change code while writing a post and then I have to find and copy anything that has changed. This is manual and error prone.</p>
<p>Fortunately <a href="https://hackage.haskell.org/package/hakyll">Hakyll</a> is reasonably easy to customise. Here I’ll show one way to write a hakyll compiler to help with this issue.</p>
<h1 id="goal">Goal</h1>
<p>What I wanted was</p>
<ol type="1">
<li>Include code from a git repo</li>
<li>Work with a specific version of the code</li>
<li>Check that the code builds</li>
<li>Check that tests or any other custom actions succeed</li>
<li>Check that the repo is still accessible</li>
</ol>
<h2 id="example-template-markdown">Example template markdown</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb1-1" data-line-number="1">  ---</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  title: testing</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ---</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  [&lt;code setup.repo&gt;] https://gist.github.com/53e179c4244411493ae1f9deebc3cc3f.git</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  [&lt;code setup.sha&gt;] 5a95ece18ecb248fb745b3e7cb19f5c4d410240f</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  [&lt;code setup.run&gt;] stack init --resolver lts-10.4</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  [&lt;code setup.run&gt;] stack build</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  [&lt;code setup.run&gt;] stack test</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  Some text</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  [&lt;code&gt;] main</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  more text</a></code></pre></div>
<p>The markdown should be parsed as follows</p>
<ul>
<li><code>[&lt;code setup.repo&gt;]</code> - is the git repo to pull the code from</li>
<li><code>[&lt;code setup.sha&gt;]</code> - is the commit to work with</li>
<li><code>[&lt;code setup.run&gt;]</code> - any number of commands to run in order.</li>
<li><code>[&lt;code&gt;] main</code> - gets the section named <code>main</code> from the code and inserts it as a markdown code block</li>
</ul>
<h2 id="example-haskell-file-with-sections">Example haskell file with sections</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Protolude</span> <span class="kw">hiding</span> (onException)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">System.FilePath</span> ((&lt;/&gt;))</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.FilePath</span> <span class="kw">as</span> <span class="dt">FP</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span> <span class="kw">as</span> <span class="dt">Dir</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Control.Exception.Safe</span> (onException, throwString)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="co">{-! SECTION&lt; main !-}</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">main <span class="fu">=</span> hakyll <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">        route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">        compile <span class="fu">$</span> includeCodeCompiler</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">            <span class="fu">&gt;&gt;=</span> renderPandoc </a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="co">{-! SECTION&gt; main !-}</span></a></code></pre></div>
<ul>
<li><code>{-! SECTION&lt;</code> starts a code section</li>
<li><code>{-! SECTION&gt;</code> ends a code section</li>
<li>The parser will read all sections from all files in the repo, so section names must be unique. The advantage is that you don’t need to worry about finding paths or paths changing later on.</li>
</ul>
<h2 id="result">Result</h2>
<p>When pandoc is run the include compiler will insert the code from the <code>main</code> section and add a title showing the source path (repo relative) and the position (line from &amp; to).</p>
<h6 id="appsite.hs-32-to-37">app/site.hs (32 to 37)</h6>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">main <span class="fu">=</span> hakyll <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        compile <span class="fu">$</span> includeCodeCompiler</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">            <span class="fu">&gt;&gt;=</span> renderPandoc </a></code></pre></div>
<p>Before including the code, the <strong>includeCompiler</strong> will checkout the code and run the commands specified in the template. In the example template above I’m cloning from a github gist that does not have a stack.yaml so I run <code>stack init</code> first. You can use the commands to run tests etc to ensure that your sample code is working 100%. If any action fails, the blog generation is aborted.</p>
<h2 id="constraints">Constraints</h2>
<ol type="1">
<li>I only use markdown, so I’m assuming that all input is markdown</li>
<li>This is not “production” code. I’m doing a lot of work in IO and throwing exceptions to abort on error</li>
<li>It works for me, feel free to use the code and change it to match your needs.</li>
</ol>
<h1 id="code">Code</h1>
<h2 id="customising-hakyll">Customising hakyll</h2>
<p>The <a href="https://jaspervdj.be/hakyll/tutorials.html">hakyll tutorial</a> will give you an idea of how to setup hakyll.</p>
<p>This is a fairly standard match clause to run your posts through pandoc to generate HTML output</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">    match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">        route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">        compile <span class="fu">$</span> pandocCompiler</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    postCtx</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">            <span class="fu">&gt;&gt;=</span> saveSnapshot <span class="st">&quot;content&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> postCtx</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">            <span class="fu">&gt;&gt;=</span> relativizeUrls</a></code></pre></div>
<p>Lets modify this route to use a new compiler named <strong>includeCodeCompiler</strong> and pipe that output through pandoc</p>
<h6 id="site.hs-32-to-39">site.hs (32 to 39)</h6>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">  match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">      route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">      compile <span class="fu">$</span> includeCodeCompiler</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">          <span class="fu">&gt;&gt;=</span> renderPandoc</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">          <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    postCtx</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">          <span class="fu">&gt;&gt;=</span> saveSnapshot <span class="st">&quot;content&quot;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">          <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> postCtx</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">          <span class="fu">&gt;&gt;=</span> relativizeUrls</a></code></pre></div>
<p>The two changes to notice are</p>
<ol type="1">
<li>Call <strong>includeCompiler</strong> rather than <strong>pandocCompiler</strong></li>
<li>The output of <strong>includeCompiler</strong> is passed to <strong>renderPandoc</strong></li>
</ol>
<h2 id="preliminaries">Preliminaries</h2>
<p>Here are the imports I’m using</p>
<h6 id="site.hs-2-to-20">site.hs (2 to 20)</h6>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Protolude</span> <span class="kw">hiding</span> (onException)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Prelude</span> (<span class="dt">String</span>)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">Lst</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Txt</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">Txt</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Data.Monoid</span> (mappend)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Hakyll</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Exit</span> <span class="kw">as</span> <span class="dt">Xit</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Process</span> <span class="kw">as</span> <span class="dt">Proc</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16"><span class="kw">import</span>           <span class="dt">System.FilePath</span> ((&lt;/&gt;))</a>
<a class="sourceLine" id="cb6-17" data-line-number="17"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.FilePath</span> <span class="kw">as</span> <span class="dt">FP</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span> <span class="kw">as</span> <span class="dt">Dir</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19"><span class="kw">import</span>           <span class="dt">Control.Exception.Safe</span> (onException, throwString)</a></code></pre></div>
<p>And a few helper functions for running shell processes and finding files</p>
<h6 id="site.hs-220-to-250">site.hs (220 to 250)</h6>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">runShell&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">runShell&#39; workingDir cmd <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  putText cmd</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  runShell workingDir cmd <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="dt">Right</span> _ <span class="ot">-&gt;</span> pass</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> throwString <span class="fu">$</span> Txt.unpack <span class="st">&quot;Error running `&quot;</span> <span class="fu">&lt;&gt;</span> Txt.unpack cmd <span class="fu">&lt;&gt;</span> <span class="st">&quot;` &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">runShell ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Int</span> ())</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">runShell workingDir cmd <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">let</span> p <span class="fu">=</span> Proc.shell <span class="fu">$</span> Txt.unpack cmd</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  (_, _, _, phandle) <span class="ot">&lt;-</span> Proc.createProcess p { Proc.cwd <span class="fu">=</span> <span class="dt">Just</span> workingDir }</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  Proc.waitForProcess phandle <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    <span class="dt">Xit.ExitSuccess</span> <span class="ot">-&gt;</span> pure <span class="fu">$</span> <span class="dt">Right</span> ()</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    <span class="dt">Xit.ExitFailure</span> i <span class="ot">-&gt;</span> pure <span class="fu">$</span> <span class="dt">Left</span> i</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"><span class="ot">getFilesRec ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> [FilePath]</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">getFilesRec p <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  fs <span class="ot">&lt;-</span> (p <span class="fu">&lt;/&gt;</span>) <span class="fu">&lt;&lt;$&gt;&gt;</span> getFiles p</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  ds <span class="ot">&lt;-</span> (p <span class="fu">&lt;/&gt;</span>) <span class="fu">&lt;&lt;$&gt;&gt;</span> getDirs p</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">  cs <span class="ot">&lt;-</span> traverse getFilesRec ds</a>
<a class="sourceLine" id="cb7-21" data-line-number="21">  pure <span class="fu">$</span> fs <span class="fu">&lt;&gt;</span> join cs</a>
<a class="sourceLine" id="cb7-22" data-line-number="22"></a>
<a class="sourceLine" id="cb7-23" data-line-number="23"><span class="ot">getDirs ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> [FilePath]</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">getDirs p <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">  entries <span class="ot">&lt;-</span> (p <span class="fu">&lt;/&gt;</span>) <span class="fu">&lt;&lt;$&gt;&gt;</span> Dir.listDirectory p</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">  filterM Dir.doesDirectoryExist entries</a>
<a class="sourceLine" id="cb7-27" data-line-number="27"></a>
<a class="sourceLine" id="cb7-28" data-line-number="28"><span class="ot">getFiles ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> [FilePath]</a>
<a class="sourceLine" id="cb7-29" data-line-number="29">getFiles p <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">  entries <span class="ot">&lt;-</span> (p <span class="fu">&lt;/&gt;</span>) <span class="fu">&lt;&lt;$&gt;&gt;</span> Dir.listDirectory p</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">  filterM Dir.doesFileExist entries</a></code></pre></div>
<h2 id="the-includecodecompiler">The includeCodeCompiler</h2>
<h6 id="site.hs-51-to-66">site.hs (51 to 66)</h6>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">includeCodeCompiler ::</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">includeCodeCompiler <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  p <span class="ot">&lt;-</span> getResourceFilePath</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  getResourceString <span class="fu">&gt;&gt;=</span> withItemBody (unsafeCompiler <span class="fu">.</span> includeCompile p)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">    includeCompile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    includeCompile compilingPath source <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      includeCompile&#39; source</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="ot">`onException`</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">      putStr (<span class="st">&quot;Exception compiling includes for: &quot;</span> <span class="fu">&lt;&gt;</span> compilingPath)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="ot">    includeCompile&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    includeCompile&#39; source <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="kw">let</span> ls1 <span class="fu">=</span> Txt.lines <span class="fu">$</span> Txt.pack source </a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      <span class="kw">let</span> (sourceNoSetup, repoPath&#39;, sha&#39;, cmds&#39;, path&#39;) <span class="fu">=</span> getConfig ls1 </a></code></pre></div>
<p>A pandoc compiler has the type <code>Compiler (Item String)</code>. Since this compiler needs to read file it has to be able to perform IO. To allow IO the <code>unsafeCompiler</code> function is used.</p>
<p>So this code, gets the current file path, the item body and starts the includeCompile in IO</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">  p <span class="ot">&lt;-</span> getResourceFilePath</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  getResourceString <span class="fu">&gt;&gt;=</span> withItemBody (unsafeCompiler <span class="fu">.</span> includeCompile p)</a></code></pre></div>
<p><code>onException</code> is used to print the name of the file being compiled if there is an exception.</p>
<p>Once the config (repo, sha and commands) have been read the main compiler logic can be run.</p>
<h6 id="site.hs-70-to-110">site.hs (70 to 110)</h6>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">      <span class="kw">case</span> path&#39; <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">          <span class="kw">case</span> (repoPath&#39;, sha&#39;, cmds&#39;) <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">            (<span class="dt">Nothing</span>, <span class="dt">Nothing</span>, []) <span class="ot">-&gt;</span> pure <span class="fu">$</span> Txt.unpack <span class="fu">.</span> Txt.unlines <span class="fu">$</span> sourceNoSetup</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">            (<span class="dt">Just</span> _, <span class="dt">Nothing</span>, _) <span class="ot">-&gt;</span> throwString <span class="st">&quot;No sha found&quot;</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">            (<span class="dt">Just</span> _, _, []) <span class="ot">-&gt;</span> throwString <span class="st">&quot;No run commands found&quot;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">            (<span class="dt">Nothing</span>, _, (_<span class="fu">:</span>_)) <span class="ot">-&gt;</span> throwString <span class="st">&quot;No repo setup found&quot;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">            (<span class="dt">Nothing</span>, <span class="dt">Just</span> _, []) <span class="ot">-&gt;</span> throwString <span class="st">&quot;No repo setup found&quot;</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">            (<span class="dt">Just</span> repoPath, <span class="dt">Just</span> sha, cmds) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">              root <span class="ot">&lt;-</span> Dir.getCurrentDirectory</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">              <span class="kw">let</span> tempPath <span class="fu">=</span> root <span class="fu">&lt;/&gt;</span> tmpDirectory defaultConfiguration <span class="fu">&lt;/&gt;</span> <span class="st">&quot;codeIncludeGit&quot;</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">              <span class="co">-- Cleanup from previous post</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">              removeDirectoryRecursiveIfExists tempPath</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">              Dir.createDirectoryIfMissing <span class="dt">True</span> tempPath</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">              <span class="co">-- Clone the git repo</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">              runShell&#39; root <span class="fu">$</span> <span class="st">&quot;git clone \&quot;&quot;</span> <span class="fu">&lt;&gt;</span> repoPath <span class="fu">&lt;&gt;</span> <span class="st">&quot;\&quot; \&quot;&quot;</span> <span class="fu">&lt;&gt;</span> Txt.pack tempPath <span class="fu">&lt;&gt;</span> <span class="st">&quot;\&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">              <span class="co">-- Goto the correct sha (if it was specified)</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">              gotoSha sha tempPath</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">              <span class="co">-- Execute the run commands (buid, test etc)</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21">              executeRunCommands cmds tempPath</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">              <span class="co">-- Delete all dirs we are not interested in (exclude .git and .stack-work)</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">              removeDirectoryRecursiveIfExists <span class="fu">$</span> tempPath <span class="fu">&lt;/&gt;</span> <span class="st">&quot;.git&quot;</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24">              removeDirectoryRecursiveIfExists <span class="fu">$</span> tempPath <span class="fu">&lt;/&gt;</span> <span class="st">&quot;.stack-work&quot;</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25">              includeCode tempPath repoPath sha sourceNoSetup</a>
<a class="sourceLine" id="cb10-26" data-line-number="26"></a>
<a class="sourceLine" id="cb10-27" data-line-number="27">        <span class="dt">Just</span> path <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb10-28" data-line-number="28">          includeCode (Txt.unpack path) <span class="st">&quot;**local**&quot;</span> <span class="st">&quot;**local**&quot;</span> sourceNoSetup</a>
<a class="sourceLine" id="cb10-29" data-line-number="29"></a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    includeCode tempPath repoPath sha sourceNoSetup <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">      <span class="co">-- Get all files in the repo </span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32">      files <span class="ot">&lt;-</span> getFilesRec tempPath</a>
<a class="sourceLine" id="cb10-33" data-line-number="33">      <span class="co">-- All sections from all files</span></a>
<a class="sourceLine" id="cb10-34" data-line-number="34">      sections&#39; <span class="ot">&lt;-</span> Map.fromList <span class="fu">.</span> concat <span class="fu">&lt;$&gt;</span> traverse getSections files</a>
<a class="sourceLine" id="cb10-35" data-line-number="35">      <span class="kw">let</span> sections <span class="fu">=</span> Map.map (\(p, s, e, lang, ls) <span class="ot">-&gt;</span> (drop (length tempPath <span class="fu">+</span> <span class="dv">1</span>) p, s, e, lang, ls)) sections&#39; </a>
<a class="sourceLine" id="cb10-36" data-line-number="36">      <span class="co">-- Replace sections in the file</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37">      replaced&#39; <span class="ot">&lt;-</span> traverse (replaceCodeLineSection tempPath sections) sourceNoSetup</a>
<a class="sourceLine" id="cb10-38" data-line-number="38">      <span class="kw">let</span> replaced <span class="fu">=</span> Txt.unlines <span class="fu">.</span> concat <span class="fu">$</span> replaced&#39;</a>
<a class="sourceLine" id="cb10-39" data-line-number="39">      <span class="co">-- Replace sha and repo tokens</span></a>
<a class="sourceLine" id="cb10-40" data-line-number="40">      pure <span class="fu">.</span> Txt.unpack <span class="fu">.</span> Txt.replace <span class="st">&quot;2297510b93a903ab23a319f7921351a9725cef0e&quot;</span> sha <span class="fu">$</span> Txt.replace <span class="st">&quot;https://gist.github.com/53e179c4244411493ae1f9deebc3cc3f.git&quot;</span> repoPath replaced</a>
<a class="sourceLine" id="cb10-41" data-line-number="41">  </a></code></pre></div>
<h6 id="site.hs-114-to-121">site.hs (114 to 121)</h6>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">    executeRunCommands ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    executeRunCommands cmds path <span class="fu">=</span> </a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      traverse_ (runShell&#39; path) cmds</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="ot">    gotoSha ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    gotoSha sha tmpPath <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">      runShell&#39; tmpPath (<span class="st">&quot;git reset &quot;</span> <span class="fu">&lt;&gt;</span> sha <span class="fu">&lt;&gt;</span> <span class="st">&quot; --hard&quot;</span>) </a>
<a class="sourceLine" id="cb11-8" data-line-number="8">      void <span class="fu">$</span> runShell tmpPath <span class="st">&quot;git clean -dfx&quot;</span></a></code></pre></div>
<p>This code does the following</p>
<ol type="1">
<li>Pre-clone cleanup</li>
<li>Clone</li>
<li>Goto the configured commit</li>
<li>Run the commands</li>
<li>Read all the sections from the files</li>
<li>Import the sections into the markdown</li>
</ol>
<h2 id="details">Details</h2>
<p>Loading the config is done quite simply by filtering the source lines</p>
<h6 id="site.hs-126-to-142">site.hs (126 to 142)</h6>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">  getConfig ls <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">      cfgPath <span class="fu">=</span> <span class="st">&quot;[&lt;code setup.path&gt;]&quot;</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">      cfgRepo <span class="fu">=</span> <span class="st">&quot;[&lt;code setup.repo&gt;]&quot;</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      cfgSha <span class="fu">=</span> <span class="st">&quot;[&lt;code setup.sha&gt;]&quot;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      cfgRun <span class="fu">=</span> <span class="st">&quot;[&lt;code setup.run&gt;]&quot;</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">      path <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.drop (Txt.length cfgRepo) <span class="fu">&lt;$&gt;</span> headMay (filter (Txt.isPrefixOf cfgPath) ls)</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">      repo <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.drop (Txt.length cfgRepo) <span class="fu">&lt;$&gt;</span> headMay (filter (Txt.isPrefixOf cfgRepo) ls)</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">      sha <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.drop (Txt.length cfgSha) <span class="fu">&lt;$&gt;</span> headMay (filter (Txt.isPrefixOf cfgSha) ls)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">      run <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.drop (Txt.length cfgRun) <span class="fu">&lt;$&gt;</span> filter (Txt.isPrefixOf cfgRun) ls</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    (filter (not <span class="fu">.</span> Txt.isPrefixOf <span class="st">&quot;[&lt;code setup.&quot;</span>) ls, repo, sha, run, path)</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">      </a>
<a class="sourceLine" id="cb12-14" data-line-number="14">  removeDirectoryRecursiveIfExists p <span class="fu">=</span> </a>
<a class="sourceLine" id="cb12-15" data-line-number="15">    Dir.doesDirectoryExist p <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">      <span class="dt">True</span> <span class="ot">-&gt;</span> Dir.removeDirectoryRecursive p</a>
<a class="sourceLine" id="cb12-17" data-line-number="17">      <span class="dt">False</span> <span class="ot">-&gt;</span> pass</a></code></pre></div>
<p>And once the sections have been loaded from the source code the tags can be replaced in the markdown. Each <code>[&lt;code&gt;]</code> tag is replaced by a markdown code block, a title showing the source file and offset.</p>
<h6 id="site.hs-147-to-175">site.hs (147 to 175)</h6>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">    replaceCodeLineSection ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Text</span> (FilePath, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Text</span>, [<span class="dt">Text</span>]) <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    replaceCodeLineSection tempPath sections line <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">      <span class="kw">let</span> codeTag <span class="fu">=</span> <span class="st">&quot;[&lt;code&gt;]&quot;</span> </a>
<a class="sourceLine" id="cb13-4" data-line-number="4">      <span class="kw">let</span> includeTag <span class="fu">=</span> <span class="st">&quot;[&lt;include&gt;]&quot;</span> </a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      <span class="kw">if</span> Txt.isPrefixOf codeTag line </a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        <span class="kw">then</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">          <span class="kw">let</span> secName <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.drop (Txt.length codeTag) <span class="fu">$</span> line <span class="kw">in</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">          <span class="kw">case</span> Map.lookup secName sections <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwString <span class="fu">$</span> Txt.unpack <span class="fu">$</span> <span class="st">&quot;No section named &quot;</span> <span class="fu">&lt;&gt;</span> secName</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">            <span class="dt">Just</span> (path, start, end, lang, code) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">              <span class="kw">let</span> title <span class="fu">=</span> Txt.pack path <span class="fu">&lt;&gt;</span> <span class="st">&quot; (&quot;</span> <span class="fu">&lt;&gt;</span> show start <span class="fu">&lt;&gt;</span> <span class="st">&quot; to &quot;</span> <span class="fu">&lt;&gt;</span> show end <span class="fu">&lt;&gt;</span> <span class="st">&quot;)&quot;</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">              pure [ <span class="st">&quot;###### &quot;</span> <span class="fu">&lt;&gt;</span> title</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">                   , <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                   , <span class="st">&quot;~~~{.&quot;</span> <span class="fu">&lt;&gt;</span> lang <span class="fu">&lt;&gt;</span> <span class="st">&quot;}&quot;</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">                   , Txt.unlines code</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">                   , <span class="st">&quot;~~~&quot;</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">                   , <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20">                   ]</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">        <span class="kw">else</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">          <span class="kw">if</span> not <span class="fu">$</span> Txt.isPrefixOf includeTag line </a>
<a class="sourceLine" id="cb13-23" data-line-number="23">            <span class="kw">then</span> pure [line]</a>
<a class="sourceLine" id="cb13-24" data-line-number="24">            <span class="kw">else</span></a>
<a class="sourceLine" id="cb13-25" data-line-number="25">              <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">                incRelPath <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.drop (Txt.length includeTag) <span class="fu">$</span> line </a>
<a class="sourceLine" id="cb13-27" data-line-number="27">                incFullPath <span class="fu">=</span> tempPath <span class="fu">&lt;/&gt;</span> Txt.unpack incRelPath</a>
<a class="sourceLine" id="cb13-28" data-line-number="28">              <span class="kw">in</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29">              sequenceA [Txt.readFile incFullPath]</a></code></pre></div>
<h2 id="getting-sections-from-the-repo">Getting sections from the repo</h2>
<h6 id="site.hs-181-to-215">site.hs (181 to 215)</h6>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">type</span> <span class="dt">LineState</span> <span class="fu">=</span> (<span class="dt">Int</span>, [(<span class="dt">Text</span>, (FilePath, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Text</span>, [<span class="dt">Text</span>]))]) </a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">getSections ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">Text</span>, (FilePath, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Text</span>, [<span class="dt">Text</span>]))]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">getSections f <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="kw">case</span> FP.takeExtension f <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="st">&quot;.hs&quot;</span> <span class="ot">-&gt;</span> getLangSections <span class="st">&quot;{-! SECTION&lt; &quot;</span> <span class="st">&quot;{-! SECTION&gt; &quot;</span> <span class="st">&quot;{-! SECTION&quot;</span> <span class="st">&quot;haskell&quot;</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="st">&quot;.js&quot;</span> <span class="ot">-&gt;</span> getLangSections <span class="st">&quot;//!SECTION&lt; &quot;</span> <span class="st">&quot;//!SECTION&gt; &quot;</span> <span class="st">&quot;//!SECTION&quot;</span> <span class="st">&quot;javascript&quot;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="st">&quot;.html&quot;</span> <span class="ot">-&gt;</span> getLangSections <span class="st">&quot;&lt;!-- !SECTION+ &quot;</span> <span class="st">&quot;&lt;!-- !SECTION- &quot;</span> <span class="st">&quot;&lt;!-- !SECTION&quot;</span> <span class="st">&quot;html&quot;</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="st">&quot;.css&quot;</span> <span class="ot">-&gt;</span> getLangSections <span class="st">&quot;/* !SECTION&lt; &quot;</span> <span class="st">&quot;/* !SECTION&gt; &quot;</span> <span class="st">&quot;/* !SECTION&quot;</span> <span class="st">&quot;html&quot;</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    _ <span class="ot">-&gt;</span> pure []</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb14-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    getLangSections startToken endToken cleanToken lang <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">      ls <span class="ot">&lt;-</span> Txt.lines <span class="fu">&lt;$&gt;</span> Txt.readFile f</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">      (_, r) <span class="ot">&lt;-</span> foldlM (parseLine ls) (<span class="dv">1</span>, []) ls</a>
<a class="sourceLine" id="cb14-16" data-line-number="16">      pure r</a>
<a class="sourceLine" id="cb14-17" data-line-number="17"></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-19" data-line-number="19"><span class="ot">        parseLine ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">LineState</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">LineState</span></a>
<a class="sourceLine" id="cb14-20" data-line-number="20">        parseLine ls (lineNum, hist) l <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-21" data-line-number="21">          <span class="kw">if</span> not <span class="fu">.</span> Txt.isPrefixOf startToken <span class="fu">.</span> Txt.strip <span class="fu">$</span> l</a>
<a class="sourceLine" id="cb14-22" data-line-number="22">          <span class="kw">then</span> pure (lineNum <span class="fu">+</span> <span class="dv">1</span>, hist)</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">          <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-24" data-line-number="24">            <span class="kw">let</span> secName <span class="fu">=</span> Txt.strip <span class="fu">.</span> fst <span class="fu">.</span> Txt.breakOn <span class="st">&quot; &quot;</span> <span class="fu">.</span> Txt.strip <span class="fu">.</span> Txt.drop (Txt.length startToken) <span class="fu">.</span> Txt.strip <span class="fu">$</span> l </a>
<a class="sourceLine" id="cb14-25" data-line-number="25">            end <span class="ot">&lt;-</span> scanForEnd ls secName lineNum</a>
<a class="sourceLine" id="cb14-26" data-line-number="26">            pure (lineNum <span class="fu">+</span> <span class="dv">1</span>, (secName, (f, lineNum <span class="fu">+</span> <span class="dv">1</span>, lineNum <span class="fu">+</span> length end, lang, end)) <span class="fu">:</span> hist)</a>
<a class="sourceLine" id="cb14-27" data-line-number="27"></a>
<a class="sourceLine" id="cb14-28" data-line-number="28">        scanForEnd ls secName fromLine <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-29" data-line-number="29">          <span class="kw">let</span> fromOffset <span class="fu">=</span> drop fromLine ls <span class="kw">in</span></a>
<a class="sourceLine" id="cb14-30" data-line-number="30">          <span class="kw">case</span> Lst.span (not <span class="fu">.</span> Txt.isPrefixOf (endToken <span class="fu">&lt;&gt;</span> secName) <span class="fu">.</span> Txt.strip) fromOffset <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-31" data-line-number="31">            (_, []) <span class="ot">-&gt;</span> throwString <span class="fu">$</span> <span class="st">&quot;No section end found for: &quot;</span> <span class="fu">&lt;&gt;</span> Txt.unpack secName</a>
<a class="sourceLine" id="cb14-32" data-line-number="32">            (r, _) <span class="ot">-&gt;</span> pure <span class="fu">$</span> filter cleanLine r</a>
<a class="sourceLine" id="cb14-33" data-line-number="33"></a>
<a class="sourceLine" id="cb14-34" data-line-number="34">        cleanLine <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-35" data-line-number="35">          not <span class="fu">.</span> Txt.isPrefixOf cleanToken <span class="fu">.</span> Txt.strip</a></code></pre></div>
<p>Different types of files will need different tag styles. In the code above I’m handling haskell, javascript, css and HTML. You should be able to fairly easily add this to other languages as well.</p>
<p><code>parseLine</code> works by going line by line looking for a start token, and for each one that it finds it scans to find the end token. This is a little inefficient but it allows for nested and/or overlapping tags.</p>
<h1 id="code-includes">Code includes</h1>
<p>Sometimes it is useful to include external files into a post. The <code>[&lt;include&gt;]</code> tag makes this simple.</p>
<p>For example <code>[&lt;include&gt;] /home/user/static/interestingStuff.json</code>. Unlike the <code>[&lt;code&gt;]</code> tag, no assumptions are made about the included text. If you want it syntax highlighted simply wrap the text in a code fence.</p>
<h1 id="speeding-up-the-writing-process">Speeding up the writing process</h1>
<p>Fetching the code from a remote repo and doing a full build each time can be pretty slow. This is fine when you are confirming that everything works correctly, but its not idea when you are writing a post and still making many small changes. To help with this there is a <code>[&lt;code setup.path&gt;]</code> tag. This tag overrides the repo and run settings. If it is present then all code sections will be read from this path directly without any fetching, building or running of commands.</p>
<p>e.g. <code>[&lt;code setup.path&gt;] /home/user/dev/myProject</code></p>
<p>Obviously it is important that you remove this setting once the post is done.</p>
<h1 id="using-the-compiler">Using the compiler</h1>
<p>Once you add this to your hakyll you can be sure that you are only using working code blocks. While there is a bit of code in this compiler most of it is for dealing with the file IO and parsing. I think it also shows how easily hakyll can be customised to do useful things.</p>
<p>This code works with hakyll 4.10.0.0. See the cabal file in the gist for other dependencies</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://gist.github.com/andrevdm/53e179c4244411493ae1f9deebc3cc3f">Code on github</a> 2297510b93a903ab23a319f7921351a9725cef0e</li>
<li><a href="https://jaspervdj.be/hakyll/tutorials.html">Hakyll tutorial</a></li>
<li><a href="https://medium.com/@phlummox/the-simplest-custom-hakyll-compiler-6ee7b189a6c6">The simplest custom Hakyll compiler</a></li>
</ul>

]]></summary>
</entry>
<entry>
    <title>bhoogle - Building a simple hoogle GUI with brick</title>
    <link href="http://www.andrevdm.com/posts/2018-01-15-bhoogle.html" />
    <id>http://www.andrevdm.com/posts/2018-01-15-bhoogle.html</id>
    <published>2018-01-15T00:00:00Z</published>
    <updated>2018-01-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 15, 2018
    
</div>

<h1 id="overview">Overview</h1>
<p>bhoogle is a simple hoogle terminal GUI written using <a href="https://hackage.haskell.org/package/brick">brick</a>. This post is the annotated source code that should give you an idea of how to use brick and how easy brick makes building terminal UIs.</p>
<h2 id="bhoogle">bhoogle</h2>
<p><img src="/images/bhoogle.png" /></p>
<p>bhoogle is possibly useful as a local hoogle UI as well as a demo app. You can get the full code from <a href="https://github.com/andrevdm/bhoogle">github</a>.</p>
<h3 id="setup">Setup</h3>
<p>You will need an existing local hoogle database. If you do not already have one or are unsure, then do this</p>
<ol type="1">
<li>Install hoogle (e.g. <code>stack install hoogle</code>)</li>
<li>Generate the default database (<code>hoogle generate</code>)</li>
</ol>
<h3 id="build">Build</h3>
<p>You can then <a href="https://github.com/andrevdm/bhoogle">clone the code</a>, or download one of the pre-build <a href="https://github.com/andrevdm/bhoogle/releases">linux releases</a></p>
<h3 id="usage">Usage</h3>
<ol type="1">
<li>Enter a type search in the “type” edit box</li>
<li>Press <strong>enter</strong> to search: focus goes directly to the results list</li>
<li>Or press <strong>tab</strong> to search and focus will go to the “text” edit box</li>
<li>You can then filter the results by typing in the “text” edit box, any result containing the sub-string typed will be shown</li>
<li>Navigate the results by using <strong>arrow</strong> or vi (<strong>hjkl</strong>) keys</li>
<li>Pressing <strong>‘s’</strong> in the results list will toggle the sort order</li>
<li><strong>Escape</strong> to exit</li>
<li>Search-ahead is enable for any type search longer than three characters</li>
</ol>
<h1 id="brick">Brick</h1>
<p>There are a few conventions to get used to when building a brick UI, but I don’t think it should take you too long to get the hang of things.</p>
<p>The <a href="https://github.com/jtdaugherty/brick/blob/master/docs/guide.rst">brick user guide</a> and documentation are fantastic. Brick comes with multiple example apps that show controls and features being used. There are also third party tutorials e.g. <a href="https://github.com/jtdaugherty/brick/blob/master/docs/samtay-tutorial.md">Samuel Tay’s brick tutorial</a></p>
<h1 id="bhoogle-0.1.1.0-source">bhoogle 0.1.1.0 source</h1>
<p>If you have looked at the user guide or Samuel Tay’s tutorial you’ll already have some idea of the fundamental concepts. Below is the annotated source for bhoogle. As always feel free to email or contact me on <a href="https://twitter.com/andrevdm">twitter</a> if anything is unclear and I’ll do my best to assist.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Control.Lens</span> ((^.), (.~), (%~))</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span>           <span class="dt">Control.Lens.TH</span> (makeLenses)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">Lst</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Time</span> <span class="kw">as</span> <span class="dt">Tm</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Txt</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vec</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Brick</span> ((&lt;+&gt;), (&lt;=&gt;))</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.BChan</span> <span class="kw">as</span> <span class="dt">BCh</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Focus</span> <span class="kw">as</span> <span class="dt">BF</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.AttrMap</span> <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.List</span> <span class="kw">as</span> <span class="dt">BL</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.Edit</span> <span class="kw">as</span> <span class="dt">BE</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.Border</span> <span class="kw">as</span> <span class="dt">BB</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.Border.Style</span> <span class="kw">as</span> <span class="dt">BBS</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="kw">import</span>           <span class="dt">Control.Concurrent</span> (threadDelay, forkIO)</a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Graphics.Vty</span> <span class="kw">as</span> <span class="dt">V</span></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Graphics.Vty.Input.Events</span> <span class="kw">as</span> <span class="dt">K</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26"></a>
<a class="sourceLine" id="cb1-27" data-line-number="27"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Hoogle</span> <span class="kw">as</span> <span class="dt">H</span></a></code></pre></div>
<p>Import all the modules we’ll need. I’m using <a href="https://github.com/sdiehl/protolude">protolude</a> as my custom prelude, changing to one of the others e.g. <a href="https://hackage.haskell.org/package/classy-prelude">classy</a> should be pretty simple if you prefer that.</p>
<p>I’m also using lens. The brick examples use lens so its worth getting used to. However I’m only using three of the simpler lenses, so if you don’t like lens or template haskell it should be easy enough to remove them.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- | Events that can be sent</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- | Here there is just one event for updating the time</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">Event</span> <span class="fu">=</span> <span class="dt">EventUpdateTime</span> <span class="dt">Tm.LocalTime</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">-- | Names use to identify each of the controls</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">TypeSearch</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">          <span class="fu">|</span> <span class="dt">TextSearch</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">          <span class="fu">|</span> <span class="dt">ListResults</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">          <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>Next we need to define the type of custom events that our brick application can handle and a sum type defining the “name” for each control we want to use.</p>
<p>In this example there is only a single event <strong>EventUpdateTime</strong>. It is sent once a second with the current time. This gets displayed by brick in the top right corner</p>
<p>There are three controls</p>
<ol type="1">
<li>The edit box for the type to search for</li>
<li>The edit box for the substring search</li>
<li>The results listbox</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- | Sort order</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">data</span> <span class="dt">SortBy</span> <span class="fu">=</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">            <span class="fu">|</span> <span class="dt">SortAsc</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">            <span class="fu">|</span> <span class="dt">SortDec</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">            <span class="kw">deriving</span> (<span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co">-- | State of the brick app. Contains the controls and any other required state</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">data</span> <span class="dt">BrickState</span> <span class="fu">=</span> <span class="dt">BrickState</span> </a>
<a class="sourceLine" id="cb3-10" data-line-number="10">     {<span class="ot"> _stEditType ::</span> <span class="fu">!</span>(<span class="dt">BE.Editor</span> <span class="dt">Text</span> <span class="dt">Name</span>)      <span class="co">-- ^ Editor for the type to search for</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">     ,<span class="ot"> _stEditText ::</span> <span class="fu">!</span>(<span class="dt">BE.Editor</span> <span class="dt">Text</span> <span class="dt">Name</span>)      <span class="co">-- ^ Editor for a text search in the results</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">     ,<span class="ot"> _stResultsList ::</span> <span class="fu">!</span>(<span class="dt">BL.List</span> <span class="dt">Name</span> <span class="dt">H.Target</span>) <span class="co">-- ^ List for the search results</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">     ,<span class="ot"> _stFocus ::</span> <span class="fu">!</span>(<span class="dt">BF.FocusRing</span> <span class="dt">Name</span>)           <span class="co">-- ^ Focus ring - a circular list of focusable controls</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">     ,<span class="ot"> _stTime ::</span> <span class="fu">!</span><span class="dt">Tm.LocalTime</span>                   <span class="co">-- ^ The current time</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">     ,<span class="ot"> _stResults ::</span> [<span class="dt">H.Target</span>]                   <span class="co">-- ^ The last set of search results from hoohle</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">     ,<span class="ot"> _stSortResults ::</span> <span class="dt">SortBy</span>                   <span class="co">-- ^ Current sort order for the results</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">     }</a>
<a class="sourceLine" id="cb3-18" data-line-number="18"></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">makeLenses <span class="ch">&#39;&#39;</span><span class="dt">BrickState</span></a></code></pre></div>
<p><strong>BrickState</strong> contains the current state of the brick application. Any event e.g. the custom update time event, or any key press event can result in the state being updated. There is a separate draw function that renders the state.</p>
<p>I.e. one part of the code deals with events, roughly <code>state -&gt; event -&gt; state</code> and another handles the drawing <code>state -&gt; GUI</code></p>
<p>Here the state contains</p>
<ol type="1">
<li>The three controls mentioned above (two edit + one listbox)</li>
<li>A focus ring. (A <a href="https://hackage.haskell.org/package/brick-0.33/docs/Brick-Focus.html">focus ring</a> is a circular list of control names that helps your code keep track of which control has the current focus).</li>
<li>The last updated current time</li>
<li>The last search result</li>
<li>The current sort order, so that it can be toggled between ascending and descending</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- | Defines how the brick application will work / handle events</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">app ::</span> <span class="dt">B.App</span> <span class="dt">BrickState</span> <span class="dt">Event</span> <span class="dt">Name</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">app <span class="fu">=</span> <span class="dt">B.App</span> { B.appDraw <span class="fu">=</span> drawUI</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">            , B.appChooseCursor <span class="fu">=</span> B.showFirstCursor</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">            , B.appHandleEvent <span class="fu">=</span> handleEvent</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">            , B.appStartEvent <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">            , B.appAttrMap <span class="fu">=</span> const theMap</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">            }</a></code></pre></div>
<p>The <strong>App</strong> type defines how the brick app operates, but defining how events are handled (<code>appHandleEvent</code>) and how the GUI is drawn (<code>appDraw</code>)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  chan <span class="ot">&lt;-</span> BCh.newBChan <span class="dv">5</span> <span class="co">-- ^ create a bounded channel for events</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="co">-- Send a tick event every 1 seconds with the current time</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="co">-- Brick will send this to our event handler which can then update the stTime field</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  void <span class="fu">.</span> forkIO <span class="fu">$</span> forever <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    t <span class="ot">&lt;-</span> getTime </a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    BCh.writeBChan chan <span class="fu">$</span> <span class="dt">EventUpdateTime</span> t</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    threadDelay <span class="fu">$</span> <span class="dv">1</span> <span class="fu">*</span> <span class="dv">1000000</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  <span class="co">-- Initial current time value</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  t <span class="ot">&lt;-</span> getTime</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  <span class="co">-- Construct the initial state values</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="kw">let</span> st <span class="fu">=</span> <span class="dt">BrickState</span> { _stEditType <span class="fu">=</span> BE.editor <span class="dt">TypeSearch</span> (<span class="dt">Just</span> <span class="dv">1</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">                      , _stEditText <span class="fu">=</span> BE.editor <span class="dt">TextSearch</span> (<span class="dt">Just</span> <span class="dv">1</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">                      , _stResultsList <span class="fu">=</span> BL.list <span class="dt">ListResults</span> Vec.empty <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">                      , _stTime <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">                      , _stFocus <span class="fu">=</span> BF.focusRing [<span class="dt">TypeSearch</span>, <span class="dt">TextSearch</span>, <span class="dt">ListResults</span>]</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">                      , _stResults <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">                      , _stSortResults <span class="fu">=</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb5-23" data-line-number="23">                      }</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">          </a>
<a class="sourceLine" id="cb5-25" data-line-number="25">  <span class="co">-- Run brick</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">  void <span class="fu">$</span> B.customMain (V.mkVty V.defaultConfig) (<span class="dt">Just</span> chan) app st</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">    <span class="co">-- | Get the local time</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    getTime <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">      t <span class="ot">&lt;-</span> Tm.getCurrentTime</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">      tz <span class="ot">&lt;-</span> Tm.getCurrentTimeZone</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">      pure <span class="fu">$</span> Tm.utcToLocalTime tz t</a></code></pre></div>
<p>In <strong>main</strong> some setup is preformed and then brick is started by calling <code>customMain</code>.</p>
<p>For bhoogle the steps are</p>
<ol type="1">
<li>Construct the channel for brick events (passed to <code>customMain</code>)</li>
<li>Create a new thread to send the current time every second</li>
<li>Construct an initial state, with empty controls and search results</li>
<li><code>B.customMain</code> to run brick</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- | Main even handler for brick events</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">handleEvent ::</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">B.BrickEvent</span> <span class="dt">Name</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">B.EventM</span> <span class="dt">Name</span> (<span class="dt">B.Next</span> <span class="dt">BrickState</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">handleEvent st ev <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">case</span> ev <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    (<span class="dt">B.AppEvent</span> (<span class="dt">EventUpdateTime</span> time)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      <span class="co">-- Update the time in the state</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">      B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stTime <span class="fu">.~</span> time</a></code></pre></div>
<p><strong>handleEvent</strong> gets all the brick events, updates the state and decides how to continue.</p>
<p>Here the code matches the custom (<strong>B.AppEvent</strong>) event looking for our update time event (<strong>EventUpdateTime</strong>) and then updates the state with the current time. <code>B.continue</code> means that brick continues after updating the state. Note that the UI is not changed in any way here, we are just altering the current state.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">    <span class="co">-- Handle keyboard events</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="co">--   k is the key</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="co">--   ms are the modifier keys</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    (<span class="dt">B.VtyEvent</span> ve<span class="fu">@</span>(<span class="dt">V.EvKey</span> k ms)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">      <span class="kw">case</span> (k, ms) <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        <span class="co">-- Escape quits the app, no matter what control has focus</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        (<span class="dt">K.KEsc</span>, []) <span class="ot">-&gt;</span> B.halt st</a></code></pre></div>
<p>Then the code matches any keyboard event (<strong>B.VtyEvent</strong>) here matching on the escape key (<strong>K.KEsc</strong>). So when the user clicks the escape key this handler will call <code>B.halt</code> which will terminate the app. As this is done at the top level, this means that no matter which control has the focus, escape will exit.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">        _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">          <span class="co">-- How to interpret the key press depends on which control is focused</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="kw">case</span> BF.focusGetCurrent <span class="fu">$</span> st <span class="fu">^.</span> stFocus <span class="kw">of</span></a></code></pre></div>
<p>For the rest of the key press logic, what bhoogle does depends on which control has the focus. <code>BF.focusGetCurrent</code> is used to get that from the state’s focus ring.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">            <span class="dt">Just</span> <span class="dt">TypeSearch</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">              <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                <span class="dt">K.KChar</span> <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">                  <span class="co">-- Search, clear sort order, focus next</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">                  found <span class="ot">&lt;-</span> doSearch st</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusNext</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">                                                  <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">                                                  <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">                <span class="dt">K.KBackTab</span> <span class="ot">-&gt;</span><span class="kw">do</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">                  <span class="co">-- Search, clear sort order, focus prev</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">                  found <span class="ot">&lt;-</span> doSearch st</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">                  B.continue  <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusPrev</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">                                                   <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">                                                   <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a></code></pre></div>
<p>If the user is typing in the “type” edit box and tabs out (either tab or shift-tab) then</p>
<ol type="1">
<li>Perform the search (see <strong>doSearch</strong> below)</li>
<li>Update the current set of results</li>
<li>Reset the sort order, default to the order that hoogle uses</li>
<li>Move the focus to the next/previous control</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">                <span class="dt">K.KEnter</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">                  <span class="co">-- Search, clear sort order, focus on results</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">                  <span class="co">--  This makes it faster if you want to search and navigate </span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                  <span class="co">--  results without tabing through the text search box</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                  found <span class="ot">&lt;-</span> doSearch st</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                                                  <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">                                                  <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusSetCurrent <span class="dt">ListResults</span></a></code></pre></div>
<p>If the user presses <strong>enter</strong> while in the type search edit box, then</p>
<ol type="1">
<li>Perform the search (see <strong>doSearch</strong> below)</li>
<li>Update the current set of results</li>
<li>Reset the sort order, default to the order that hoogle uses</li>
<li>Move the focus directly to the results lisbox so they can navigate and see the current item’s details &amp; help text</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">                _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">                  <span class="co">-- Let the editor handle all other events</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">                  r <span class="ot">&lt;-</span> BE.handleEditorEvent ve <span class="fu">$</span> st <span class="fu">^.</span> stEditType</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">                  next <span class="ot">&lt;-</span> liftIO <span class="fu">.</span> searchAhead doSearch <span class="fu">$</span> st <span class="fu">&amp;</span> stEditType <span class="fu">.~</span> r </a>
<a class="sourceLine" id="cb11-5" data-line-number="5">                  B.continue next</a></code></pre></div>
<p>For all other key events for the type search, let the editor control handle the key press. This gives us editing, navigation etc for free.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">            <span class="dt">Just</span> <span class="dt">TextSearch</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">              <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                <span class="dt">K.KChar</span> <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusNext <span class="co">-- Focus next</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">                <span class="dt">K.KBackTab</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusPrev   <span class="co">-- Focus previous</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">                _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">                  <span class="co">-- Let the editor handle all other events</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">                  r <span class="ot">&lt;-</span> BE.handleEditorEvent ve <span class="fu">$</span> st <span class="fu">^.</span> stEditText</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stEditText <span class="fu">.~</span> r</a></code></pre></div>
<p>For the text edit box</p>
<ol type="1">
<li>Change focus on tab / shift-tab</li>
<li>For all other keys
<ol type="1">
<li>Let the editor handle the key press</li>
<li>Filter the hoogle results</li>
</ol></li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">            <span class="dt">Just</span> <span class="dt">ListResults</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">              <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">                <span class="dt">K.KChar</span> <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusNext <span class="co">-- Focus next</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">                <span class="dt">K.KBackTab</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusPrev   <span class="co">-- Focus previous</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">                <span class="dt">K.KChar</span> <span class="ch">&#39;s&#39;</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">                  <span class="co">-- Toggle the search order between ascending and descending,</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">                  <span class="co">--  use asc if sort order was &#39;none&#39;</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">                  <span class="kw">let</span> sortDir <span class="fu">=</span> <span class="kw">if</span> (st <span class="fu">^.</span> stSortResults) <span class="fu">==</span> <span class="dt">SortAsc</span> </a>
<a class="sourceLine" id="cb13-9" data-line-number="9">                                  <span class="kw">then</span> <span class="dt">SortDec</span> </a>
<a class="sourceLine" id="cb13-10" data-line-number="10">                                  <span class="kw">else</span> <span class="dt">SortAsc</span> </a>
<a class="sourceLine" id="cb13-11" data-line-number="11">                  <span class="kw">in</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">                  <span class="kw">let</span> sorter <span class="fu">=</span> <span class="kw">if</span> sortDir <span class="fu">==</span> <span class="dt">SortDec</span> </a>
<a class="sourceLine" id="cb13-13" data-line-number="13">                                 <span class="kw">then</span> (Lst.sortBy <span class="fu">$</span> flip compareType) </a>
<a class="sourceLine" id="cb13-14" data-line-number="14">                                 <span class="kw">else</span> (Lst.sortBy compareType) </a>
<a class="sourceLine" id="cb13-15" data-line-number="15">                  <span class="kw">in</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">%~</span> sorter</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">                                                  <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> sortDir</a>
<a class="sourceLine" id="cb13-18" data-line-number="18"></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">                _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20">                  <span class="co">-- Let the list handle all other events</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">                  <span class="co">-- Using handleListEventVi which adds vi-style keybindings for navigation</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">                  <span class="co">--  and the standard handleListEvent as a fallback for all other events</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23">                  r <span class="ot">&lt;-</span> BL.handleListEventVi BL.handleListEvent ve <span class="fu">$</span> st <span class="fu">^.</span> stResultsList</a>
<a class="sourceLine" id="cb13-24" data-line-number="24">                  B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stResultsList <span class="fu">.~</span> r</a>
<a class="sourceLine" id="cb13-25" data-line-number="25"></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">            _ <span class="ot">-&gt;</span> B.continue st</a>
<a class="sourceLine" id="cb13-27" data-line-number="27"></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">    _ <span class="ot">-&gt;</span> B.continue st</a></code></pre></div>
<p>For the results listbox</p>
<ul>
<li>Handle tab / shift-tab</li>
<li>Pressing the <strong>‘s’</strong> key will sort the results. Pressing it again toggles the direction, so keep track of which order was used last.</li>
<li>For all other keys use <code>BL.handleListEventVi BL.handleListEvent</code> which gives us vi style navigation and uses the standard <strong>handleListEvent</strong> as the fallback, so that all the normal navigation (arrows) also work.</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    doSearch st&#39; <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-3" data-line-number="3">      liftIO <span class="fu">$</span> searchHoogle (Txt.strip <span class="fu">.</span> Txt.concat <span class="fu">$</span> BE.getEditContents (st&#39; <span class="fu">^.</span> stEditType))</a></code></pre></div>
<p>And finally for <strong>handleEvent</strong> the <strong>doSearch</strong> function which calls the <strong>searchHoogle</strong> function (below) to search on the text from the type editbox.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- | Search ahead for type strings longer than 3 chars.</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">searchAhead ::</span> (<span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">H.Target</span>]) <span class="ot">-&gt;</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">BrickState</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">searchAhead search st <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="kw">let</span> searchText <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.concat <span class="fu">.</span> BE.getEditContents <span class="fu">$</span> st <span class="fu">^.</span> stEditType <span class="kw">in</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">if</span> Txt.length searchText <span class="fu">&gt;</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    <span class="co">-- Search</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    found <span class="ot">&lt;-</span> search st</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    pure <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">                              <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    <span class="co">-- Just clear</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">    pure <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">.~</span> []</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">              <span class="fu">&amp;</span> stResultsList <span class="fu">%~</span> BL.listClear</a></code></pre></div>
<p><strong>searchAhead</strong> is a helper function that searches hoogle as the user types. As long as there are more than three characters being searched for. Without this limit hoogle seems a bit slow on my machine because of the large number of results.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- | Filter the results from hoogle using the search text</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">filterResults ::</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">BrickState</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">filterResults st <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">let</span> allResults <span class="fu">=</span> st <span class="fu">^.</span> stResults <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  <span class="kw">let</span> filterText <span class="fu">=</span> Txt.toLower <span class="fu">.</span> Txt.strip <span class="fu">.</span> Txt.concat <span class="fu">.</span> BE.getEditContents <span class="fu">$</span> st <span class="fu">^.</span> stEditText <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  <span class="kw">let</span> results <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">        <span class="kw">if</span> Txt.null filterText</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">        <span class="kw">then</span> allResults</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">        <span class="kw">else</span> filter (\t <span class="ot">-&gt;</span> Txt.isInfixOf filterText <span class="fu">.</span> Txt.toLower <span class="fu">$</span> formatResult t) allResults</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  st <span class="fu">&amp;</span> stResultsList <span class="fu">.~</span> BL.list <span class="dt">ListResults</span> (Vec.fromList results) <span class="dv">1</span></a></code></pre></div>
<p>Filter the hoogle results by doing a sub-string search if the user has entered one</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- | Draw the UI</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">drawUI ::</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> [<span class="dt">B.Widget</span> <span class="dt">Name</span>]</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">drawUI st <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  [B.padAll <span class="dv">1</span> contentBlock] </a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    contentBlock <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">      (B.withBorderStyle BBS.unicode <span class="fu">$</span> BB.border searchBlock)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">      B.padTop (<span class="dt">B.Pad</span> <span class="dv">1</span>) resultsBlock</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">      </a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    resultsBlock <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">      <span class="kw">let</span> total <span class="fu">=</span> show <span class="fu">.</span> length <span class="fu">$</span> st <span class="fu">^.</span> stResults <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">      <span class="kw">let</span> showing <span class="fu">=</span> show <span class="fu">.</span> length <span class="fu">$</span> st <span class="fu">^.</span> stResultsList <span class="fu">^.</span> BL.listElementsL <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">      (B.withAttr <span class="st">&quot;infoTitle&quot;</span> <span class="fu">$</span> B.txt <span class="st">&quot;Results: &quot;</span>) <span class="fu">&lt;+&gt;</span> B.txt (showing <span class="fu">&lt;&gt;</span> <span class="st">&quot;/&quot;</span> <span class="fu">&lt;&gt;</span> total)</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-17" data-line-number="17">      (B.padTop (<span class="dt">B.Pad</span> <span class="dv">1</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-18" data-line-number="18">       resultsContent <span class="fu">&lt;+&gt;</span> resultsDetail</a>
<a class="sourceLine" id="cb17-19" data-line-number="19">      )</a>
<a class="sourceLine" id="cb17-20" data-line-number="20"></a>
<a class="sourceLine" id="cb17-21" data-line-number="21">    resultsContent <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">      BL.renderList (\_ e <span class="ot">-&gt;</span> B.txt <span class="fu">$</span> formatResult e) <span class="dt">False</span> (st <span class="fu">^.</span> stResultsList)</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">    resultsDetail <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-25" data-line-number="25">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">1</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-26" data-line-number="26">      B.hLimit <span class="dv">60</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-27" data-line-number="27">      vtitle <span class="st">&quot;package:&quot;</span></a>
<a class="sourceLine" id="cb17-28" data-line-number="28">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-29" data-line-number="29">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">2</span>) (B.txt <span class="fu">$</span> getSelectedDetail (\t <span class="ot">-&gt;</span> maybe <span class="st">&quot;&quot;</span> (Txt.pack <span class="fu">.</span> fst) (H.targetPackage t)))</a>
<a class="sourceLine" id="cb17-30" data-line-number="30">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-31" data-line-number="31">      vtitle <span class="st">&quot;module:&quot;</span></a>
<a class="sourceLine" id="cb17-32" data-line-number="32">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-33" data-line-number="33">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">2</span>) (B.txt <span class="fu">$</span> getSelectedDetail (\t <span class="ot">-&gt;</span> maybe <span class="st">&quot;&quot;</span> (Txt.pack <span class="fu">.</span> fst) (H.targetModule t)))</a>
<a class="sourceLine" id="cb17-34" data-line-number="34">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-35" data-line-number="35">      vtitle <span class="st">&quot;docs:&quot;</span></a>
<a class="sourceLine" id="cb17-36" data-line-number="36">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-37" data-line-number="37">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">2</span>) (B.txt <span class="fu">$</span> getSelectedDetail (Txt.pack <span class="fu">.</span> clean <span class="fu">.</span> H.targetDocs))</a>
<a class="sourceLine" id="cb17-38" data-line-number="38">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-39" data-line-number="39">      B.fill <span class="ch">&#39; &#39;</span></a>
<a class="sourceLine" id="cb17-40" data-line-number="40">  </a>
<a class="sourceLine" id="cb17-41" data-line-number="41">    searchBlock <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-42" data-line-number="42">      ((htitle <span class="st">&quot;Type: &quot;</span> <span class="fu">&lt;+&gt;</span> editor <span class="dt">TypeSearch</span> (st <span class="fu">^.</span> stEditType)) <span class="fu">&lt;+&gt;</span> time (st <span class="fu">^.</span> stTime))</a>
<a class="sourceLine" id="cb17-43" data-line-number="43">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-44" data-line-number="44">      (htitle <span class="st">&quot;Text: &quot;</span> <span class="fu">&lt;+&gt;</span> editor <span class="dt">TextSearch</span> (st <span class="fu">^.</span> stEditText))</a>
<a class="sourceLine" id="cb17-45" data-line-number="45"></a>
<a class="sourceLine" id="cb17-46" data-line-number="46">    htitle t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-47" data-line-number="47">      B.hLimit <span class="dv">20</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-48" data-line-number="48">      B.withAttr <span class="st">&quot;infoTitle&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-49" data-line-number="49">      B.txt t</a>
<a class="sourceLine" id="cb17-50" data-line-number="50">      </a>
<a class="sourceLine" id="cb17-51" data-line-number="51">    vtitle t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-52" data-line-number="52">      B.withAttr <span class="st">&quot;infoTitle&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-53" data-line-number="53">      B.txt t</a>
<a class="sourceLine" id="cb17-54" data-line-number="54"></a>
<a class="sourceLine" id="cb17-55" data-line-number="55">    editor n e <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-56" data-line-number="56">      B.vLimit <span class="dv">1</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-57" data-line-number="57">      BE.renderEditor (B.txt <span class="fu">.</span> Txt.unlines) (BF.focusGetCurrent (st <span class="fu">^.</span> stFocus) <span class="fu">==</span> <span class="dt">Just</span> n) e</a>
<a class="sourceLine" id="cb17-58" data-line-number="58"></a>
<a class="sourceLine" id="cb17-59" data-line-number="59">    time t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-60" data-line-number="60">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">1</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-61" data-line-number="61">      B.hLimit <span class="dv">20</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-62" data-line-number="62">      B.withAttr <span class="st">&quot;time&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-63" data-line-number="63">      B.str (Tm.formatTime Tm.defaultTimeLocale <span class="st">&quot;%H-%M-%S&quot;</span> t)</a>
<a class="sourceLine" id="cb17-64" data-line-number="64"></a>
<a class="sourceLine" id="cb17-65" data-line-number="65">    getSelectedDetail fn <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-66" data-line-number="66">      <span class="kw">case</span> BL.listSelectedElement <span class="fu">$</span> st <span class="fu">^.</span> stResultsList <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-67" data-line-number="67">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb17-68" data-line-number="68">        <span class="dt">Just</span> (_, e) <span class="ot">-&gt;</span> fn e</a></code></pre></div>
<p><strong>drawUI</strong> renders the state and creates the GUI. At first this may take some getting used to, but you will soon be able to see the GUI structure from the code.</p>
<ul>
<li><code>&lt;=&gt;</code> means horizontal break, i.e. next “line”</li>
<li><code>&lt;+&gt;</code> means “next to”</li>
<li>I often end up formatting code slightly differently to how I would in the other functions to better communicate the structure</li>
<li><p>Create small GUI fragments/“controls” and combine them with <code>&lt;+&gt;</code> and <code>&lt;=&gt;</code></p>
For example <strong>htitle</strong> creates a “title” by
<ul>
<li>Limiting the max width to 20</li>
<li>Setting the attribute to <strong>infoTitle</strong></li>
<li>Displaying the text using <code>B.txt</code> (<code>B.txt</code> displays a Text, <code>B.str</code> displays a string/[char])</li>
</ul></li>
<li><p><code>B.fill ' '</code> is used to get brick to fill to the maximum width (here 60) rather that having the right detail pain growing/shrinking as the data changes.</p></li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">theMap ::</span> <span class="dt">BA.AttrMap</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">theMap <span class="fu">=</span> BA.attrMap V.defAttr [ (BE.editAttr        , V.black <span class="ot">`B.on`</span> V.cyan)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">                              , (BE.editFocusedAttr , V.black <span class="ot">`B.on`</span> V.yellow)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">                              , (BL.listAttr        , V.white <span class="ot">`B.on`</span> V.blue)</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">                              , (BL.listSelectedAttr, V.blue <span class="ot">`B.on`</span> V.white)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">                              , (<span class="st">&quot;infoTitle&quot;</span>        , B.fg V.cyan)</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">                              , (<span class="st">&quot;time&quot;</span>             , B.fg V.yellow)</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">                              ]</a></code></pre></div>
<p>The attribute map is where attributes for the controls and custom attributes are defined. This makes it easy to change how the GUI looks. There is even support <a href="https://hackage.haskell.org/package/brick-0.33/docs/Brick-Themes.html">for themes</a> and basic <a href="https://hackage.haskell.org/package/brick-0.33/docs/Brick-Markup.html">markup</a>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">----------------------------------------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="co">-- | Compare two hoogle results for sorting</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">compareType ::</span> <span class="dt">H.Target</span> <span class="ot">-&gt;</span> <span class="dt">H.Target</span> <span class="ot">-&gt;</span> <span class="dt">Ordering</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">compareType a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  compare (formatResult a) (formatResult b)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6"></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb19-8" data-line-number="8"><span class="co">-- | Search hoogle using the default hoogle database</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">searchHoogle ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">H.Target</span>]</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">searchHoogle f <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  d <span class="ot">&lt;-</span> H.defaultDatabaseLocation </a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  H.withDatabase d (\x <span class="ot">-&gt;</span> pure <span class="fu">$</span> H.searchDatabase x (Txt.unpack f))</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb19-14" data-line-number="14"></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="co">-- | Format the hoogle results so they roughly match what the terminal app would show</span></a>
<a class="sourceLine" id="cb19-16" data-line-number="16"><span class="ot">formatResult ::</span> <span class="dt">H.Target</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">formatResult t <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18">  <span class="kw">let</span> typ <span class="fu">=</span> clean <span class="fu">$</span> H.targetItem t <span class="kw">in</span></a>
<a class="sourceLine" id="cb19-19" data-line-number="19">  <span class="kw">let</span> m <span class="fu">=</span> (clean <span class="fu">.</span> fst) <span class="fu">&lt;$&gt;</span> H.targetModule t <span class="kw">in</span></a>
<a class="sourceLine" id="cb19-20" data-line-number="20">  Txt.pack <span class="fu">$</span> fromMaybe <span class="st">&quot;&quot;</span> m <span class="fu">&lt;&gt;</span> <span class="st">&quot; :: &quot;</span> <span class="fu">&lt;&gt;</span> typ</a>
<a class="sourceLine" id="cb19-21" data-line-number="21">  </a>
<a class="sourceLine" id="cb19-22" data-line-number="22"></a>
<a class="sourceLine" id="cb19-23" data-line-number="23"><span class="ot">clean ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb19-24" data-line-number="24">clean <span class="fu">=</span> unescapeHTML <span class="fu">.</span> stripTags</a>
<a class="sourceLine" id="cb19-25" data-line-number="25"></a>
<a class="sourceLine" id="cb19-26" data-line-number="26"></a>
<a class="sourceLine" id="cb19-27" data-line-number="27"><span class="co">-- | From hoogle source: https://hackage.haskell.org/package/hoogle-5.0.16/docs/src/General-Util.html</span></a>
<a class="sourceLine" id="cb19-28" data-line-number="28"><span class="ot">unescapeHTML ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb19-29" data-line-number="29">unescapeHTML (<span class="ch">&#39;&amp;&#39;</span><span class="fu">:</span>xs)</a>
<a class="sourceLine" id="cb19-30" data-line-number="30">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;lt;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;&lt;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-31" data-line-number="31">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;gt;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;&gt;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-32" data-line-number="32">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;amp;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;&amp;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-33" data-line-number="33">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;quot;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;\&quot;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-34" data-line-number="34">unescapeHTML (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> unescapeHTML xs</a>
<a class="sourceLine" id="cb19-35" data-line-number="35">unescapeHTML [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb19-36" data-line-number="36">  </a>
<a class="sourceLine" id="cb19-37" data-line-number="37"></a>
<a class="sourceLine" id="cb19-38" data-line-number="38"><span class="co">-- | From hakyll source: https://hackage.haskell.org/package/hakyll-4.1.2.1/docs/src/Hakyll-Web-Html.html#stripTags</span></a>
<a class="sourceLine" id="cb19-39" data-line-number="39"><span class="ot">stripTags ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb19-40" data-line-number="40">stripTags []         <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb19-41" data-line-number="41">stripTags (<span class="ch">&#39;&lt;&#39;</span> <span class="fu">:</span> xs) <span class="fu">=</span> stripTags <span class="fu">$</span> drop <span class="dv">1</span> <span class="fu">$</span> dropWhile (<span class="fu">/=</span> <span class="ch">&#39;&gt;&#39;</span>) xs</a>
<a class="sourceLine" id="cb19-42" data-line-number="42">stripTags (x <span class="fu">:</span> xs)   <span class="fu">=</span> x <span class="fu">:</span> stripTags xs</a></code></pre></div>
<p>The remainder of the code is non-brick code for searching and formatting hoogle results</p>
<ul>
<li><strong>compareType</strong> compares two results by formatting them first and then comparing the resulting text</li>
<li><strong>searchHoogle</strong> searches hoogle using the default database</li>
<li><strong>formatResults</strong> formats the hoogle results</li>
<li><strong>unescapeHTML</strong> and <strong>stripTags</strong> are used to get plain text from the HTML. Note that this code comes from the <a href="https://hackage.haskell.org/package/hakyll-4.1.2.1/docs/src/Hakyll-Web-Html.html#stripTags">hakyll</a> and <a href="https://hackage.haskell.org/package/hoogle-5.0.16/docs/src/General-Util.html">hoogle</a> source code</li>
</ul>
<h1 id="section"></h1>
<p>Hopefully this example helps you get started with brick and demonstrates how easy brick makes creating terminal UIs</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://github.com/andrevdm/bhoogle/tree/blog">Code on github</a></li>
<li><a href="https://github.com/andrevdm/bhoogle/releases">Releases with prebuilt linux binaries</a></li>
<li><a href="https://github.com/jtdaugherty/brick/blob/master/docs/guide.rst">Brick user guide</a></li>
<li><a href="https://github.com/jtdaugherty/brick/blob/master/docs/samtay-tutorial.md">Samuel Tay’s brick tutorial</a></li>
<li><a href="https://hackage.haskell.org/package/bhoogle">Latest version on hackage</a> - NB code does not match the annotated source above</li>
<li><a href="https://github.com/andrevdm/bhoogle">Latest version on github</a> - NB code does not match the annotated source above</li>
</ul>

]]></summary>
</entry>
<entry>
    <title>Refactoring exception handling using a free monad</title>
    <link href="http://www.andrevdm.com/posts/2018-01-08-refactor-free.html" />
    <id>http://www.andrevdm.com/posts/2018-01-08-refactor-free.html</id>
    <published>2018-01-08T00:00:00Z</published>
    <updated>2018-01-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January  8, 2018
    
</div>

<h1 id="overview">Overview</h1>
<p>In my <a href="http://www.andrevdm.com/posts/2017-10-31-refactor-away-io.html">previous post</a> I showed how I was managing exceptions by using a “wrapper” around a record of functions. In this post I’ll show how a free monad approach can be used to achieve the same goal and compare the two techniques.</p>
<h1 id="recap">Recap</h1>
<h2 id="requirements">Requirements</h2>
<p>This is the requirement for the example app, which is a pipeline of jobs</p>
<ol type="1">
<li>Job
<ol type="1">
<li>Can run any IO action and as a result these actions can fail with exceptions</li>
<li>This is custom code and can fail for any number of reasons, network errors, disk permissions etc</li>
</ol></li>
<li>Pipeline
<ol type="1">
<li>Must run impure jobs but be as pure as possible itself</li>
<li>Must be able to handle job failure (exceptions)</li>
<li>Supports different storage mechanisms, e.g. on disk for local dev vs cloud for production</li>
</ol></li>
<li>Both jobs and the pipeline should be testable</li>
</ol>
<h2 id="intent">Intent</h2>
<p>The idea was to have a record of operations, different implementations of this record are possible (e.g. run locally vs run in cloud). Then a function is called to create a wrapper function for each record field and a wrapper record is created. The functions in the wrapper record catch all synchronous exceptions and convert them to ExceptT.</p>
<p>The benefit of this approach was that more of the code could be written with pure functions without losing the ability to deal with exceptions that could occur at any point if the operations were specialized to IO.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> m <span class="fu">=</span> <span class="dt">Operations</span> {<span class="ot"> opRead ::</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">                               ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">                               }</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">OperationsWrapper</span> m <span class="fu">=</span> <span class="dt">OperationsWrapper</span> {<span class="ot"> opRead ::</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">                                             ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m ()</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">                                             }</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">                                             </a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">mkOpsWrapper ::</span> (<span class="dt">MonadCatch</span> m) <span class="ot">=&gt;</span> <span class="dt">I2.Operations</span> m <span class="ot">-&gt;</span> <span class="dt">OperationsWrapper</span> m</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">mkOpsWrapper o <span class="fu">=</span> <span class="dt">OperationsWrapper</span> { opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opRead o) <span class="ot">`catch`</span> readError)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">                                   , <span class="fu">...</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                                   }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="ot">    readError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    readError e <span class="fu">=</span> pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrRead</span> <span class="fu">$</span> <span class="st">&quot;Error reading: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">      </a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    <span class="fu">...</span></a></code></pre></div>
<h2 id="observations">Observations</h2>
<p>Here is roughly how it worked</p>
<p><img src="/images/free_wrapper.png" /></p>
<ul>
<li>It seems like a fair amount of code is required to add the exception handling and the wrapper record.</li>
<li>The wrapper is specialized to ExceptT. E.g. The test’s are pure, so using the IO exception handling -&gt; ExceptT pattern is unnecessary</li>
<li>Not only is it a lot of code, but the mkOpsWrapper code is also a little messy</li>
</ul>
<h1 id="a-quick-overview-of-free-monads">A quick overview of free monads</h1>
<p>There are many great articles on what free monads are and how they are implemented, see the links below for some of them. So I wont be going into detail about how they work, rather I’ll show how they can be used. But even if you’ve never used a free monad before, you may well be able to follow along with how I use them here.</p>
<h2 id="what-are-they">What are they?</h2>
<p>A free monad way to build a monad from any functor. The rest of the article demonstrates why you might want to use them.</p>
<h2 id="how-will-this-help">How will this help?</h2>
<p>With a free monad you have a function that builds the free monad structure and one or more functions that interpret/run the AST.</p>
<p><img src="/images/free_free.png" /></p>
<p>As the image above illustrates createAst generates the AST. The AST can then be passed to different interpreters that run the AST. With the record based approach you varied the implementation by choosing which record of functions to pass in. Here you use a different interpreter over the same free monad output to vary the implementation. This results in a clean separation of concerns.</p>
<p>Note that you don’t need to use free monads to implement this pattern. You could create an AST using sum types and have interpreters that run that. The advantage of using free is that since it is monadic you get to use Haskell’s <code>do</code> notation. This makes the code that generates the AST feel “natural”, it is a simple embedded domain specific language</p>
<h1 id="the-free-operations">The free operations</h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Control.Monad.Free</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Control.Monad.Free.TH</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="kw">data</span> <span class="dt">OpsF</span> m next <span class="fu">=</span> <span class="dt">OpRead</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> next)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">                 <span class="fu">|</span> <span class="dt">OpWrite</span> <span class="dt">Text</span> next</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">                 <span class="fu">|</span> <span class="dt">OpLog</span> <span class="dt">Text</span> next</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">                 <span class="fu">|</span> <span class="dt">OpRun</span> <span class="dt">Text</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> m <span class="dt">Text</span>) <span class="dt">Text</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> next)</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">                 <span class="kw">deriving</span> (<span class="dt">Functor</span>)</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">makeFree <span class="ch">&#39;&#39;</span><span class="dt">OpsF</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="kw">type</span> <span class="dt">Ops</span> m <span class="fu">=</span> <span class="dt">Free</span> (<span class="dt">OpsF</span> m)</a></code></pre></div>
<p>I’m using template haskell and DeriveFunctor to do all the heavy lifting. I.e. it creates all the types that lift your operations into the Free monad. Not having to manually do this makes creating free monads pretty simple. If you have not used free before I’d suggest reading some of the articles I’ve linked to below to understand the detail, or you can just follow this pattern for now</p>
<ol type="1">
<li>The last type in the data constructor is the “return type”</li>
<li><code>next</code> is what enables the chaining</li>
<li>If the last type is a function returning next, that means that you can bind the value</li>
</ol>
<p>E.g. for OpWrite</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- data OpsF m next = OpWrite Text next</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">--                  | ...</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">do</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  opWrite <span class="st">&quot;param1&quot;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  opWrite <span class="st">&quot;param2&quot;</span></a></code></pre></div>
<ol type="1">
<li><strong>opWrite</strong> is the function created by template Haskell that constructs a <strong>OpWrite</strong>.</li>
<li><strong>opWrite</strong> takes a single param, the <strong>Text</strong> from “OpWrite Text next”</li>
<li>Since there is a <strong>next</strong> you can have multiple statements in the <strong>do</strong> block</li>
</ol>
<p>E.g. for OpRead</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- data OpsF m next = OpRead (Text -&gt; next)</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">--                  | ...</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">do</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  r <span class="ot">&lt;-</span> opRead </a></code></pre></div>
<ol type="1">
<li><strong>opRead</strong> is the function created by template Haskell that constructs a <strong>OpRead</strong>.</li>
<li><strong>opRead</strong> takes no parameters</li>
<li>We can bind to the Text result the <strong>(Text -&gt; next)</strong> from “OpRead (Text -&gt; next)”</li>
</ol>
<p>And here is an example using several of the DSL operations together</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Ops</span> m) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  opLog <span class="fu">$</span> <span class="st">&quot;starting: &quot;</span> <span class="fu">&lt;&gt;</span> x</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  r <span class="ot">&lt;-</span> opRead</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  opWrite <span class="fu">$</span> r <span class="fu">&lt;&gt;</span> x</a></code></pre></div>
<h2 id="interpreting">Interpreting</h2>
<p>After running the <strong>createAst</strong> function what you have is an AST. opRead etc do nothing on their own. This is the magic of using free with do notation. We go to write normal, pure, code and we end up with an AST.</p>
<p>Given this AST it is possible to write different interpreters that act in various ways. E.g. one for testing, one for local, one for running in the cloud etc.</p>
<h1 id="was-this-not-about-exceptions">Was this not about exceptions?</h1>
<p>Yes, lets write an interpreter that, similar to the record wrapper approach, catches exceptions.</p>
<p>However before starting its worth reiterating a few points about exceptions from my previous post. Remember that it is usually a very bad idea to catch all exceptions as you may end up catching exceptions that you ought not to catch. See <a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in Haskell</a> for a good overview. There are several ways to ensure that you are only catch asynchronous exceptions. In these examples I’m going to be using the <a href="https://hackage.haskell.org/package/safe-exceptions">safe exceptions</a> package which does exactly that.</p>
<p>Right, back to the code. In this example interpreterFile is a function that interprets the AST and uses a file to store/load the state</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- Make sure that the SafeException functions are used</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Protolude</span> <span class="kw">hiding</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Exception.Safe</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">interpreterFile ::</span> (<span class="dt">Ops</span> <span class="dt">IO</span>) <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">interpreterFile o <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">case</span> o <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="dt">Pure</span> a <span class="ot">-&gt;</span> pure a   <span class="co">-- no next action</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    (<span class="dt">Free</span> (<span class="dt">OpRead</span> n)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        r <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> Txt.readFile <span class="st">&quot;data.txt&quot;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">        interpreterFile <span class="fu">$</span> n r  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">      <span class="ot">`catch`</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">        handler <span class="dt">ErrRead</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17"></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    (<span class="dt">Free</span> (<span class="dt">OpWrite</span> t n)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">      <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">        liftIO <span class="fu">$</span> Txt.writeFile <span class="st">&quot;data.txt&quot;</span> t</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">        interpreterFile n  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">      <span class="ot">`catch`</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">        handler <span class="dt">ErrWrite</span></a>
<a class="sourceLine" id="cb6-24" data-line-number="24">      </a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    (<span class="dt">Free</span> (<span class="dt">OpRun</span> name fn t n)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">      <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-27" data-line-number="27">        r <span class="ot">&lt;-</span> lift <span class="fu">$</span> fn t</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">        interpreterFile <span class="fu">$</span> n r  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-29" data-line-number="29">      <span class="ot">`catch`</span></a>
<a class="sourceLine" id="cb6-30" data-line-number="30">        handler (<span class="dt">ErrRunning</span> name)</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">      </a>
<a class="sourceLine" id="cb6-32" data-line-number="32">    (<span class="dt">Free</span> (<span class="dt">OpLog</span> t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-33" data-line-number="33">      putText <span class="fu">$</span> <span class="st">&quot;log: &quot;</span> <span class="fu">&lt;&gt;</span> t</a>
<a class="sourceLine" id="cb6-34" data-line-number="34">      interpreterFile n  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-35" data-line-number="35"></a>
<a class="sourceLine" id="cb6-36" data-line-number="36">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-37" data-line-number="37"><span class="ot">    handler ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">OpsError</span>) <span class="ot">-&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-38" data-line-number="38">    handler ope e <span class="fu">=</span> throwE <span class="fu">.</span> ope <span class="fu">$</span> show e  <span class="co">-- catch exception and use ExceptT&#39;s throwE</span></a></code></pre></div>
<p>The operations are run and any synchronous exception is caught and handled in the ExceptT. This looks pretty similar to the record based approach but I think is simpler.</p>
<h2 id="testing">Testing</h2>
<p>Here is an interpreter for testing which uses a state monad to store/retrieve the state</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TestState</span> <span class="fu">=</span> <span class="dt">TestState</span> {<span class="ot"> tstValue ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">                           ,<span class="ot"> tstLog ::</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">                           } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="ot">interpreterState ::</span> (<span class="dt">Ops</span> (<span class="dt">S.State</span> <span class="dt">TestState</span>)) <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">S.State</span> <span class="dt">TestState</span>) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">interpreterState o <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">case</span> o <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    <span class="dt">Pure</span> a <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">      modify (\s <span class="ot">-&gt;</span> s { tstValue <span class="fu">=</span> a })</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">      tstValue <span class="fu">&lt;$&gt;</span> get</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    (<span class="dt">Free</span> (<span class="dt">OpRead</span> n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">      st <span class="ot">&lt;-</span> S.get </a>
<a class="sourceLine" id="cb7-14" data-line-number="14">      interpreterState <span class="fu">$</span> n (tstValue st)</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">    (<span class="dt">Free</span> (<span class="dt">OpWrite</span> t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">      S.modify (\s <span class="ot">-&gt;</span> s { tstValue <span class="fu">=</span> t } )</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">      interpreterState n</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">      </a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    (<span class="dt">Free</span> (<span class="dt">OpRun</span> _ fn t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">      r <span class="ot">&lt;-</span> fn t</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">      interpreterState <span class="fu">$</span> n r</a>
<a class="sourceLine" id="cb7-23" data-line-number="23">      </a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    (<span class="dt">Free</span> (<span class="dt">OpLog</span> t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">      S.modify (\(<span class="dt">TestState</span> s ls) <span class="ot">-&gt;</span> <span class="dt">TestState</span> s <span class="fu">$</span> ls <span class="fu">&lt;&gt;</span> [t])</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">      interpreterState n</a></code></pre></div>
<p>Compare that to the previous approach’s tests</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">testPipeline ::</span> [<span class="dt">I2.Job</span> (<span class="dt">S.State</span> <span class="dt">Text</span>)] <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">S.State</span> <span class="dt">Text</span> (<span class="dt">Either</span> <span class="dt">I3.OpsError</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">testPipeline jobs initial <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">let</span> ops <span class="fu">=</span> <span class="dt">I3.OperationsWrapper</span> { I3.opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                                     r <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> r</a></code></pre></div>
<p>The big advantage here is that the tests are no longer forced to use ExceptT. Each interpreter, for testing or otherwise, can use whatever stack is appropriate</p>
<h1 id="problems">Problems</h1>
<p>As always there are trade offs, see the <a href="https://markkarpov.com/post/free-monad-considered-harmful.html">Free monad considered harmful</a> article for example. While some of these issues can be address (e.g. see church encoding below) it is worth considering alternatives.</p>
<p>Personally, so far, I’ve found free to be a great fit for what I need (e.g. selecting implementation not based on type), but its definitely worth deciding on a case by case basis</p>
<h1 id="church-encoding">Church encoding</h1>
<p>The <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-Church.html">Control.Monad.Free.Church</a> package handles church encoding of a free monad. This can be important to do because, as it says in <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-Church.html">Control.Monad.Free.Church</a>:</p>
<p><em><code>Even if the Haskell runtime optimizes some of the overhead through laziness and generational garbage collection, the asymptotic runtime is still quadratic. On the other hand, if the Church encoding is used, the tree only needs to be constructed once.</code></em></p>
<p>Given how easy this package makes church encoding, and how bad O(n^2) performance can be, it is almost always a good idea to do the encoding.</p>
<p><em>(I originally found getting the types correct for Church encoding a bit tricky. This <a href="https://github.com/queertypes/free-tutorial">Free monad and church encoding example</a> helped clear up a lot of the confusion for me. Be sure to look at it as well if my explanation below does not help you).</em></p>
<p>To get Church encoding, the only requirement is that you use a MonadFree constraint rather than your more specific data type for the function that generates the DSL.</p>
<p>In the example above createAst looked like this.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Ops</span> m) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a></code></pre></div>
<p>The problem is that I’ve used the “<code>Ops m</code>” type, rather than MonadFree.</p>
<p>Here is what it should look like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadFree</span> (<span class="dt">OpsF</span> m) a) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span> m] <span class="ot">-&gt;</span> a <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a></code></pre></div>
<p>The important parts being</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadFree</span> (<span class="dt">OpsF</span> m) a) <span class="ot">=&gt;</span> <span class="fu">...............</span> <span class="ot">-&gt;</span> a <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a></code></pre></div>
<ul>
<li>Change from Ops to OpsF</li>
<li>Add “<code>MonadFree (...) a</code>”</li>
</ul>
<p>This is how it would be run without Church encoding</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="co">-- Example in IO with exception</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="kw">let</span> ioJobs <span class="fu">=</span> [ <span class="dt">Job</span> <span class="st">&quot;j1&quot;</span> ioJob1</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">               , <span class="dt">Job</span> <span class="st">&quot;j2&quot;</span> ioJob2</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">               , <span class="dt">Job</span> <span class="st">&quot;j3&quot;</span> ioJob3</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">               ]</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  a <span class="ot">&lt;-</span> runExceptT <span class="fu">$</span> interpreterFile <span class="fu">$</span> createAst <span class="st">&quot;test1&quot;</span> ioJobs</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  print a</a></code></pre></div>
<p>And this is how its run with Church encoding using <code>improve</code> from Control.Monad.Free.Church</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="co">-- Example in IO with exception</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">let</span> ioJobs <span class="fu">=</span> [ <span class="dt">Job</span> <span class="st">&quot;j1&quot;</span> ioJob1</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">               , <span class="dt">Job</span> <span class="st">&quot;j2&quot;</span> ioJob2</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">               , <span class="dt">Job</span> <span class="st">&quot;j3&quot;</span> ioJob3</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">               ]</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb13-9" data-line-number="9">        <span class="co">-- Note that createAst must be run inline here to avoid an error about the monad constraints</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  ai <span class="ot">&lt;-</span> runExceptT <span class="fu">$</span> interpreterFile (C.improve <span class="fu">$</span> createAst <span class="st">&quot;test1&quot;</span> ioJobs)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  print ai</a></code></pre></div>
<p>That is all it takes, we can now use free without O(n^2) concerns</p>
<h1 id="conclusion">Conclusion</h1>
<p>Free monads give us a nice way to separate pure and impure code while also handling exceptions. Overall I think this approach is more flexible and easier to read that the record of functions approach.</p>
<h1 id="links">Links</h1>
<ul>
<li><p><a href="https://gist.github.com/andrevdm/4d1625e6504e3f1fef9ee9fbc1298b34">Code on github (gist)</a></p></li>
<li>Free monad tutorials
<ul>
<li><a href="http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html">Purify code using free monads</a></li>
<li><a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why free monads matter</a></li>
<li><a href="http://www.parsonsmatt.org/2017/09/22/what_does_free_buy_us.html">What does Free buy us?</a></li>
</ul></li>
<li><a href="https://hackage.haskell.org/package/free">Control.Monad.Free</a></li>
<li><a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-Church.html">Control.Monad.Free.Church</a></li>
<li><a href="https://markkarpov.com/post/free-monad-considered-harmful.html">Free monad considered harmful</a></li>
<li><a href="https://github.com/queertypes/free-tutorial">Free monad and church encoding example</a></li>
<li><p><a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in Haskell</a></p></li>
<li><p><a href="https://gist.github.com/brandonhamilton/2a87b8d66aa6bd7872c3848cd99318e1">Port of example code to use operational monad by @brandonhamilton</a></p></li>
</ul>

]]></summary>
</entry>
<entry>
    <title>Refactoring to pure code and dealing with exceptions.</title>
    <link href="http://www.andrevdm.com/posts/2017-10-31-refactor-away-io.html" />
    <id>http://www.andrevdm.com/posts/2017-10-31-refactor-away-io.html</id>
    <published>2017-10-31T00:00:00Z</published>
    <updated>2017-10-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October 31, 2017
    
</div>

<h1 id="overview">Overview</h1>
<p><em>(TL;DR: I use a record of functions &amp; a record of wrapper functions that catch all synchronous exceptions and convert to ExceptT for the pure code) </em></p>
<p>See also the followup post on <a href="2018-01-08-refactor-free.html">using Free as an alternative</a></p>
<p>This is a quick overview of how I refactored one of my first production haskell application that had a majority of IO code to be more pure. I’ve seen several approaches with different trade offs but none that fit exactly what I was doing 100%.</p>
<p>The design I needed was a pipeline of actions that needs to be performed, where each job in the pipeline is considered user code (think plugin)</p>
<p>Some design notes</p>
<ol type="1">
<li>Job
<ol type="1">
<li>Can run any IO action and as a result these actions can fail with exceptions</li>
<li>I don’t want to constrain what a job can do in any way, i.e. full IO access</li>
<li>This is custom code and can fail for any number of reasons, network errors, disk permissions etc</li>
</ol></li>
<li>Pipeline
<ol type="1">
<li>Must run impure jobs but be as pure as possible itself</li>
<li>Must be able to handle job failure (exceptions)</li>
<li>Supports different storage mechanisms, e.g. on disk for local dev vs cloud for production</li>
</ol></li>
</ol>
<p>Both jobs and the pipeline should be testable</p>
<h1 id="step-1---just-use-io-and-refactor-later">Step 1 - Just use IO and refactor later</h1>
<h2 id="jobs">Jobs</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Job</span> <span class="fu">=</span> <span class="dt">Job</span> {<span class="ot"> jobName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">               ,<span class="ot"> jobFn ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">               }</a></code></pre></div>
<p>A job has a name and an IO action to perform. In this demo a job takes a text value, does some transformation and returns a resulting text value. In a real world application this record would contain more operations and probably be polymorphic</p>
<h2 id="operations">Operations</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> <span class="fu">=</span> <span class="dt">Operations</span> {<span class="ot"> opRead ::</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                             ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                             }</a></code></pre></div>
<p>Operations is a record of operations that the pipeline uses to persist job results. I.e. this is the pluggable storage and related functions</p>
<p>I’ve chosen to pass a record of functions rather than using a type class. For discussion on records vs typeclass for this type of design see</p>
<ol type="1">
<li><a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">ReaderT design pattern</a></li>
<li><a href="https://github.com/lexi-lambda/mtl-style-example">mtl-style-example: A small, self-contained example of using mtl style to unit test effectful code in a pure way</a></li>
<li><a href="https://chris-martin.org/2017/interfaces-and-records">Java interfaces map to Haskell records</a></li>
</ol>
<p>A pluggable set of operations feels more natural as a record of functions to me than a typeclass. For me this is because they are just a named set of functions rather than something that has a set of rules (“an algebra”).</p>
<h2 id="pipeline">Pipeline</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">runPipeline ::</span> <span class="dt">Operations</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">runPipeline ops init jobs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  opWrite ops init</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  id <span class="ot">&lt;-</span> foldlM runJob <span class="dv">0</span> jobs</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  putText <span class="fu">$</span> <span class="st">&quot;\nfinal job id = &quot;</span> <span class="fu">&lt;&gt;</span> show id</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  opRead ops</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    runJob (id<span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dt">Job</span> name fn) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">      putText <span class="fu">$</span> <span class="st">&quot;running job: &quot;</span> <span class="fu">&lt;&gt;</span> name</a>
<a class="sourceLine" id="cb3-12" data-line-number="12"></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">      prev <span class="ot">&lt;-</span> opRead ops</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">      r <span class="ot">&lt;-</span> fn prev</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">      opWrite ops r</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">      </a>
<a class="sourceLine" id="cb3-17" data-line-number="17">      putText <span class="fu">$</span> <span class="st">&quot;  = &quot;</span> <span class="fu">&lt;&gt;</span> r</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">      putText <span class="st">&quot;  ----&quot;</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">      pure <span class="fu">$</span> id <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>Run each job in order, for each job</p>
<ol type="1">
<li>Load the last data</li>
<li>Run the job</li>
<li>Store the result</li>
<li>Pass a unique (for the run) id to each step</li>
</ol>
<p><em>(Obviously I could simply pass the previous state as part of the fold and do away with the load and store. Its done this way for the demonstration)</em></p>
<h2 id="storage">Storage</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">Txt</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step1.Impl1</span> <span class="kw">as</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">readFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">readFileOp <span class="fu">=</span> Txt.readFile</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="ot">writeFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">writeFileOp <span class="fu">=</span> Txt.writeFile</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="ot">mkFileOps ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">I.Operations</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">mkFileOps p <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="dt">I.Operations</span> { I.opRead <span class="fu">=</span> readFileOp p</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">               , I.opWrite <span class="fu">=</span> writeFileOp p</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">               }</a></code></pre></div>
<p>Here the operations are implemented by reading and writing to a file, using Data.Text.IO. The <a href="https://github.com/andrevdm/refactorAwayIO">example code</a> in github also has a STM backed storage implementation</p>
<h2 id="example-jobs">Example jobs</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">job1 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">job1 v <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  putText <span class="st">&quot;in job1&quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  pure <span class="fu">$</span> <span class="st">&quot;1:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">job2 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">job2 v <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  putText <span class="st">&quot;in job2&quot;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  void <span class="fu">.</span> throwIO <span class="fu">$</span> <span class="dt">DemoException</span> <span class="st">&quot;oops&quot;</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  pure <span class="fu">$</span> <span class="st">&quot;2:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="ot">job3 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">job3 v <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  putText <span class="st">&quot;in job3&quot;</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  pure <span class="fu">$</span> <span class="st">&quot;3:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17"></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="kw">newtype</span> <span class="dt">DemoException</span> <span class="fu">=</span> <span class="dt">DemoException</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"></a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">DemoException</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">  show (<span class="dt">DemoException</span> s) <span class="fu">=</span> Txt.unpack s</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">DemoException</span></a></code></pre></div>
<p>These are three example jobs. Notice that the second one explicitly throws an exception. A job can explicitly throw an exception like this or it could throw an exception on failure (e.g. network error)</p>
<h2 id="running">Running</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span> <span class="kw">hiding</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step1.Impl1</span> <span class="kw">as</span> <span class="dt">I1</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step1.Storage1</span> <span class="kw">as</span> <span class="dt">S1</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I1.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">             , <span class="dt">I1.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">             , <span class="dt">I1.Job</span> <span class="st">&quot;j3&quot;</span> job3</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">             ]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">let</span> ops <span class="fu">=</span> S1.mkFileOps</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  r <span class="ot">&lt;-</span> I1.runPipeline ops <span class="st">&quot;0&quot;</span> jobs</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  putText r</a></code></pre></div>
<p>When run this will fail with an exception in job 2 and result in the application terminating</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb7-1" data-line-number="1">---------</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"> Demo1: in memory</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">---------</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">running job: j1</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">in job1</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  = 1:0</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  ----</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">running job: j2</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">in job2</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="fu">Exception: </span>oops</a></code></pre></div>
<h1 id="step-2---monad-m">Step 2 - (Monad m)</h1>
<p>So far the example has a working pipeline but everything is in IO and it does nothing about exceptions.</p>
<p>Lets remove some IO constraints.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Step2.Impl2</span> ( <span class="dt">Operations</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                   , <span class="dt">Job</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                   , runPipeline</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                   ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="kw">data</span> <span class="dt">Operations</span> m <span class="fu">=</span> <span class="dt">Operations</span> {<span class="ot"> opRead ::</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">                               ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">                               ,<span class="ot"> opLog ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">                               }</a>
<a class="sourceLine" id="cb8-17" data-line-number="17"></a>
<a class="sourceLine" id="cb8-18" data-line-number="18"></a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="kw">data</span> <span class="dt">Job</span> m <span class="fu">=</span> <span class="dt">Job</span> {<span class="ot"> jobName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">                 ,<span class="ot"> jobFn ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">                 }</a>
<a class="sourceLine" id="cb8-22" data-line-number="22"></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="ot">runPipeline ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Operations</span> m <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span> m] <span class="ot">-&gt;</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">runPipeline ops init jobs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  opWrite ops init</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">  id <span class="ot">&lt;-</span> foldlM runJob <span class="dv">0</span> jobs</a>
<a class="sourceLine" id="cb8-27" data-line-number="27"></a>
<a class="sourceLine" id="cb8-28" data-line-number="28">  opLog ops <span class="fu">$</span> <span class="st">&quot;\nfinal job id = &quot;</span> <span class="fu">&lt;&gt;</span> show id</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">  opRead ops</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"></a>
<a class="sourceLine" id="cb8-31" data-line-number="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32">    runJob (id<span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dt">Job</span> name fn) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-33" data-line-number="33">      opLog ops <span class="fu">$</span> <span class="st">&quot;running job: &quot;</span> <span class="fu">&lt;&gt;</span> name</a>
<a class="sourceLine" id="cb8-34" data-line-number="34"></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">      prev <span class="ot">&lt;-</span> opRead ops</a>
<a class="sourceLine" id="cb8-36" data-line-number="36">      r <span class="ot">&lt;-</span> fn prev</a>
<a class="sourceLine" id="cb8-37" data-line-number="37">      opWrite ops r</a>
<a class="sourceLine" id="cb8-38" data-line-number="38">      </a>
<a class="sourceLine" id="cb8-39" data-line-number="39">      opLog ops <span class="fu">$</span> <span class="st">&quot;  = &quot;</span> <span class="fu">&lt;&gt;</span> r</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">      opLog ops <span class="st">&quot;  ----&quot;</span></a>
<a class="sourceLine" id="cb8-41" data-line-number="41"></a>
<a class="sourceLine" id="cb8-42" data-line-number="42">      pure <span class="fu">$</span> id <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>Here I’ve removed all explicit IO actions for the pipeline types and functions</p>
<h2 id="opread">opRead</h2>
<p>opRead has changed from</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">opRead ::</span> <span class="dt">IO</span> <span class="dt">Text</span></a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">opRead ::</span> m <span class="dt">Text</span></a></code></pre></div>
<p>i.e. the type no longer explicitly says IO but now accepts any kind * -&gt; * (e.g. any monad)</p>
<h2 id="operations-1">Operations</h2>
<p>The Operations type has changed from</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> <span class="fu">=</span> <span class="dt">Operations</span> {<span class="fu">..</span>}</a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> m <span class="fu">=</span> <span class="dt">Operations</span> {<span class="fu">..</span>}</a></code></pre></div>
<h2 id="runpipeline">runPipeline</h2>
<p>runPipeline has changed from</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">runPipeline ::</span> <span class="dt">Operations</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">runPipeline ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Operations</span> m <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span> m] <span class="ot">-&gt;</span> m <span class="dt">Text</span></a></code></pre></div>
<p>There is a constraint saying that m must be a monad. This is so that we can use the monadic type class (pure, &gt;&gt;= etc)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">(<span class="dt">Monad</span> m) <span class="ot">=&gt;</span></a></code></pre></div>
<p>And we use the <strong>Operations m</strong> and <strong>Job m</strong> types</p>
<h2 id="storage-1">Storage</h2>
<p>These changes mean that the pipeline and its types no longer require IO</p>
<p>The storage implementations need IO so you specialize the m to IO. Apart from that nothing changes I.e.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">readFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">readFileOp <span class="fu">=</span> Txt.readFile</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">writeFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">writeFileOp <span class="fu">=</span> Txt.writeFile</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="ot">mkFileOps ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Operations</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">mkFileOps p <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">  <span class="dt">Operations</span> { opRead <span class="fu">=</span> readFileOp p</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">             , opWrite <span class="fu">=</span> writeFileOp p</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">             , opLog <span class="fu">=</span> putText</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">             }</a></code></pre></div>
<p>Notice that I added <strong>opLog</strong>. It is used for logging rather than calling putText etc which can not be done since there is no IO (or MonadIO constraint)</p>
<h2 id="running-1">Running</h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span> <span class="kw">hiding</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Storage2</span> <span class="kw">as</span> <span class="dt">S2</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Impl2</span> <span class="kw">as</span> <span class="dt">I2</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I2.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">             , <span class="dt">I2.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">             , <span class="dt">I2.Job</span> <span class="st">&quot;j3&quot;</span> job3</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">             ]</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  <span class="kw">let</span> ops <span class="fu">=</span> S2.mkFileOps</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">  r <span class="ot">&lt;-</span> I2.runPipeline ops <span class="st">&quot;0&quot;</span> jobs</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  putText r</a></code></pre></div>
<p>Note that we can use the same jobs as we did in step 1 (job1, job2 and job3).</p>
<h2 id="and-so">And… so?</h2>
<p>This simple change has already resulted in a few nice improvements.</p>
<ol type="1">
<li>The pipeline code is pure, no IO at all</li>
<li>This means that the pipeline can already be tested as pure code.</li>
<li>The pipeline can be specialized to IO and can run IO jobs or as above kept pure when testing or running non-IO jobs</li>
<li>The types are now compatible with monad transformers since a concrete monad type was not specified</li>
<li>The jobs can be used as is.</li>
</ol>
<p>That is a pretty good for not much extra work. However I have done nothing about exceptions and when this code runs it still breaks with an exception as it did before.</p>
<h1 id="step-3---exceptions">Step 3 - Exceptions</h1>
<p>If you have not seen the <a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in haskell</a> article, I think its worth looking at before continuing. The two points from the article I want to address are</p>
<ol type="1">
<li>Mixing ExceptT and exceptions mean you have to deal with multiple failure modes</li>
<li>When you are using IO anything can fail and throw an exception</li>
</ol>
<p>Not only must we accept that jobs can fail with exceptions but we should treat this as normal. I.e. when someone is writing a IO job they should be able to throw exceptions and the pipeline should handle them.</p>
<p>However I don’t want the pure code to have to deal with exceptions, I’d much rather deal with an Either type there. Which may seem to contradict point 1 from the article above. But this is not the case, remember that jobs perform IO and thus should deal with exceptions and the pipeline is pure and should not, so ExceptT/Either is fine.</p>
<p>And so we need something to bridge the gap between the two worlds.</p>
<h2 id="the-wrapper-type">The wrapper type</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">OpsError</span> <span class="fu">=</span> <span class="dt">ErrRead</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">              <span class="fu">|</span> <span class="dt">ErrWrite</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">              <span class="fu">|</span> <span class="dt">ErrLogging</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">              <span class="fu">|</span> <span class="dt">ErrRunning</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">              <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6"></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="kw">data</span> <span class="dt">OperationsWrapper</span> m <span class="fu">=</span> <span class="dt">OperationsWrapper</span> {<span class="ot"> opRead ::</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">                                             ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m ()</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">                                             ,<span class="ot"> opLog ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m ()</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">                                             ,<span class="ot"> opRun ::</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> m <span class="dt">Text</span>) <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">                                             }</a></code></pre></div>
<p>OperationsWrapper is a record with a wrapper function for each function from the Operations record. Each function will run the corresponding Operation function, catch any synchronous exception and covert it into an ExceptT transformer type. (See the section on catching all exceptions below)</p>
<p>The code for the wrapper is not terribly pretty, but I feel its a fair price to pay for separating the two concerns without resorting to any higher level magic (that I’m not comfortable with yet)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">mkOpsWrapper ::</span> (<span class="dt">MonadCatch</span> m) <span class="ot">=&gt;</span> <span class="dt">I2.Operations</span> m <span class="ot">-&gt;</span> <span class="dt">OperationsWrapper</span> m</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">mkOpsWrapper o <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="dt">OperationsWrapper</span> { opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opRead o) <span class="ot">`catch`</span> readError)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">                    , opWrite <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opWrite o t) <span class="ot">`catch`</span> writeError)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">                    , opLog <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opLog o t) <span class="ot">`catch`</span> logError)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                    , opRun <span class="fu">=</span> \fn t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> fn t) <span class="ot">`catch`</span> logError)</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                    }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">    readError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">    readError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb19-11" data-line-number="11">      pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrRead</span> <span class="fu">$</span> <span class="st">&quot;Error reading: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    </a>
<a class="sourceLine" id="cb19-13" data-line-number="13"><span class="ot">    writeError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    writeError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb19-15" data-line-number="15">      pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrWrite</span> <span class="fu">$</span> <span class="st">&quot;Error writing: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">    </a>
<a class="sourceLine" id="cb19-17" data-line-number="17"><span class="ot">    logError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">    logError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb19-19" data-line-number="19">      pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrLogging</span> <span class="fu">$</span> <span class="st">&quot;Error logging: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a></code></pre></div>
<p>Each function works as follows</p>
<ol type="1">
<li><p>Call the “wrapped” corresponding function and on success return the result as a Right value</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opRead o</a></code></pre></div></li>
<li><p>Catch any exception and return it as a Left OpsError</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">...</span> <span class="ot">`catch`</span> readError</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">readError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">readError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrRead</span> <span class="fu">$</span> <span class="st">&quot;Error reading: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a></code></pre></div></li>
</ol>
<h2 id="pipeline-using-the-wrapper">Pipeline using the wrapper</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">runPipeline ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">OperationsWrapper</span> m <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">I2.Job</span> m] <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">runPipeline ops init jobs <span class="fu">=</span> runExceptT <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  opWrite ops init</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  id <span class="ot">&lt;-</span> foldlM runJob <span class="dv">0</span> jobs</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">  opLog ops <span class="fu">$</span> <span class="st">&quot;\nfinal job id = &quot;</span> <span class="fu">&lt;&gt;</span> show id</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  opRead ops</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    runJob (id<span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dt">I2.Job</span> name fn) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">      opLog ops <span class="fu">$</span> <span class="st">&quot;running job: &quot;</span> <span class="fu">&lt;&gt;</span> name</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"></a>
<a class="sourceLine" id="cb22-13" data-line-number="13">      prev <span class="ot">&lt;-</span> opRead ops</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">      r <span class="ot">&lt;-</span> opRun ops fn prev <span class="co">-- don&#39;t just lift, use opRun</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15">      opWrite ops r</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb22-17" data-line-number="17">      opLog ops <span class="fu">$</span> <span class="st">&quot;  = &quot;</span> <span class="fu">&lt;&gt;</span> r</a>
<a class="sourceLine" id="cb22-18" data-line-number="18">      opLog ops <span class="st">&quot;  ----&quot;</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19"></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">      pure <span class="fu">$</span> id <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>The changes from Step2 are</p>
<ol type="1">
<li>The result type is an Either. I.e. failure is now explicit</li>
<li>Its using OperationsWrapper not Operations</li>
<li>It is using the ExceptT monad, so <strong>runExceptT</strong> is used</li>
<li>Each function from the wrapper will abort the monad if it returns a Left (i.e. if the wrapped function throws)</li>
</ol>
<p>Also notice that I added a <strong>opRun</strong> function to wrap the running of the job. If you just lifted the job’s run function, then the exception would not be handled. So we need a wrapper function for this as well.</p>
<h2 id="running-2">Running</h2>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Storage2</span> <span class="kw">as</span> <span class="dt">S2</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Impl2</span> <span class="kw">as</span> <span class="dt">I2</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step3.Impl3</span> <span class="kw">as</span> <span class="dt">I3</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I2.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">             , <span class="dt">I2.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">             , <span class="dt">I2.Job</span> <span class="st">&quot;j3&quot;</span> job3</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">             ]</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb23-15" data-line-number="15">  <span class="kw">let</span> ops <span class="fu">=</span> S2.mkFileOps</a>
<a class="sourceLine" id="cb23-16" data-line-number="16"></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">  r <span class="ot">&lt;-</span> I3.runPipeline (I3.mkOpsWrapper ops) <span class="st">&quot;0&quot;</span> jobs</a>
<a class="sourceLine" id="cb23-18" data-line-number="18"></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">  <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20">    <span class="dt">Right</span> x <span class="ot">-&gt;</span> putText <span class="fu">$</span> <span class="st">&quot;Success: &quot;</span> <span class="fu">&lt;&gt;</span> x</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> putText <span class="fu">$</span> <span class="st">&quot;Exception: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a></code></pre></div>
<p>When run this will catch the exception in job 2 and correctly report the error, i.e. no runtime failure</p>
<pre><code> Demo3: use file
---------
running job: j1
in job1
  = 1:0
  ----
running job: j2
in job2
Exception: ErrLogging &quot;Error logging: oops&quot;</code></pre>
<h1 id="testing">Testing</h1>
<p>For completeness here is an example of how the pipeline can be tested using only pure code. I’m using the State monad (which you may not want to use in production but for my test and this example its just fine). Skip this the section if you are not interested in the tests</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="kw">module</span> <span class="dt">PipelineSpec</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Protolude</span> </a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.Except</span> <span class="kw">as</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.State.Strict</span> <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Impl2</span> <span class="kw">as</span> <span class="dt">I2</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step3.Impl3</span> <span class="kw">as</span> <span class="dt">I3</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14"><span class="ot">spec ::</span> <span class="dt">Spec</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">spec <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  describe <span class="st">&quot;simple pipeline&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-17" data-line-number="17">    it <span class="st">&quot;should run in correct order&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">      <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I2.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb25-19" data-line-number="19">                 , <span class="dt">I2.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">                 ]</a>
<a class="sourceLine" id="cb25-21" data-line-number="21">      </a>
<a class="sourceLine" id="cb25-22" data-line-number="22">      <span class="kw">let</span> (r, _) <span class="fu">=</span> S.runState (testPipeline jobs <span class="st">&quot;0&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb25-23" data-line-number="23">      r <span class="ot">`shouldBe`</span> (<span class="dt">Right</span> <span class="st">&quot;2:1:0&quot;</span>)</a>
<a class="sourceLine" id="cb25-24" data-line-number="24"></a>
<a class="sourceLine" id="cb25-25" data-line-number="25"></a>
<a class="sourceLine" id="cb25-26" data-line-number="26"></a>
<a class="sourceLine" id="cb25-27" data-line-number="27"><span class="ot">testPipeline ::</span> [<span class="dt">I2.Job</span> (<span class="dt">S.State</span> <span class="dt">Text</span>)] <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">S.State</span> <span class="dt">Text</span> (<span class="dt">Either</span> <span class="dt">I3.OpsError</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb25-28" data-line-number="28">testPipeline jobs initial <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-29" data-line-number="29">  <span class="kw">let</span> ops <span class="fu">=</span> <span class="dt">I3.OperationsWrapper</span> { I3.opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-30" data-line-number="30">                                     r <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb25-31" data-line-number="31">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> r</a>
<a class="sourceLine" id="cb25-32" data-line-number="32"></a>
<a class="sourceLine" id="cb25-33" data-line-number="33">                                 , I3.opWrite <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-34" data-line-number="34">                                     put <span class="fu">$</span> t</a>
<a class="sourceLine" id="cb25-35" data-line-number="35">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> ()</a>
<a class="sourceLine" id="cb25-36" data-line-number="36"></a>
<a class="sourceLine" id="cb25-37" data-line-number="37">                                 , I3.opRun <span class="fu">=</span> \fn t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-38" data-line-number="38">                                     r <span class="ot">&lt;-</span> fn t</a>
<a class="sourceLine" id="cb25-39" data-line-number="39">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> r</a>
<a class="sourceLine" id="cb25-40" data-line-number="40"></a>
<a class="sourceLine" id="cb25-41" data-line-number="41">                                 , I3.opLog <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> ()</a>
<a class="sourceLine" id="cb25-42" data-line-number="42">                                 }</a>
<a class="sourceLine" id="cb25-43" data-line-number="43"></a>
<a class="sourceLine" id="cb25-44" data-line-number="44">  I3.runPipeline ops initial jobs</a>
<a class="sourceLine" id="cb25-45" data-line-number="45"></a>
<a class="sourceLine" id="cb25-46" data-line-number="46"></a>
<a class="sourceLine" id="cb25-47" data-line-number="47"><span class="ot">job1 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">S.State</span> <span class="dt">Text</span>) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb25-48" data-line-number="48">job1 v <span class="fu">=</span> pure <span class="fu">$</span> <span class="st">&quot;1:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb25-49" data-line-number="49"></a>
<a class="sourceLine" id="cb25-50" data-line-number="50"><span class="ot">job2 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">S.State</span> <span class="dt">Text</span>) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb25-51" data-line-number="51">job2 v <span class="fu">=</span> pure <span class="fu">$</span> <span class="st">&quot;2:&quot;</span> <span class="fu">&lt;&gt;</span> v</a></code></pre></div>
<h1 id="notes-on-exceptions">Notes on exceptions</h1>
<h2 id="catching-all-exceptions">Catching all exceptions</h2>
<p>Catching all exceptions is generally considered to be a bad idea. See for example the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#g:4">docs for Control.Exception</a>.</p>
<p>For a thorough discussion of alternatives see <a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions">Catching all exceptions</a> from www.schoolofhaskell.com</p>
<h2 id="safe-exceptions">Safe-exceptions</h2>
<p>In this example I am using the <a href="https://hackage.haskell.org/package/safe-exceptions-0.1.6.0/docs/Control-Exception-Safe.html">safe-exceptions package</a>. The catch function comes from Control.Exception.Safe not Control.Exception so only synchronous exceptions are caught. Take a look at the <a href="https://github.com/andrevdm/refactorAwayIO">source code</a> to see the cabal file and the explicit imports from Control.Exception.Safe</p>
<h2 id="using-async">Using async</h2>
<p>Another approach that <a href="https://twitter.com/thumphriees">@thumphriees</a> pointed out to me on twitter (and is discussed in the “Catching All Exceptions” article) is to use the async library to help with exceptions. This is the approach I’ll probably be using with the production version of this code as it for almost no extra cost gives me simple timeout and cancellation control.</p>
<p>As you can see from the code below this is a pretty simple to use</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">demoAsyncCatch ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">demoAsyncCatch <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  r <span class="ot">&lt;-</span> async jobBad <span class="fu">&gt;&gt;=</span> waitCatch</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="dt">Right</span> _ <span class="ot">-&gt;</span> putText <span class="st">&quot;demo async - Right&quot;</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> putText <span class="fu">$</span> <span class="st">&quot;demo async - Left: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb26-8" data-line-number="8"></a>
<a class="sourceLine" id="cb26-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    jobBad <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-11" data-line-number="11">      putText <span class="st">&quot;in jobBad&quot;</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12">      void <span class="fu">.</span> throwIO <span class="fu">$</span> <span class="dt">DemoException</span> <span class="st">&quot;oops&quot;</span></a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<ul>
<li>The wrapper record separates the pure and effectful worlds and converts all synchronous IO exceptions into Eithers.</li>
<li>Passing around a record of functions is a alternative to using a typeclass and I believe makes more sense in many cases.</li>
<li>It is not that hard to refactor much of the impure code from a codebase</li>
</ul>
<p>The obvious downside to this method is that you end up with boilerplate code for the wrapper. You’ll have to decide on if this is a problem for you or not. For me this is working really well so far.</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://github.com/andrevdm/refactorAwayIO">Sample code on github</a></li>
<li><a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in haskell</a></li>
<li><a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">ReaderT design pattern</a></li>
<li><a href="https://github.com/lexi-lambda/mtl-style-example">mtl-style-example: A small, self-contained example of using mtl style to unit test effectful code in a pure way</a></li>
<li><a href="https://chris-martin.org/2017/interfaces-and-records">Java interfaces map to Haskell records</a></li>
<li><a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#g:4">docs for Control.Exception</a></li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions">Catching all exceptions</a></li>
<li><a href="https://hackage.haskell.org/package/safe-exceptions-0.1.6.0/docs/Control-Exception-Safe.html">safe-exceptions package</a></li>
</ul>
<p><img src="/images/pumpkin.png" /></p>

]]></summary>
</entry>
<entry>
    <title>Raspbery Pi GPIO using PureScript</title>
    <link href="http://www.andrevdm.com/posts/2016-10-05-purescript-raspberrypi-gpio.html" />
    <id>http://www.andrevdm.com/posts/2016-10-05-purescript-raspberrypi-gpio.html</id>
    <published>2016-10-05T00:00:00Z</published>
    <updated>2016-10-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October  5, 2016
    
</div>

<h1 id="overview">Overview</h1>
<p>This is a quick overview of how you can use PureScript on a RaspberryPi to do GPIO</p>
<h2 id="installing-node-js">Installing Node JS</h2>
<p>The version of NodeJs available in most of the distros is quite old. There are a few ways to get a new version. Personally I found that installing the same version of node that I have on my desktop on the pi worked best. To do this get the version you need from <a href="https://nodejs.org/dist/" class="uri">https://nodejs.org/dist/</a>.</p>
<p>Then run the commands with the appropriate version numbers</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">tar</span> -xvf node-v4nnn</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="bu">cd</span> node-v4nnn</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">sudo</span> cp -R . /usr/local</a></code></pre></div>
<p>if you prefer to get the latest, and a more automated install, then you can follow the instructions here <a href="http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/">Beginner’s Guide to Installing Node.js on a Raspberry Pi</a></p>
<h2 id="purescript-on-the-pi">PureScript on the Pi</h2>
<p>PureScript itself does not seem to install on the pi, so you’ll need to compile on a desktop machine and copy the resulting JavaScript files across</p>
<h2 id="raspberry-pi-gpio">Raspberry Pi GPIO</h2>
<p>GPIO can quite easily be done using unix files. This is not particularly fast but it should be more that sufficient for many use cases. It is also simple enough that it can even be done directly from the shell. If you need faster access FFI to one of the broadcom libraries is probably the way to go.</p>
<p>The GPIO ports are exposed here</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">/sys/class/gpio/gpio</span></a></code></pre></div>
<p>To use a GPIO pin for basic IO you need to do the following</p>
<ol type="1">
<li>Ensure that the port is “open”. Write the port number to <code>/sys/class/gpio/export</code></li>
<li>Set the direction by writing “in” or “out” to <code>/sys/class/gpio/gpioNN/direction</code> (where NN is the pin number)</li>
<li>Set the pin value by writing “on” or “off” to <code>/sys/class/gpio/gpioNN/value</code></li>
<li>Read the pin value by reading from <code>/sys/class/gpio/gpioNN/value</code></li>
</ol>
<h2 id="raspberry-pi-pin-numbers">Raspberry Pi Pin numbers</h2>
<p>The Raspberry Pi pin numbers are a little confusing. There are different models of the pi (A, B, B+, rev 2 etc). There are also different numbering schemes i.e. pin numbers, gpio numbers, wiring pi numbers…</p>
<p>When you are looking at existing code or examples make sure you know which scheme is being used.</p>
<p><a href="http://raspi.tv/wp-content/uploads/2014/07/Raspberry-Pi-GPIO-pinouts.png">Here is a good reference</a> showing pin number and GPIO numbers</p>
<h1 id="purescript">PureScript</h1>
<h2 id="gpio-types">GPIO types</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Gpio</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Direction</span> <span class="fu">=</span> <span class="dt">In</span> <span class="fu">|</span> <span class="dt">Out</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">newtype</span> <span class="dt">Pin</span> <span class="fu">=</span> <span class="dt">Pin</span> <span class="dt">Int</span></a></code></pre></div>
<h2 id="dealing-with-the-various-pin-numbering-schemes">Dealing with the various pin numbering schemes</h2>
<p>As shown above the physical pin numbers are used when working with GPIO, so all the functions here work with a pin number (Pin newtype). Then there is a module per board that can be used to map from a logical GPIO number to a pin. In this example I’ve only defined the layout for the Rev 2 A &amp; B P1 boards.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Gpio</span> (<span class="dt">Pin</span> (..))</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">data</span> <span class="dt">GpioPin</span> <span class="fu">=</span> <span class="dt">GpioPin2</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">             <span class="fu">|</span> <span class="dt">GpioPin3</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">             <span class="fu">|</span> <span class="dt">GpioPin4</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">             <span class="fu">|</span> <span class="dt">GpioPin17</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">             <span class="fu">|</span> <span class="dt">GpioPin27</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">             <span class="fu">|</span> <span class="dt">GpioPin22</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">             <span class="fu">|</span> <span class="dt">GpioPin10</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">             <span class="fu">|</span> <span class="dt">GpioPin9</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">             <span class="fu">|</span> <span class="dt">GpioPin11</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">             <span class="fu">|</span> <span class="dt">GpioPin14</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">             <span class="fu">|</span> <span class="dt">GpioPin15</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">             <span class="fu">|</span> <span class="dt">GpioPin18</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">             <span class="fu">|</span> <span class="dt">GpioPin23</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">             <span class="fu">|</span> <span class="dt">GpioPin24</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">             <span class="fu">|</span> <span class="dt">GpioPin25</span></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">             <span class="fu">|</span> <span class="dt">GpioPin8</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">             <span class="fu">|</span> <span class="dt">GpioPin7</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="ot">toPin ::</span> <span class="dt">GpioPin</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">toPin g <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">  <span class="kw">case</span> g <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">    <span class="dt">GpioPin2</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">    <span class="dt">GpioPin3</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    <span class="dt">GpioPin4</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">    <span class="dt">GpioPin17</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">11</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">    <span class="dt">GpioPin27</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">13</span></a>
<a class="sourceLine" id="cb4-29" data-line-number="29">    <span class="dt">GpioPin22</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">15</span></a>
<a class="sourceLine" id="cb4-30" data-line-number="30">    <span class="dt">GpioPin10</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">19</span></a>
<a class="sourceLine" id="cb4-31" data-line-number="31">    <span class="dt">GpioPin9</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">    <span class="dt">GpioPin11</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">23</span></a>
<a class="sourceLine" id="cb4-33" data-line-number="33">    <span class="dt">GpioPin14</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb4-34" data-line-number="34">    <span class="dt">GpioPin15</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb4-35" data-line-number="35">    <span class="dt">GpioPin18</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb4-36" data-line-number="36">    <span class="dt">GpioPin23</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">16</span></a>
<a class="sourceLine" id="cb4-37" data-line-number="37">    <span class="dt">GpioPin24</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">18</span></a>
<a class="sourceLine" id="cb4-38" data-line-number="38">    <span class="dt">GpioPin25</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">22</span></a>
<a class="sourceLine" id="cb4-39" data-line-number="39">    <span class="dt">GpioPin8</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">24</span></a>
<a class="sourceLine" id="cb4-40" data-line-number="40">    <span class="dt">GpioPin7</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">26</span></a></code></pre></div>
<h2 id="gpio">GPIO</h2>
<p>To “open” a port you write the port number to the export file. This function first checks if the port is open</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">open ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">open (<span class="dt">Pin</span> pin) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  e <span class="ot">&lt;-</span> S.exists <span class="fu">$</span> <span class="st">&quot;/sys/class/gpio/gpio&quot;</span> <span class="fu">&lt;&gt;</span> show pin</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">if</span> not e </a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">then</span> </a>
<a class="sourceLine" id="cb5-6" data-line-number="6">      S.writeTextFile <span class="dt">E.ASCII</span> <span class="st">&quot;/sys/class/gpio/export&quot;</span> (show pin)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">      pure unit</a></code></pre></div>
<p>Set a port to be <em>in</em> or <em>out</em>. Remember that you can read a value from a port that is set to be output, you read if the port was set to on or off. Reading from a port set to <em>in</em> means that you are reading the value from the pin, i.e. is the pin being held high or low by an external input.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">setDirection ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> <span class="dt">Direction</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">setDirection (<span class="dt">Pin</span> pin) dir <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">let</span> dirStr <span class="fu">=</span> <span class="kw">case</span> dir <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">                  <span class="dt">In</span> <span class="ot">-&gt;</span> <span class="st">&quot;in&quot;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">                  <span class="dt">Out</span> <span class="ot">-&gt;</span> <span class="st">&quot;out&quot;</span> </a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  S.writeTextFile <span class="dt">E.ASCII</span> <span class="st">&quot;/sys/class/gpio/gpio18/direction&quot;</span> dirStr</a></code></pre></div>
<p>Set an <em>output</em> pin to high or low</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">setValue ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">setValue (<span class="dt">Pin</span> pin) on <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span> val <span class="fu">=</span> <span class="kw">if</span> on <span class="kw">then</span> <span class="st">&quot;1&quot;</span> <span class="kw">else</span> <span class="st">&quot;0&quot;</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  S.writeTextFile <span class="dt">E.ASCII</span> (<span class="st">&quot;/sys/class/gpio/gpio&quot;</span> <span class="fu">&lt;&gt;</span> (show pin) <span class="fu">&lt;&gt;</span> <span class="st">&quot;/value&quot;</span>) val</a></code></pre></div>
<p>Read the current value from the pin</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">getValue ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Boolean</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">getValue (<span class="dt">Pin</span> pin) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  val <span class="ot">&lt;-</span> (Str.trim <span class="fu">&lt;$&gt;</span> S.readTextFile <span class="dt">E.ASCII</span> <span class="st">&quot;/sys/class/gpio/gpio18/value&quot;</span>)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  pure <span class="fu">$</span> val <span class="fu">/=</span> <span class="st">&quot;0&quot;</span></a></code></pre></div>
<h2 id="e.g.-toggle-gpio-24">E.g. Toggle GPIO 24</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">main ::</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">CONSOLE</span>,<span class="ot"> fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">let</span> pin <span class="fu">=</span> R.toPin <span class="dt">R.GpioPin24</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  R.open pin </a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  v <span class="ot">&lt;-</span> R.getValue pin</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  R.setDirection pin <span class="dt">R.Out</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  R.setValue pin <span class="fu">$</span> not v</a></code></pre></div>
<h1 id="building-and-running">Building and running</h1>
<h2 id="build-the-purescript">Build the purescript</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ex">pulp</span> build --optimise --to ripiTest.js</a></code></pre></div>
<p>You then need to copy everything from the output folder to a folder on the pi</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">scp</span> -r ./output pi@192.168.0.99:/home/pi/ripiTest/output</a></code></pre></div>
<p>Finally copy your compiled bundle across</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">scp</span> -r ./ripiTest.js pi@192.168.0.99:/home/pi/ripiTest/</a></code></pre></div>
<p>Note that you only need to copy the <em>output</em> folder again when you add more imports. Otherwise just copy your bundle to save time.</p>
<h2 id="running">Running</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="bu">cd</span> /home/pi/ripiTest</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="fu">sudo</span> node ripiTest.js</a></code></pre></div>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://github.com/andrevdm/raspberryPiGpio">Source code</a></li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Haskell text classification using Tf-Idf</title>
    <link href="http://www.andrevdm.com/posts/2016-09-21-haskell-tfidf.html" />
    <id>http://www.andrevdm.com/posts/2016-09-21-haskell-tfidf.html</id>
    <published>2016-09-21T00:00:00Z</published>
    <updated>2016-09-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 21, 2016
    
</div>

<p>This is part two in a two part blog series about haskell terminal applications, this blog shows a simple text classification implementation using techniques from <a href="2016-09-20-haskell-shell.html">part one</a>.</p>
<h1 id="text-classification-with-tf-idf">Text Classification with Tf-Idf</h1>
<p>There are many ways to classify documents ranging from simple to very complex. The algorithm I’m using here is called Tf-Idf or “term frequency / inverse document frequency”. There are a number of sites that explain how it works better in detail than I would. See for example</p>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">Wikipedia</a></li>
<li><a href="http://www.tfidf.com/">What does tf-idf mean?</a></li>
</ol>
<p>Basically Tf-Idf counts the number of times a term occurs (term frequency) and combines that with a negative weighting for the number of times the term occurs in all categories. This means that common words that exist in multiple categories are going to count less towards the final score.</p>
<p>There are also multiple ways that TfIdf itself can be implemented e.g. with different algorithms for weighting the Tf vs the Idf or using n-grams (where n &gt; 1). I’m going with a pretty simple implementation but even with that I’ve seen pretty accurate results with the classifications I’m doing. I’m primarily using this for classifying short sentences of text. So it has been tested for simple matching on relatively small documents.</p>
<h1 id="the-textclassification-application">The TextClassification application</h1>
<p>You can get the source for TextClassify at <a href="https://github.com/andrevdm/TextClassify" class="uri">https://github.com/andrevdm/TextClassify</a>. The code is reasonably well commented IMO, so I wont go into too much detail here on every line of code</p>
<p>Below I’ll discuss some implementation details not covered by the code comments.</p>
<h1 id="using-the-application">Using the application</h1>
<ol type="1">
<li>The user sets up a directory of text files, one file per category.
<ul>
<li>These files contain the text that each category should match against.</li>
<li>Since, in this implementation, I’m not using n-grams each file is treated as a “bag of words” and newlines etc are ignored.</li>
</ul></li>
<li>Given the set of categories (the training set) the user then provides an input file (or piped via stdin) containing the text to be matched.
<ul>
<li>The data can be provided in plain text or in a CSV</li>
</ul></li>
<li>The application will ‘clean’ the input data and classify it</li>
<li>The results will be written to stdout and can be piped to a file if required</li>
</ol>
<h1 id="using-sed-awk-and-column">Using sed, awk and column</h1>
<p>There are a large number of existing terminal applications so it often makes sense to use this existing functionality as well as writing terminal applications so that they too can be reused.</p>
<h2 id="removing-lines-with-awk">Removing lines with awk</h2>
<p>The CSV files I work with have a header that needs to be removed. Here is a awk script (removePrefix.awk) to do that</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode awk"><code class="sourceCode awk"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">#!/usr/bin/awk -f</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="cf">BEGIN</span> <span class="kw">{</span><span class="bu">FS</span> <span class="op">=</span> <span class="st">&quot;,&quot;</span><span class="op">;</span><span class="kw">}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="bu">NR</span><span class="op">&lt;</span><span class="dv">7</span> <span class="kw">{next}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="bu">NF</span> <span class="kw">{</span> <span class="kw">print</span> <span class="kw">}</span> </a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="cf">END</span> <span class="kw">{</span> <span class="kw">}</span></a></code></pre></div>
<p>This script can be used to pre-process the CSV file</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">removePrevfix.awk</span> souceFile.csv</a></code></pre></div>
<h2 id="cleaning-text-with-sed">Cleaning text with sed</h2>
<p>The higher the quality of the input data to the classification algorithm the better the results will be. Some regular expressions can clean up the input text nicely. Here is a sed script that does this</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sed"><code class="sourceCode sed"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">#!/bin/sed -uf</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">s</span><span class="st">/c</span><span class="ch">\*</span><span class="st">/ /</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">s</span><span class="st">/jan</span><span class="ch">\|</span><span class="st">feb</span><span class="ch">\|</span><span class="st">mar</span><span class="ch">\|</span><span class="st">apr</span><span class="ch">\|</span><span class="st">may</span><span class="ch">\|</span><span class="st">jun</span><span class="ch">\|</span><span class="st">jul</span><span class="ch">\|</span><span class="st">aug</span><span class="ch">\|</span><span class="st">sep</span><span class="ch">\|</span><span class="st">oct</span><span class="ch">\|</span><span class="st">nov</span><span class="ch">\|</span><span class="st">dec/ /</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">s</span><span class="st">/ </span><span class="ch">\+$</span><span class="st">//</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">s</span><span class="st">/</span><span class="ch">\[\(\)</span><span class="st">!\-</span><span class="ch">\/*\\\]</span><span class="st">/ /g</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="er">s/[\.*\/\(\)_,\]/ /g</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">s</span><span class="st">/-/ /</span><span class="dt">g</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">s</span><span class="st">/</span><span class="ch">\t</span><span class="st">/ /</span><span class="dt">g</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">s</span><span class="st">/  </span><span class="ch">\+</span><span class="st">/ /</span><span class="dt">g</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">s</span><span class="st">/ </span><span class="ch">\+$</span><span class="st">//</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">s</span><span class="st">/</span><span class="ch">^</span><span class="st"> </span><span class="ch">\+</span><span class="st">//</span><span class="dt">gi</span></a></code></pre></div>
<p>This sed script removes some common words (the months), removes special characters and multiple spaces. You can customise this or create one per type of input as required. The -u parameter is important as it disables buffering which may interfere with line-by-line processing.</p>
<p>The TextClassification application will start sed and keep it running. A line of input data will be passed to it and the result read back a line at a time.</p>
<h2 id="displaying-csv-results-with-column">Displaying CSV results with column</h2>
<p><code>column</code> can be used to show CSV data as an aligned table in the terminal. I’ll use this later to show the results of the classification.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">cat</span> sourceFile.csv <span class="kw">|</span> <span class="ex">column</span> -s , -t</a></code></pre></div>
<h1 id="command-line-arguments">Command line arguments</h1>
<p><em>See Args.hs</em></p>
<p>As <a href="2016-09-20-haskell-shell.html">part one</a> showed I’m using <a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a> to parse the command line arguments.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Arguments</span> <span class="fu">=</span> <span class="dt">Arguments</span> {<span class="ot">train ::</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Path to training data&quot;</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">                           ,<span class="ot">input ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Input file to categorise. If missing stdin will be used&quot;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">                           ,<span class="ot">parser ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser type, defaults to lines. Options are lines/detail/csv&quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">                           ,<span class="ot">popts ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser options&quot;</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">                           ,<span class="ot">clean ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Options name of text cleaner - see docs&quot;</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">                           } <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">ParseRecord</span> <span class="dt">Arguments</span></a></code></pre></div>
<p>This is the resulting help text from these arguments</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb6-1" data-line-number="1">  Usage: txtcls --train STRING [--input STRING] [--parser TEXT] [--popts TEXT]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">                [--clean TEXT]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  Available options:</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    -h,--help                Show this help text</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    --train TEXT             Path to training data</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    --input TEXT             Input file to categorise. If missing stdin will be</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">                             used</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    --parser TEXT            Parser type, defaults to lines. Options are</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">                             lines/detail/csv</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    --popts TEXT             Parser options</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    --clean TEXT             Options name of text cleaner - see docs</a></code></pre></div>
<p>These arguments are then interpreted and stored in the Options type</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Options</span> {<span class="ot">trainingPath ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">                       ,<span class="ot">parserType ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">                       ,<span class="ot">parserOptions ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                       ,<span class="ot">txtCleaner ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">                       ,<span class="ot">hin ::</span> <span class="dt">Handle</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">                       ,<span class="ot">hout ::</span> <span class="dt">Handle</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">                       } </a></code></pre></div>
<h2 id="input-handle">Input handle</h2>
<p>hin is set to the handle of the input stream, stdin if no <code>--input</code> parameter is present else the handle for the file</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">hin_ <span class="ot">&lt;-</span> <span class="kw">case</span> unHelpful <span class="fu">$</span> input args <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">           <span class="dt">Just</span> t <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb8-3" data-line-number="3">             openFile (Txt.unpack t) <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">           <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              pure stdin</a></code></pre></div>
<h1 id="text-cleaning-with-the-cleaning-script">Text cleaning with the cleaning script</h1>
<p>Above I showed a sed that could be used to clean the input text. However because this application can use a CSV as the input it can’t simply apply the cleaning to the entire file or even an entire line. Only the text being classified should be cleaned. To do this an instance of sed is started and fed the text to clean one line at a time. (Actually any app could be used as long as it reads and writes one line at a time). The name of the app / script to use is defined by the <code>--clean</code> parameter</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">-- | Build a &#39;cleaner&#39;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">getCleaner ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">getCleaner mcmd <span class="fu">=</span> </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">case</span> mcmd <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="co">-- | The cleaner uses the extenal process to do the actual cleaning. One line is writtent to the processes&#39; stdin and then a value is read from its stdout </span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="dt">Just</span> cmd <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      (<span class="dt">Just</span> inp, <span class="dt">Just</span> outp, _, phandle) <span class="ot">&lt;-</span> createProcess (proc (Txt.unpack cmd) []) { std_out <span class="fu">=</span> <span class="dt">CreatePipe</span>, std_in <span class="fu">=</span> <span class="dt">CreatePipe</span> }</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      hSetBuffering outp <span class="dt">NoBuffering</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">      hSetBuffering inp <span class="dt">LineBuffering</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">      pure <span class="fu">$</span> cleanText inp outp</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    <span class="co">-- | No external cleaner. Just make the text lower case</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">      pure <span class="fu">$</span> pure <span class="fu">.</span> Txt.toLower</a>
<a class="sourceLine" id="cb9-14" data-line-number="14"></a>
<a class="sourceLine" id="cb9-15" data-line-number="15"><span class="co">-- | Used by getCleaner to build a curried cleaner function</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="ot">cleanText ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">cleanText inp outp txt <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">  hPutStrLn inp <span class="fu">$</span> Txt.unpack (Txt.toLower txt)</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  pure <span class="fu">.</span> Txt.pack <span class="fu">=&lt;&lt;</span> hGetLine outp</a></code></pre></div>
<p>The <strong>getCleaner</strong> function is passed (the optional) name of the cleaner script. If a script was specified then a processes is started and a curried <strong>cleanText</strong> function is returned as the cleaning function. If no script was specified then the returned cleaning function simply performs a toLower on the text.</p>
<p><strong>cleanText</strong> writes a line to the input handle for the process and then immediately reads the response line.</p>
<h1 id="reading-the-input-data">Reading the input data</h1>
<p>TextClassifier has three parsers</p>
<ol type="1">
<li>CSV - one of the columns is the data column</li>
<li>Lines - each line is the data</li>
<li>Detail - same as line but additional information is printed for each input line</li>
</ol>
<p>whileM_ is used to read a line of input at a time. The line is then passed to the appropriate parsers, i.e. CSV, line or detail.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- | Read input a line at a time and pass it to the parser</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">whileM_ (not <span class="fu">&lt;$&gt;</span> <span class="dt">IO</span><span class="fu">.</span>hIsEOF (Args.hin opts)) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="co">-- | line of data</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  origChars <span class="ot">&lt;-</span> <span class="dt">IO</span><span class="fu">.</span>hGetLine <span class="fu">$</span> Args.hin opts</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">let</span> origLine <span class="fu">=</span> Txt.pack origChars</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="co">-- | parse the line and get the results to display</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  parsed <span class="ot">&lt;-</span> <span class="kw">case</span> parser <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">              <span class="co">---</span></a></code></pre></div>
<h1 id="parsing-the-csv-data">Parsing the CSV Data</h1>
<p><em>See ClassifyCsv.hs and Classify.hs</em></p>
<p>I’m using <a href="https://hackage.haskell.org/package/cassava">Cassava</a> to read the CSV file as well as creating the output csv. Since I’m not interpreting any of the data apart from the text to be classified I’m simply reading the CSV as a vector of Text.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">let</span> contents <span class="fu">=</span> BL8.pack <span class="fu">.</span> Txt.unpack <span class="fu">$</span> line <span class="kw">in</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">let</span> parsed <span class="fu">=</span> decode <span class="dt">NoHeader</span><span class="ot"> contents ::</span> <span class="dt">Either</span> [<span class="dt">Char</span>] (<span class="dt">V.Vector</span> [<span class="dt">Text</span>]) <span class="kw">in</span></a></code></pre></div>
<p>Given a vector of Text it is simple to get the column containing the text to classify. The <strong>parseCsvLine</strong> function returns a <strong>ParsedLine a</strong> type which contains the text to be classified.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RawText</span> <span class="fu">=</span> <span class="dt">RawText</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">data</span> <span class="dt">ParsedLine</span> a <span class="fu">=</span> <span class="dt">ParsedLine</span> <span class="dt">RawText</span> a <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Remember that each line of data must be cleaned. Rather than having <strong>parseCsvLine</strong> live in IO it returns a <strong>ParsedLine a</strong> type. The code in Main then calls the cleaner and passes the resulting <strong>CleanedLine a</strong> to <strong>categoriseCsvLine</strong>. This limits the amount of code that needs to be in IO. It also make the code easier to test (e.g. from the REPL) as the two functions can be tested independently.</p>
<h1 id="tf-idf">Tf-Idf</h1>
<h2 id="training-set">Training set</h2>
<p><em>See ClassifyIO.hs</em></p>
<p>The training set is a directory with a file per category. Each file contains the words for that category. To load the files the <strong>loadTrainingSet</strong> function is used</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Category</span> <span class="fu">=</span> <span class="dt">Category</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">data</span> <span class="dt">TrainingSet</span> <span class="fu">=</span> <span class="dt">TrainingSet</span> [(<span class="dt">Category</span>, [<span class="dt">Text</span>])] <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">loadTrainingSet ::</span> <span class="dt">Args.Options</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TrainingSet</span></a></code></pre></div>
<p>All .txt files in the directory are loaded and result in a category of words.</p>
<h2 id="tf-idf-1">Tf-Idf</h2>
<p><em>See TfIdf.hs</em></p>
<p>To review the terminology</p>
<ul>
<li>Term - a single word</li>
<li>Category - category name</li>
<li>Document - a document of terms mapped to their TfIdf value</li>
</ul>
<p>the <strong>train</strong> function takes a <strong>TrainingSet</strong> and creates a <strong>TrainedData</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">-- | A term is a single word</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Term</span> <span class="fu">=</span> <span class="dt">Term</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co">-- | A category name</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">newtype</span> <span class="dt">Category</span> <span class="fu">=</span> <span class="dt">Category</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="co">-- | Term frequency value</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Tf</span> <span class="fu">=</span> <span class="dt">Tf</span> <span class="dt">Double</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="co">-- | Inverse document frequency value</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="kw">newtype</span> <span class="dt">Idf</span> <span class="fu">=</span> <span class="dt">Idf</span> <span class="dt">Double</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="co">-- | The combined Tf and Idf value</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="kw">newtype</span> <span class="dt">TfIdf</span> <span class="fu">=</span> <span class="dt">TfIdf</span> <span class="dt">Double</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="co">-- | A document is a map of terms to TfIdf</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="kw">newtype</span> <span class="dt">Document</span> <span class="fu">=</span> <span class="dt">Document</span> (<span class="dt">Map</span> <span class="dt">Term</span> <span class="dt">TfIdf</span>) <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"></a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="co">-- | Data making up the training set</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="kw">data</span> <span class="dt">TrainingSet</span> <span class="fu">=</span> <span class="dt">TrainingSet</span> [(<span class="dt">Category</span>, [<span class="dt">Text</span>])] <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"><span class="co">-- | The trained data, each category linked to a document</span></a>
<a class="sourceLine" id="cb14-17" data-line-number="17"><span class="kw">data</span> <span class="dt">TrainedData</span> <span class="fu">=</span> <span class="dt">TrainedData</span> [(<span class="dt">Category</span>, <span class="dt">Document</span>)] <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-18" data-line-number="18"></a>
<a class="sourceLine" id="cb14-19" data-line-number="19"></a>
<a class="sourceLine" id="cb14-20" data-line-number="20"><span class="ot">train ::</span> <span class="dt">TrainingSet</span> <span class="ot">-&gt;</span> <span class="dt">TrainedData</span></a></code></pre></div>
<p>Categorising text is handled by the <strong>categorise</strong> function. Given a collection of words it returns the best matching category if one was found. <strong>classifyDetail</strong> returns all possible matches sorted best match first. Both functions use cagegoriseWords to do the actual classification.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- | Classify a line of text and try get the best matching category</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">classify ::</span> <span class="dt">Args.Options</span> <span class="ot">-&gt;</span> <span class="dt">TrainedData</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Category</span>, <span class="dt">Double</span>) <span class="co">-- In Classify.hs</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="co">-- | Classify a line of text and get all matching categories, best first</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="ot">classifyDetail ::</span> <span class="dt">TrainedData</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [(<span class="dt">Category</span>, <span class="dt">Double</span>)] <span class="co">-- In Classify.hs</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="ot">categoriseWords ::</span> <span class="dt">TrainedData</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [(<span class="dt">Category</span>, <span class="dt">Double</span>)]  <span class="co">-- in TfIdf.hs</span></a></code></pre></div>
<p>To calculate the Tf and the Idf values the following two functions are used</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- | Calgulate the term frequency for a collection of words</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">-- | Tf = occurrence / terms in document.</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">calcTermFreq ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Term</span> <span class="dt">Tf</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">calcTermFreq terms <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  <span class="co">-- | Map of term to number of occurrences</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="kw">let</span> freq <span class="fu">=</span> Map.fromListWith (<span class="fu">+</span>) [(<span class="dt">Term</span> t, <span class="dv">1</span>) <span class="fu">|</span> t <span class="ot">&lt;-</span> terms] <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  <span class="co">-- | Document of Term to freq. Tf = occurrence count / terms in doc</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">  (\d <span class="ot">-&gt;</span> <span class="dt">Tf</span> <span class="fu">$</span> d <span class="fu">/</span> fromIntegral(length terms)) <span class="fu">&lt;$&gt;</span> freq</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="co">-- | Claculate the term&#39;s inverse document frequency</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="co">-- | Idf = (tf + 1) / (number of documents + 1)</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="co">-- | + 1 is used to avoid divide by zero</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13"><span class="ot">calcTermIdf ::</span> [<span class="dt">Map</span> <span class="dt">Term</span> a] <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Idf</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">calcTermIdf termToTfs term <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  <span class="kw">let</span> docsWithTerm <span class="fu">=</span> filter identity (Map.member term <span class="fu">&lt;$&gt;</span> termToTfs) <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  <span class="dt">Idf</span> <span class="fu">$</span> log ((fromIntegral <span class="fu">.</span> length <span class="fu">$</span> termToTfs) <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">/</span> ((fromIntegral <span class="fu">.</span> length <span class="fu">$</span> docsWithTerm) <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>Notice that there is no need for IO at all in the TfIdf module. It is given a loaded training set and cleaned text to classify.</p>
<p>The classification is then just finding the category with the closest matching tf-idf value</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- | Calculate how well terms matches categories</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">compareToCategory ::</span> [(<span class="dt">Term</span>,<span class="dt">TfIdf</span>)] <span class="ot">-&gt;</span> (<span class="dt">Category</span>, <span class="dt">Document</span>) <span class="ot">-&gt;</span> (<span class="dt">Category</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">compareToCategory searchTfIdf (cat, <span class="dt">Document</span> catMap) <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">let</span> catList <span class="fu">=</span> Map.toList catMap <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  <span class="co">-- | common words in the category and the search text</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  <span class="kw">let</span> common <span class="fu">=</span> Lst.intersectBy sameTerm catList searchTfIdf <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">  <span class="kw">let</span> commonV <span class="fu">=</span> sum <span class="fu">$</span> valFromTfIdf <span class="fu">.</span> snd <span class="fu">&lt;$&gt;</span> common <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  <span class="co">-- | Sum of all the TfIdf values</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  <span class="kw">let</span> allV <span class="fu">=</span> sum (valFromTfIdf <span class="fu">.</span> snd <span class="fu">&lt;$&gt;</span> searchTfIdf) <span class="fu">+</span> sum (valFromTfIdf <span class="fu">.</span> snd <span class="fu">&lt;$&gt;</span> catList) <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  <span class="co">-- | Similarity = ((common a) + (common b)) / (sum all tfIdf)</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  (cat, (commonV <span class="fu">*</span> <span class="dv">2</span>) <span class="fu">/</span> allV)</a></code></pre></div>
<h1 id="using-txtcls">Using txtcls</h1>
<h2 id="building">Building</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="fu">git</span> clone git@github.com:andrevdm/TextClassify.git</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="ex">stack</span> build</a></code></pre></div>
<h2 id="installing">Installing</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ex">stack</span> install</a></code></pre></div>
<p>This will install txtcls into your local stack bin folder.</p>
<h2 id="usage-instructions">Usage Instructions</h2>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ex">txtcls</span> --help</a></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb21-1" data-line-number="1">txtcls - Text Classifier. Version 0.1.2</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">Usage: txtcls --train TEXT [--input TEXT] [--parser TEXT] [--popts TEXT]</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">              [--clean TEXT]</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">Available options:</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  -h,--help                Show this help text</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  --train TEXT             Path to training data</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">  --input TEXT             Input file to categorise. If missing stdin will be</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">                           used</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">  --parser TEXT            Parser type, defaults to lines. Options are</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">                           lines/detail/csv</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">  --popts TEXT             Parser options</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">  --clean TEXT             Options name of text cleaner - see docs</a></code></pre></div>
<h2 id="usage-examples">Usage examples</h2>
<p>The examples folder contains scripts showing how txtcls can be used. The files are</p>
<ol type="1">
<li>cleanText.sed - sed script for cleaning the words</li>
<li>skipLines.awk - awk script for skipping lines in the input CSV</li>
<li>egLines.txt - example of data where each line is the data</li>
<li>egCsv.csv - example of data in csv</li>
<li>egCsvWithHeader.csv - example of data in CSV with a header text</li>
<li>demoCsv.sh - run the example on egCsv.csv</li>
<li>demoLines.sh - run the example on egLines.txt<br />
</li>
<li>demoDetail.sh - run the example on egLines.txt using the detail output</li>
<li>demoCsvWithHeader.sh - run the example on egCsvWithHeader.csv</li>
<li>demoDetailInteractive.sh - run the detail parser interactively, read a line from stdin and write to stdout</li>
<li>trainingData/cs.txt</li>
<li>trainingData/hasekll.txt</li>
</ol>
<h2 id="lines">Lines</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --input egLines.txt --parser lines --clean ./cleanText.sed</a></code></pre></div>
<p>Where</p>
<ul>
<li><code class="sourceCode bash"><span class="ex">--train</span> ./trainingData</code>
<ul>
<li>is the path to the folder with the training data</li>
</ul></li>
<li><code class="sourceCode bash"><span class="ex">--input</span> egLines.txt</code>
<ul>
<li>is the data source to classify</li>
</ul></li>
<li><code class="sourceCode bash"><span class="ex">--parser</span> lines</code>
<ul>
<li>is the parser to use</li>
</ul></li>
<li><code class="sourceCode bash"><span class="ex">--clean</span> ./cleanText.sed</code>
<ul>
<li>is the external process or script to use to clean the text</li>
</ul></li>
</ul>
<h3 id="detail">Detail</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --input egLines.txt --parser detail --clean ./cleanText.sed</a></code></pre></div>
<p>Where</p>
<ul>
<li><code>--parser detail</code> {.bash}
<ul>
<li>is the parser to use</li>
</ul></li>
</ul>
<h3 id="csv">CSV</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --input egCsv.csv --parser csv --popts 2 --clean ./cleanText.sed <span class="kw">|</span> <span class="ex">column</span> -s , -t</a></code></pre></div>
<p>Where</p>
<ul>
<li><code>--popts 2</code> {.bash}
<ul>
<li>is column in the CSV data that contains the data to classify</li>
</ul></li>
<li><code>| column -s , -t</code> {.bash}
<ul>
<li>pipes the resulting CSV to column to display it as a table in the terminal window</li>
</ul></li>
</ul>
<h3 id="csv-with-header-text">CSV with header text</h3>
<pre class="./bash"><code>skipLines.awk egCsvWithHeader.csv | txtcls --train ./trainingData --parser csv --popts 2 --clean ./cleanText.sed | column -s , -t</code></pre>
<p>Where</p>
<ul>
<li><code class="sourceCode bash"><span class="ex">./skipLines.awk</span> egCsvWithHeader.csv <span class="kw">|</span></code>
<ul>
<li>uses the awk script to remove 4 lines from the input CSV. Note that there is no <code>--input</code> paramter so the input is read from stdin (here the output of awk)</li>
</ul></li>
</ul>
<h3 id="interactive">interactive</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --parser detail --clean ./cleanText.sed</a></code></pre></div>
<h1 id="in-conclusion">In conclusion</h1>
<p>The source code for TextClassify is available and commented. You should hopefully be able to look at it and understand how it was implemented.</p>
<p>The important things to notice are</p>
<ul>
<li>How little needs to be in IO</li>
<li>How to use an external process (like sed) as part of your application’s pipeline</li>
<li>How to write your application so that it can be part of a larger pipeline (e.g. pipe the results of awk to it)</li>
<li>Selecting input from stdin or a file</li>
<li>Tf-Idf is a relatively simple but quite accurate way to classify simple documents</li>
</ul>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://github.com/andrevdm/TextClassify">Source code for the examples</a></li>
<li><a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a></li>
<li><a href="https://hackage.haskell.org/package/cassava">Cassava</a></li>
<li><a href="https://www.haskellstack.org/">Stack</a>.</li>
<li><a href="https://github.com/sdiehl/protolude">Protolude</a></li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>.</li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Haskell shell applications techniques</title>
    <link href="http://www.andrevdm.com/posts/2016-09-20-haskell-shell.html" />
    <id>http://www.andrevdm.com/posts/2016-09-20-haskell-shell.html</id>
    <published>2016-09-20T00:00:00Z</published>
    <updated>2016-09-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 20, 2016
    
</div>

<h1 id="haskell-terminal-applications">Haskell terminal applications</h1>
<p>This is part one in a two part blog series about haskell terminal applications. In this blog I’ll cover some techniques for writing a haskell application that behaves well as a shell application. In <a href="2016-09-21-haskell-tfidf.html">part two</a> I’ll show a simple text classification implementation using these techniques.</p>
<h1 id="interacting-with-the-terminal">Interacting with the terminal</h1>
<h2 id="parsing-command-line-arguments">Parsing command line arguments</h2>
<p><a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a> makes parsing command line arguments easy. Doing this manually is tedious and not terribly interesting so its great to have a simple library that handles this well.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Arguments</span> <span class="fu">=</span> <span class="dt">Arguments</span> {<span class="ot">train ::</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Path to training data&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">                           ,<span class="ot">input ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Input file to categorise. If missing stdin will be used&quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">                           ,<span class="ot">parser ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser type, defaults to lines. Options are lines/detail/csv&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">                           ,<span class="ot">popts ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser options&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">                           ,<span class="ot">clean ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Options name of text cleaner - see docs&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                           } <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">ParseRecord</span> <span class="dt">Arguments</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ot">getArgs ::</span> <span class="dt">IO</span> <span class="dt">Arguments</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">getArgs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  args <span class="ot">&lt;-</span> getRecord <span class="st">&quot;Your app name here.&quot;</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  pure (<span class="ot">args ::</span> <span class="dt">Arguments</span>)</a></code></pre></div>
<p>The <code>&lt;?&gt;</code> operator here lets you specify help text for each argument. Running your app with –help will print the help message using this text</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb2-1" data-line-number="1">  Usage: appName --train STRING [--input STRING] [--parser TEXT] [--popts TEXT]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                [--clean TEXT]</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  Available options:</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    -h,--help                Show this help text</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    --train TEXT             Path to training data</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    --input TEXT             Input file to categorise. If missing stdin will be</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">                             used</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    --parser TEXT            Parser type, defaults to lines. Options are</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">                             lines/detail/csv</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    --popts TEXT             Parser options</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    --clean TEXT             Options name of text cleaner - see docs</a></code></pre></div>
<h2 id="input-from-stdin-or-a-file">Input from stdin or a file</h2>
<p>It is often useful to allow terminal apps to get their input data either from an input file or have it piped to the app (stdin). <code>System.IO</code> defines a set of functions for reading and writing IO that all take an explicit handle. For example hGetLine</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">hGetLine ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></a></code></pre></div>
<p>System.IO also defines the stdin, stdout and stderr standard IO handles.</p>
<p>This means that you can pass either stdin or a file handle to hGetLine and it will work the same.</p>
<p>In the example arguments above I’ve allowed the user to specify an input file by using the –input option. If that is missing stdin is used.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">handle <span class="ot">&lt;-</span> <span class="kw">case</span> unHelpful <span class="fu">$</span> input args <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">            <span class="dt">Just</span> t <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb4-3" data-line-number="3">              openFile (Txt.unpack t) <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">               pure stdin</a></code></pre></div>
<p>Notice that <code>unHelpful</code> is called to get the value from a record field with a description</p>
<p>While you could use the parsed data directly I chose to rather create another record populated from the parsed command line arguments. This allows me to have names tailored for command line in one record and for my code in another. In this interpreted record I also store the handle to use for input</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">getOptions ::</span> <span class="dt">IO</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">getOptions <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  args <span class="ot">&lt;-</span> getRecord <span class="st">&quot;Your app name here.&quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  hin_ <span class="ot">&lt;-</span> <span class="kw">case</span> unHelpful <span class="fu">$</span> input args <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">             <span class="dt">Just</span> t <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb5-6" data-line-number="6">               openFile (Txt.unpack t) <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">                pure stdin</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  pure <span class="dt">Options</span> {trainingPath <span class="fu">=</span> unHelpful (train args)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">               ,parserType <span class="fu">=</span> fromMaybe <span class="st">&quot;lines&quot;</span> <span class="fu">$</span> unHelpful (parser args)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">               ,parserOptions <span class="fu">=</span> unHelpful (popts args)</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">               ,hout <span class="fu">=</span> stdout</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">               ,hin <span class="fu">=</span> hin_</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">               }</a></code></pre></div>
<h2 id="processing-a-line-at-a-time">Processing a line at a time</h2>
<p>It is often desirable to allow terminal applications to process and respond to a single line of data at a time (e.g. sed). There are several ways to do this in haskell. One of the simplest it to use <code>whileM_</code> and check for EOF.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="co">--where inputH is the input handle stdin or a file as above</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">hSetBuffering inputH <span class="dt">LineBuffering</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">whileM_ (not <span class="fu">&lt;$&gt;</span> hIsEOF inputH) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  line <span class="ot">&lt;-</span> hGetLine inputH</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="co">--</span></a></code></pre></div>
<h2 id="using-another-terminal-app-for-processing">Using another terminal app for processing</h2>
<p>Using an existing terminal application is a quick way to leverage existing functionality. For example you may want to use sed to manipulate some text. This is fairly strait-forward in haskell.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">import</span> <span class="dt">System.Process</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">(<span class="dt">Just</span> inp, <span class="dt">Just</span> outp, _, phandle) <span class="ot">&lt;-</span> createProcess (proc <span class="st">&quot;command_name_here&quot;</span> []) { std_out <span class="fu">=</span> <span class="dt">CreatePipe</span>, std_in <span class="fu">=</span> <span class="dt">CreatePipe</span> }</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">hSetBuffering outp <span class="dt">NoBuffering</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">hSetBuffering inp <span class="dt">LineBuffering</span></a></code></pre></div>
<p>You now have and an input (inp) and output (outp) handle for the application. If the application supports line at a time input from stdin you can simply write your data and read the result back. Alternatively you may need to write the entire contents and wait for a result.</p>
<p>See <a href="2016-09-21-haskell-tfidf">part two</a> to see these techniques in use in a text classification application</p>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a></li>
<li><a href="https://www.haskellstack.org/">Stack</a>.</li>
<li><a href="https://github.com/sdiehl/protolude">Protolude</a></li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>.</li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Row span with PureScript pux and JavaScript redux</title>
    <link href="http://www.andrevdm.com/posts/2016-09-01-rowSpan-pux-redux.html" />
    <id>http://www.andrevdm.com/posts/2016-09-01-rowSpan-pux-redux.html</id>
    <published>2016-09-01T00:00:00Z</published>
    <updated>2016-09-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September  1, 2016
    
</div>

<h1 id="row-spans">Row spans</h1>
<p>I’ve always found creating tables that need rowspans a bit awkward. Having to skip TDs in the rows means that the logic to create each row can get a bit ugly. Typically I just want to map over an array of and get an array of TDs. Fortunately its quite easy to create a function to help make this easier. To keep it interesting I’m going to implement it in PureScript and JavaScript and compare a Haskell version of the function too.</p>
<h1 id="the-data">The data</h1>
<p>As an example imagine I have a set of data to display that shows the days an event occurred per month per day. Starting at the end, this is what I want the result to look like. You can see that the each year spans over the months + days and each month spans over the days.</p>
<p><img src="../images/rowSpan_final.png" /></p>
<h2 id="purescript">PureScript</h2>
<p>Here is how the data could be represented in PureScript using records</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">  <span class="kw">let</span> dates <span class="fu">=</span> [{year<span class="fu">:</span><span class="dv">2016</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">              ,months<span class="fu">:</span>[{month<span class="fu">:</span><span class="dv">11</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">                       ,days<span class="fu">:</span>[{day<span class="fu">:</span><span class="dv">30</span>}</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">                             ,{day<span class="fu">:</span><span class="dv">10</span>}</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">                             ]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">                       }</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">                      ,{month<span class="fu">:</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">                       ,days<span class="fu">:</span>[{day<span class="fu">:</span><span class="dv">15</span>}</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">                             ,{day<span class="fu">:</span><span class="dv">3</span>}</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">                             ,{day<span class="fu">:</span><span class="dv">1</span>}</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">                             ]</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                       }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">                      ]</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">              }</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">             ,{year<span class="fu">:</span><span class="dv">2015</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">              ,months<span class="fu">:</span>[{month<span class="fu">:</span><span class="dv">5</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">                       ,days<span class="fu">:</span>[{day<span class="fu">:</span><span class="dv">20</span>}</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">                             ,{day<span class="fu">:</span><span class="dv">17</span>}</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">                             ]</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">                       }</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">                      ]</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">              }</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">             ]</a></code></pre></div>
<p>Now we need something to map this data to. The simplest thing to do is to map it to a structure where each row contains the same number of columns and have a secondary function manage the shenanigans of omitting TDs that are spanned over.</p>
<p>Here is a definition for the row and column types</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Col</span> c <span class="fu">=</span> {span<span class="ot"> ::</span> <span class="dt">Int</span> <span class="fu">|</span> c}</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">type</span> <span class="dt">Row</span> r c <span class="fu">=</span> {<span class="ot">cols ::</span> <span class="dt">Array</span> (<span class="dt">Col</span> c) <span class="fu">|</span> r}</a></code></pre></div>
<p>Each row has columns and each column has a span. PureScript has extensible record types that support row polymorphism. What that means here is that we can define a function that accepts these types but the data actually passed to the function can be a superset of the required values. React for example needs a unique element id and obviously each column needs a value to be displayed. Rather than forcing this on the user of the rowSpan algorithm however we just get PureScript to check for the actual fields we need and let the caller add whatever extra data they need.</p>
<p>Here is a function to take the data above and creates an array of <strong>Row</strong>s.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">  <span class="kw">let</span> rowData <span class="fu">=</span> concat <span class="fu">$</span> concat <span class="fu">$</span> map</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">                (\y <span class="ot">-&gt;</span> map</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">                       (\m <span class="ot">-&gt;</span> map</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">                              (\d <span class="ot">-&gt;</span> {rid<span class="fu">:</span>y<span class="fu">.</span>year <span class="fu">*</span> <span class="dv">100</span> <span class="fu">+</span> m<span class="fu">.</span>month</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">                                     ,cols<span class="fu">:</span>[{val<span class="fu">:</span>show y<span class="fu">.</span>year,  span<span class="fu">:</span>length <span class="fu">$</span> concat <span class="fu">$</span> map (\a <span class="ot">-&gt;</span> a<span class="fu">.</span>days) y<span class="fu">.</span>months}</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">                                           ,{val<span class="fu">:</span>show m<span class="fu">.</span>month, span<span class="fu">:</span>length m<span class="fu">.</span>days}</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">                                           ,{val<span class="fu">:</span>show d<span class="fu">.</span>day,   span<span class="fu">:</span><span class="dv">1</span>}</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">                                           ]</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">                                     })</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">                              m<span class="fu">.</span>days)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                       y<span class="fu">.</span>months)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">                dates</a></code></pre></div>
<p>The result of this is an array of Rows. I.e. the data has been flattened and looks something like this</p>
<p><img src="../images/rowSpan_flat.png" /></p>
<p>Each <strong>Row</strong> has a rid (row id) field. Each column has a val (value) and a span field. The <strong>Col</strong>’s val contains the text to display and the span is the number of columns to span. This is simple to calculate. For months its the number of days in that month, for a year its the total number of days in all months in the year.</p>
<h1 id="the-rowspan-algorithm">The rowSpan algorithm</h1>
<p>Given a grid of data (<strong>Array</strong> of <strong>Row</strong>) we need a function that can remove the cols that are to be spanned over. This result can then be mapped over to generate the required TRs and TDs.</p>
<p>Effectively the function must do this</p>
<p><img src="../images/rowSpan_remove.png" /></p>
<p>Here is one way to achieve this</p>
<ol type="1">
<li>For each column have a <em>collapse</em> integer showing how many more times the col in its position should be skipped</li>
<li>Start with a 0 for each column, i.e. the first row always has all the columns</li>
<li>For each col in a row
<ol type="1">
<li>If <em>collapse</em> is zero then
<ol type="1">
<li>Include the column.</li>
<li>Use the <em>span</em> from the <strong>Col</strong> as the next <em>collapse</em> value</li>
</ol></li>
<li>Else if <em>collapse</em> is not zero then
<ol type="1">
<li>Ignore the column</li>
<li>Use the <em>collapse</em> value minus one as the next <em>collapse</em> value</li>
</ol></li>
</ol></li>
</ol>
<p>In the image below you can see the grid with the initial collapse value per row. As above notice that a column is removed unless the <em>collapse</em> value is zero.</p>
<p><img src="../images/rowSpan_collapse.png" /></p>
<p>And here is the PureScript code to do this</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">collapseTableArray ::</span> forall r c<span class="fu">.</span> <span class="dt">Array</span> (<span class="dt">Row</span> r c) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Row</span> r c)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">collapseTableArray rows <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="co">-- | To create the initial collapse array, we need to know the number of cols in a row</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="co">-- | Get the number of cols in each row and then  get the minimum value</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="co">-- | PureScript being safe ensures that the empty list case is handled</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">case</span> minimum <span class="fu">$</span> (\r <span class="ot">-&gt;</span> length r<span class="fu">.</span>cols) <span class="fu">&lt;$&gt;</span> rows <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="dt">Just</span> m <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">      <span class="co">-- | Initial collapse array of zeros</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      <span class="kw">let</span> collapse <span class="fu">=</span> replicate m <span class="dv">0</span> <span class="kw">in</span> </a>
<a class="sourceLine" id="cb4-10" data-line-number="10">      <span class="co">-- | fold rows with collapseRow</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">      <span class="kw">let</span> fixed <span class="fu">=</span> foldl collapseRow {collapse<span class="fu">:</span> collapse, st<span class="fu">:</span> []} rows <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">      fixed<span class="fu">.</span>st</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    _ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="co">-- | The fold function</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17"><span class="ot">    collapseRow ::</span> forall rr cc ss<span class="fu">.</span> (<span class="dt">CollapseState</span> rr cc ss) <span class="ot">-&gt;</span> <span class="dt">Row</span> rr cc <span class="ot">-&gt;</span> (<span class="dt">CollapseState</span> rr cc ss)</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    collapseRow state row <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">      <span class="co">-- | Zip the previous collapse array and the current cols array</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">      <span class="co">-- | This results in an array of [collapse, col]</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">      <span class="kw">let</span> skipCols <span class="fu">=</span> zip state<span class="fu">.</span>collapse row<span class="fu">.</span>cols <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">      <span class="co">-- | Get all cols where the collapse value is less than 1</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">      <span class="co">-- | First the list is filtered by checking the collapse value (fst in array)</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">      <span class="co">-- | Then snd is called (fmapped over) each itemm to get only the column</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">      <span class="co">-- | Note that this results in the selected columns being unaltered and all additional information (fields)</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">      <span class="co">-- |  in the columns being retained</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">      <span class="kw">let</span> nextCols <span class="fu">=</span> snd <span class="fu">&lt;$&gt;</span> filter (\t <span class="ot">-&gt;</span> fst t <span class="fu">&lt;=</span> <span class="dv">0</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      <span class="co">-- | If current collapse is zero then next skip is the span value - 1 else its collapse - 1</span></a>
<a class="sourceLine" id="cb4-29" data-line-number="29">      <span class="kw">let</span> nextSkip <span class="fu">=</span> map (\t <span class="ot">-&gt;</span> <span class="kw">if</span> fst t <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> (snd t)<span class="fu">.</span>span <span class="fu">-</span> <span class="dv">1</span> <span class="kw">else</span> (fst t) <span class="fu">-</span> <span class="dv">1</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-30" data-line-number="30">      <span class="co">-- | Construct the row, change only the cols</span></a>
<a class="sourceLine" id="cb4-31" data-line-number="31">      <span class="co">-- | Again, note that the other fields in the row are returned unaltered</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">      <span class="kw">let</span> resRow <span class="fu">=</span> row { cols <span class="fu">=</span> nextCols } <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-33" data-line-number="33">      <span class="co">-- | Next state</span></a>
<a class="sourceLine" id="cb4-34" data-line-number="34">      state {collapse <span class="fu">=</span> nextSkip, st <span class="fu">=</span> snoc state<span class="fu">.</span>st resRow }</a></code></pre></div>
<p>Finally here is the Pux code to generate the HTML from the result of <em>collapseTableArray</em></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">getTable ::</span> forall a<span class="fu">.</span> <span class="dt">Html</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">getTable <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">let</span> rowData <span class="fu">=</span> <span class="co">-- See above</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">let</span> c <span class="fu">=</span> collapseTableArray rowData <span class="kw">in</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">let</span> tableRows <span class="fu">=</span> map buildRow c <span class="kw">in</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  div</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    []</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    [table</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">       []</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">       [thead</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">          []</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">          [tr</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">             []</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">             [th [] [text <span class="st">&quot;year&quot;</span>]</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">             ,th [] [text <span class="st">&quot;month&quot;</span>]</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">             ,th [] [text <span class="st">&quot;day&quot;</span>]</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">             ]</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">          ]</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">       ,tbody</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">          []</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">          (buildRow <span class="fu">&lt;$&gt;</span> c)</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">       ]</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    ]</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">    buildRow r <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">      tr</a>
<a class="sourceLine" id="cb5-28" data-line-number="28">      []</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">      (buildCol <span class="fu">&lt;$&gt;</span> r<span class="fu">.</span>cols)</a>
<a class="sourceLine" id="cb5-30" data-line-number="30"></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">    buildCol c <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-32" data-line-number="32">      td</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">        [attr <span class="st">&quot;rowSpan&quot;</span> c<span class="fu">.</span>span]</a>
<a class="sourceLine" id="cb5-34" data-line-number="34">        [text <span class="fu">$</span> c<span class="fu">.</span>val]</a></code></pre></div>
<h1 id="javascript-and-redux">JavaScript and Redux</h1>
<p>Here is what that would look like in JavaScript. The example uses <a href="https://github.com/reactjs/redux">Redux</a> (react-redux) for the rendering and <a href="http://ramdajs.com/">Ramda</a> for the functional programming features. The code is compiled with babel with ES2015 syntax and the object spread operator enabled.</p>
<p>The data looks very similar to the PureScript data.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" data-line-number="1">  [<span class="op">{</span><span class="dt">year</span><span class="op">:</span><span class="dv">2016</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="dt">months</span><span class="op">:</span>[<span class="op">{</span><span class="dt">month</span><span class="op">:</span><span class="dv">11</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">             <span class="dt">days</span><span class="op">:</span>[<span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">30</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">10</span><span class="op">}</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">                  ]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">            <span class="op">},</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">            <span class="op">{</span><span class="dt">month</span><span class="op">:</span><span class="dv">2</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">             <span class="dt">days</span><span class="op">:</span>[<span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">15</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">3</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">1</span><span class="op">}</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">                  ]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">            <span class="op">}</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">           ]</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">   <span class="op">},</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">   <span class="op">{</span><span class="dt">year</span><span class="op">:</span><span class="dv">2015</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="dt">months</span><span class="op">:</span>[<span class="op">{</span><span class="dt">month</span><span class="op">:</span><span class="dv">5</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">             <span class="dt">days</span><span class="op">:</span>[<span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">20</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">17</span><span class="op">}</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">                  ]</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">            <span class="op">}</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">           ]</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">   <span class="op">}</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  ]<span class="op">;</span></a></code></pre></div>
<p>As with the PureScript example the first step is to create a flattened grid of the data and then call collapseTableArray on it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" data-line-number="1">  <span class="kw">const</span> daysInYear <span class="op">=</span> y <span class="op">=&gt;</span> <span class="va">R</span>.<span class="at">flatten</span>( <span class="va">R</span>.<span class="at">map</span>( m <span class="op">=&gt;</span> <span class="va">m</span>.<span class="at">days</span><span class="op">,</span> <span class="va">y</span>.<span class="at">months</span> ) )<span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">const</span> rows <span class="op">=</span> <span class="va">R</span>.<span class="at">flatten</span>( <span class="va">R</span>.<span class="at">map</span>(</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    y <span class="op">=&gt;</span> <span class="va">R</span>.<span class="at">map</span>(</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">      m <span class="op">=&gt;</span> <span class="va">R</span>.<span class="at">map</span>(</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        d <span class="op">=&gt;</span> (<span class="op">{</span><span class="dt">rowId</span><span class="op">:</span> <span class="va">y</span>.<span class="at">year</span> <span class="op">+</span> <span class="st">&quot;.&quot;</span> <span class="op">+</span> <span class="va">m</span>.<span class="at">month</span> <span class="op">+</span> <span class="st">&quot;.&quot;</span> <span class="op">+</span> <span class="va">d</span>.<span class="at">day</span><span class="op">,</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">               <span class="dt">cols</span><span class="op">:</span>[<span class="op">{</span><span class="dt">val</span><span class="op">:</span> <span class="va">y</span>.<span class="at">year</span><span class="op">,</span>  <span class="dt">span</span><span class="op">:</span> <span class="at">daysInYear</span>(y).<span class="at">length</span><span class="op">}</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">                    <span class="op">,{</span><span class="dt">val</span><span class="op">:</span> <span class="va">m</span>.<span class="at">month</span><span class="op">,</span> <span class="dt">span</span><span class="op">:</span> <span class="va">m</span>.<span class="va">days</span>.<span class="at">length</span><span class="op">}</span> </a>
<a class="sourceLine" id="cb7-9" data-line-number="9">                    <span class="op">,{</span><span class="dt">val</span><span class="op">:</span> <span class="va">d</span>.<span class="at">day</span><span class="op">,</span>   <span class="dt">span</span><span class="op">:</span> <span class="dv">1</span><span class="op">}</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">                    ]</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">              <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">        <span class="va">m</span>.<span class="at">days</span> )<span class="op">,</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">      <span class="va">y</span>.<span class="at">months</span> )<span class="op">,</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    data )</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">  <span class="kw">var</span> collapsed <span class="op">=</span> <span class="at">collapseTableArray</span>( rows )<span class="op">;</span></a></code></pre></div>
<p>The JavaScript version of the collapseTableArray function works in exactly the same way. Using Rambda and the ES2015 syntax (lambdas, destructuring etc) allows the JavaScript code to be nice and functional.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" data-line-number="1">  <span class="kw">const</span> collapseTableArray <span class="op">=</span> (tableArray) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="cf">if</span>( <span class="va">R</span>.<span class="at">isEmpty</span>(tableArray) )<span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      <span class="cf">return</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="co">//First collapse array is just a 0 for each col on first row</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="kw">var</span> collapse <span class="op">=</span> <span class="va">R</span>.<span class="at">map</span>( a <span class="op">=&gt;</span> <span class="dv">0</span><span class="op">,</span> tableArray[<span class="dv">0</span>].<span class="at">cols</span> )<span class="op">;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="kw">var</span> fixed <span class="op">=</span> <span class="va">R</span>.<span class="at">reduce</span>(</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      ([skip<span class="op">,</span> acc]<span class="op">,</span>row) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        <span class="co">//combine the skip list and cols</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        <span class="kw">const</span> skipCols <span class="op">=</span> <span class="va">R</span>.<span class="at">zip</span>( skip<span class="op">,</span> <span class="va">row</span>.<span class="at">cols</span> )</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        <span class="co">//Get the col that should not be skipped (2nd item from each of the filtered pair)</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        <span class="kw">const</span> nextCols <span class="op">=</span> <span class="va">R</span>.<span class="at">map</span>( p <span class="op">=&gt;</span> p[<span class="dv">1</span>]<span class="op">,</span> <span class="va">R</span>.<span class="at">filter</span>( f <span class="op">=&gt;</span> f[<span class="dv">0</span>] <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">,</span> skipCols ) )</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        <span class="co">//Calculate next skip. Look at prev skip, use the rowSpan from tableArray once the previous span has been used up</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">        <span class="kw">const</span> nextSkip <span class="op">=</span> <span class="va">R</span>.<span class="at">map</span>( p <span class="op">=&gt;</span> p[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> p[<span class="dv">1</span>].<span class="at">span</span> <span class="op">-</span> <span class="dv">1</span> : p[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> skipCols )</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  </a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        <span class="kw">const</span> res <span class="op">=</span> <span class="va">R</span>.<span class="at">concat</span>( acc<span class="op">,</span> [<span class="op">{</span>...<span class="at">row</span><span class="op">,</span> <span class="dt">cols</span><span class="op">:</span>nextCols<span class="op">}</span>] )<span class="op">;</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        <span class="cf">return</span> [nextSkip<span class="op">,</span> res]<span class="op">;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">      <span class="op">},</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">      [collapse<span class="op">,</span>[]]<span class="op">,</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">      tableArray )<span class="op">;</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  </a>
<a class="sourceLine" id="cb8-24" data-line-number="24">    <span class="cf">return</span> fixed[<span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  <span class="op">}</span></a></code></pre></div>
<p>Finally the data is rendered with react</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb9-1" data-line-number="1">  return (</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="kw">&lt;div&gt;</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">      <span class="kw">&lt;table&gt;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="kw">&lt;thead&gt;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">          <span class="kw">&lt;tr&gt;</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">            <span class="kw">&lt;th&gt;</span>Year<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">            <span class="kw">&lt;th&gt;</span>Month<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">            <span class="kw">&lt;th&gt;</span>Day<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">          <span class="kw">&lt;/tr&gt;</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="kw">&lt;/thead&gt;</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        <span class="kw">&lt;tbody&gt;</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">          {R.map( r =&gt; (<span class="kw">&lt;tr</span><span class="ot"> key=</span><span class="st">{r.rowId}</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">                         {R.map( c =&gt; (<span class="kw">&lt;td</span><span class="ot"> rowSpan=</span><span class="st">{c.span}</span><span class="ot"> key=</span><span class="st">{r.rowId</span> <span class="er">+</span> <span class="er">&quot;.&quot;</span> <span class="er">+</span><span class="ot"> c.val</span><span class="er">}</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">                                         {c.val}</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">                                       <span class="kw">&lt;/td&gt;</span>),</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">                                 r.cols )}</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">                        <span class="kw">&lt;/tr&gt;</span>),</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">                  collapsed )}</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">        <span class="kw">&lt;/tbody&gt;</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      <span class="kw">&lt;/table&gt;</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">    <span class="kw">&lt;/div&gt;</span></a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  );</a></code></pre></div>
<h1 id="haskell">Haskell</h1>
<p>While I’ve not implemented the HTML rendering with GHCJS I think its interesting to compare the PureScript and Haskell version of the collapseTableArray functions</p>
<p>Starting with the Haskell types</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Col</span> c <span class="fu">=</span> <span class="dt">Col</span> {span<span class="ot"> ::</span> <span class="dt">Int</span>,<span class="ot"> cval ::</span> c} <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Row</span> r c <span class="fu">=</span> <span class="dt">Row</span> {<span class="ot">cols ::</span> [<span class="dt">Col</span> c],<span class="ot"> rval ::</span> r} <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>Haskell does not have row polymorphism (e.g. extensible records) so to allow the <strong>Row</strong> and <strong>Col</strong> types to have user defined values I’ve used a record with type params</p>
<p>In this example I’m using <strong>Rid</strong> and <strong>Cval</strong> as defined below</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Rid</span> <span class="fu">=</span> <span class="dt">Rid</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Cval</span> <span class="fu">=</span> <span class="dt">Cval</span> <span class="dt">Text</span> <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>The Haskell collapseTableArray is very similar to the PureScript version</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">  <span class="co">-- | same as minimum but check for an empty list</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">  minimumSafe ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  minimumSafe xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      _ <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> minimum xs</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">  collapseTableArray ::</span> [<span class="dt">Row</span> r c] <span class="ot">-&gt;</span> [<span class="dt">Row</span> r c]</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  collapseTableArray rows <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    <span class="co">-- | To create the initial collapse array, we need to know the number of cols in a row</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    <span class="co">-- | Get the number of cols in each row and then  get the minimum value</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    <span class="co">-- | Use minimumSafe to guard against an empty list</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    <span class="kw">case</span> minimumSafe <span class="fu">$</span> (\r <span class="ot">-&gt;</span> length <span class="fu">$</span> cols r) <span class="fu">&lt;$&gt;</span> rows <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14">      <span class="dt">Just</span> i <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">        <span class="co">-- | Initial collapse array of zeros</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">        <span class="kw">let</span> collapse <span class="fu">=</span> replicate i <span class="dv">0</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">        <span class="co">-- | fold rows with collapseRow</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">        <span class="kw">let</span> (c,res) <span class="fu">=</span> foldl collapseRow (collapse, []) rows <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19">        res</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">      _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">        []</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb12-23" data-line-number="23">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24">      <span class="co">-- | The fold function</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25"><span class="ot">      collapseRow ::</span> ([<span class="dt">Int</span>], [<span class="dt">Row</span> r c]) <span class="ot">-&gt;</span> <span class="dt">Row</span> r c <span class="ot">-&gt;</span> ([<span class="dt">Int</span>], [<span class="dt">Row</span> r c])</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">      collapseRow (collapse, res) row <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27">        <span class="co">-- | Zip the previous collapse array and the current cols array</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28">        <span class="co">-- | This results in a tuple of (collapse, col)</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29">        <span class="kw">let</span> skipCols <span class="fu">=</span> zip collapse <span class="fu">$</span> cols row <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-30" data-line-number="30">        <span class="co">-- | Get all cols where the collapse value is less than 1</span></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">        <span class="co">-- | First the list is filtered by checking the collapse value (the first value in the tuple)</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32">        <span class="co">-- | Then snd is called (fmapped over) each tuple to get only the column</span></a>
<a class="sourceLine" id="cb12-33" data-line-number="33">        <span class="kw">let</span> nextCols <span class="fu">=</span> snd <span class="fu">&lt;$&gt;</span> filter (\(c,_) <span class="ot">-&gt;</span> c <span class="fu">&lt;=</span> <span class="dv">0</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-34" data-line-number="34">        <span class="co">-- | If current collapse is zero then next skip is the span value - 1 else its collapse - 1</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35">        <span class="kw">let</span> nextSkip <span class="fu">=</span> map (\(c,r) <span class="ot">-&gt;</span> <span class="kw">if</span> c <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> (span r) <span class="fu">-</span> <span class="dv">1</span> <span class="kw">else</span> c <span class="fu">-</span> <span class="dv">1</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36">        <span class="co">-- | Construct the row, change only the cols</span></a>
<a class="sourceLine" id="cb12-37" data-line-number="37">        <span class="kw">let</span> resRow <span class="fu">=</span> row { cols <span class="fu">=</span> nextCols } <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-38" data-line-number="38">        (nextSkip, res <span class="fu">&lt;&gt;</span> [resRow])</a></code></pre></div>
<p>A few differences to note from PureScript</p>
<ol type="1">
<li><code>deriving show</code> makes printing values easy. The sample project prints the result to the console</li>
<li><em>minimum</em> is not safe by default, so I’m using a custom <em>safeMinimum</em> to check for empty lists</li>
<li>Support for tuples and tuple destructuring</li>
<li>record functions to get values rather than field access</li>
</ol>
<p>Overall though the differences are small.</p>
<h1 id="building-the-sample-projects">Building the sample projects</h1>
<p>All the code for the <a href="https://github.com/andrevdm/rowSpanPureScriptJs">examples is on github</a></p>
<ul>
<li>PureScript
<ol type="1">
<li>In the ps directory run <code>setupPs.sh</code></li>
<li>Run <code>pulp build</code> to build</li>
<li>Run <code>npm sttart</code> to build and run the site.</li>
<li>Browse to http://localhost:3000/</li>
</ol></li>
<li>JavaScript
<ol type="1">
<li>In the js directory run <code>setupBable.sh</code></li>
<li>Run <code>runBabelAndWatch.sh</code> to build the bable js</li>
<li>Start a web server in the js/demo directory (e.g. node’s http-server)</li>
</ol></li>
<li>Haskell
<ol type="1">
<li>Ensure you have stack installed</li>
<li>In the hs directory run <code>stack build</code></li>
<li>Run <code>buildAndRun.sh</code></li>
</ol></li>
</ul>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://github.com/andrevdm/rowSpanPureScriptJs">Source code for the examples</a>.</li>
<li><a href="https://github.com/alexmingoia/pux-starter-app">Purescript pux starter app</a>.</li>
<li><a href="http://ramdajs.com/">Ramda</a>.</li>
<li><a href="https://github.com/reactjs/redux">Redux</a>.</li>
<li><a href="https://www.haskellstack.org/">Stack</a>.</li>
<li><a href="https://github.com/sdiehl/protolude">Protolude</a></li>
<li><a href="https://leanpub.com/purescript">PureScript By Example</a>. The PureScript book</li>
<li><a href="http://www.alexmingoia.com/purescript-pux/index.html">Pux Tutorial</a></li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>.</li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Composing components with PureScript Pux</title>
    <link href="http://www.andrevdm.com/posts/2016-08-15-PureScript-Pux-Compose.html" />
    <id>http://www.andrevdm.com/posts/2016-08-15-PureScript-Pux-Compose.html</id>
    <published>2016-08-15T00:00:00Z</published>
    <updated>2016-08-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on August 15, 2016
    
</div>

<h2 id="purescript-pux">PureScript Pux</h2>
<p>Pux is a PureScript interface to React. The tutorial at <a href="http://www.alexmingoia.com/purescript-pux/index.html" class="uri">http://www.alexmingoia.com/purescript-pux/index.html</a> gives a good introduction to the library. The section titled <strong>Multiple components</strong> shows how you can easily compose simple components. What it does not show however is how to compose components that have effects (eff or aff).</p>
<p>I battled with this for a bit and so decided to document the solution in the hopes it helps other beginners. The explanation below shows how to compose components in the framework of the <a href="https://github.com/alexmingoia/pux-starter-app">starter app</a>.</p>
<p>I’m assuming that you have read the pux tutorial at least up to the fetching data section so I wont be covering the same detail here.</p>
<h2 id="the-starter-app">The starter app</h2>
<p>The starter app has a counter component that is rendered in the Laout.purs file</p>
<h3 id="the-original-counter">The original counter</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Action</span> <span class="fu">=</span> <span class="dt">Increment</span> <span class="fu">|</span> <span class="dt">Decrement</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">init<span class="ot"> ::</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">init <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">update <span class="dt">Increment</span> state <span class="fu">=</span> state <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">update <span class="dt">Decrement</span> state <span class="fu">=</span> state <span class="fu">-</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="the-original-layout">The original layout</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Child</span> (<span class="dt">Counter.Action</span>)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">PageView</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  {<span class="ot"> route ::</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  ,<span class="ot"> count ::</span> <span class="dt">Counter.State</span> }</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">init<span class="ot"> ::</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">init <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  { route<span class="fu">:</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  , count<span class="fu">:</span> Counter.init }</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">update (<span class="dt">PageView</span> route) state <span class="fu">=</span> state { route <span class="fu">=</span> route }</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">update (<span class="dt">Child</span> action) state <span class="fu">=</span> state { count <span class="fu">=</span> Counter.update action state<span class="fu">.</span>count }</a></code></pre></div>
<h2 id="making-the-counter-effectful">Making the counter effectful</h2>
<h3 id="effmodel">EffModel</h3>
<p>The type of an update function with no effects (as above) is</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">State</span></a></code></pre></div>
<p>For it to be effectful it should return an EffModel. The EffModel looks like this</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">type</span> <span class="dt">EffModel</span> state action eff <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    {<span class="ot"> state ::</span> state</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    ,<span class="ot"> effects ::</span> <span class="dt">Array</span> (<span class="dt">Aff</span> (<span class="ot">channel ::</span> <span class="dt">CHANNEL</span> <span class="fu">|</span> eff) action) </a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    }</a></code></pre></div>
<p>The update type will then be</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a></code></pre></div>
<h3 id="changing-the-counter">Changing the counter</h3>
<p>To keep things simple I’ll make the counter component act as if its effectual without doing any actual IO. To perform effects the component returns a list of effects that should be performed in the EffModel’s effects. The counter needs to do three things</p>
<ol type="1">
<li>Increment</li>
<li>Decrement</li>
<li>Apply the effects</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">update (<span class="dt">ReceiveInc</span> i) state<span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  noEffects <span class="fu">$</span> state <span class="fu">+</span> i</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">update <span class="dt">Increment</span> state <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  { state<span class="fu">:</span> state</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  , effects<span class="fu">:</span> [ <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">                  pure <span class="fu">$</span> <span class="dt">ReceiveInc</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">             ]</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">update <span class="dt">Decrement</span> state <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  { state<span class="fu">:</span> state</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  , effects<span class="fu">:</span> [ <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">                  pure <span class="fu">$</span> <span class="dt">ReceiveInc</span> (<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">             ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17"><span class="ot">view ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Html</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">view state <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">  div</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    []</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">    [ button [ onClick (const <span class="dt">Increment</span>) ] [ text <span class="st">&quot;Increment&quot;</span> ]</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">    , span [] [ text (show state) ]</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">    , button [ onClick (const <span class="dt">Decrement</span>) ] [ text <span class="st">&quot;Decrement&quot;</span> ]</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">    ]</a></code></pre></div>
<p>The increment and decrement cases return a ReceiveInc effect that will then be passed to the component and applied by the ReceiveInc case. In a real world component there would be an actual IO action e.g. using AJAX with affjax etc. But ultimately you are returning the effect in the array to be applied.</p>
<h3 id="changing-the-layout">Changing the layout</h3>
<p>The layout’s update function must also be changed to use an EffModel</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">update (<span class="dt">PageView</span> route) state <span class="fu">=</span> noEffects <span class="fu">$</span> state { route <span class="fu">=</span> route }</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a></code></pre></div>
<p>The problem is that the counter’s EffModel does not have the same type as the layout’s EffModel, so you can’t simply use the result from the child components. Rather you need to map both the state and the effects using the mapState and mapEffects functions.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">let</span> efm <span class="fu">=</span> Counter.update action state<span class="fu">.</span>count <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">let</span> st <span class="fu">=</span> mapState (\s <span class="ot">-&gt;</span> state {count <span class="fu">=</span> s}) efm <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">let</span> ef <span class="fu">=</span> mapEffects (\e <span class="ot">-&gt;</span> <span class="dt">PostCounter</span> e) st <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  ef</a></code></pre></div>
<p>So first the Counter’s update function is called. Then the state is mapped to change the state. Finally the effects are mapped by creating a PostCounter instance for each event. This can be cleaned up a bit, e.g. using the <strong><em>#</em></strong> operator</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  Counter.update action state<span class="fu">.</span>count</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">#</span> mapState (state {count <span class="fu">=</span> _}) </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="fu">#</span> mapEffects <span class="dt">PostCounter</span> </a></code></pre></div>
<p>The final layout code looks like this</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">PostCounter</span> (<span class="dt">Counter.Action</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">PostCounter2</span> (<span class="dt">Counter.Action</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">PageView</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  {<span class="ot"> route ::</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  ,<span class="ot"> count ::</span> <span class="dt">Counter.State</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  ,<span class="ot"> count2 ::</span> <span class="dt">Counter.State</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">init<span class="ot"> ::</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">init <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">  {</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    route<span class="fu">:</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">  , count<span class="fu">:</span> Counter.init</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">  , count2<span class="fu">:</span> Counter.init</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb10-19" data-line-number="19"></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">update (<span class="dt">PageView</span> route) state <span class="fu">=</span> noEffects <span class="fu">$</span> state { route <span class="fu">=</span> route }</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">  Counter.update action state<span class="fu">.</span>count</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">  <span class="fu">#</span> mapState (state {count <span class="fu">=</span> _}) </a>
<a class="sourceLine" id="cb10-25" data-line-number="25">  <span class="fu">#</span> mapEffects <span class="dt">PostCounter</span> </a>
<a class="sourceLine" id="cb10-26" data-line-number="26">update (<span class="dt">PostCounter2</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27">  Counter.update action state<span class="fu">.</span>count2</a>
<a class="sourceLine" id="cb10-28" data-line-number="28">  <span class="fu">#</span> mapState (state {count2 <span class="fu">=</span> _}) </a>
<a class="sourceLine" id="cb10-29" data-line-number="29">  <span class="fu">#</span> mapEffects <span class="dt">PostCounter2</span> </a>
<a class="sourceLine" id="cb10-30" data-line-number="30"></a>
<a class="sourceLine" id="cb10-31" data-line-number="31"><span class="ot">view ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Html</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32">view state <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">  div</a>
<a class="sourceLine" id="cb10-34" data-line-number="34">    []</a>
<a class="sourceLine" id="cb10-35" data-line-number="35">    [ h1 [] [ text <span class="st">&quot;Pux Starter App&quot;</span> ]</a>
<a class="sourceLine" id="cb10-36" data-line-number="36">    , p [] [ text <span class="st">&quot;Change src/Layout.purs and watch me hot-reload.&quot;</span> ]</a>
<a class="sourceLine" id="cb10-37" data-line-number="37">    , <span class="kw">case</span> state<span class="fu">.</span>route <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38">        <span class="dt">Home</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39">          div</a>
<a class="sourceLine" id="cb10-40" data-line-number="40">            []</a>
<a class="sourceLine" id="cb10-41" data-line-number="41">            [</a>
<a class="sourceLine" id="cb10-42" data-line-number="42">              map <span class="dt">PostCounter</span> <span class="fu">$</span> Counter.view state<span class="fu">.</span>count</a>
<a class="sourceLine" id="cb10-43" data-line-number="43">            , hr [] [] </a>
<a class="sourceLine" id="cb10-44" data-line-number="44">            , map <span class="dt">PostCounter2</span> <span class="fu">$</span> Counter.view state<span class="fu">.</span>count2</a>
<a class="sourceLine" id="cb10-45" data-line-number="45">            ]</a>
<a class="sourceLine" id="cb10-46" data-line-number="46">        <span class="dt">NotFound</span> <span class="ot">-&gt;</span> NotFound.view state</a>
<a class="sourceLine" id="cb10-47" data-line-number="47">    ]</a></code></pre></div>
<h3 id="changing-main">Changing main</h3>
<p>The only remaining changes are a few minor modifications to Main.purs</p>
<ol type="1">
<li>Import <code>Network.HTTP.Affjax (AJAX)</code></li>
<li><p>Add AJAX to the AppEfects type</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="dt">AppEffects</span> <span class="fu">=</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX0</span>)</a></code></pre></div></li>
<li><p>The update function no longer needs the <code>fromSimple</code></p></li>
</ol>
<h2 id="summary">Summary</h2>
<p>The full code for this example is available in this fork of the start app <a href="https://github.com/andrevdm/pux-starter-app-with-effects" class="uri">https://github.com/andrevdm/pux-starter-app-with-effects</a></p>
<h2 id="links">Links</h2>
<ol type="1">
<li><a href="https://leanpub.com/purescript">PureScript By Example</a>. The PureScript book</li>
<li><a href="http://www.alexmingoia.com/purescript-pux/index.html">Pux Tutorial</a></li>
<li><a href="https://github.com/dariooddenino/pux-blog">Pux blog sample project</a>. Shows this and more in a real world project. This helped clear up some of the confusion for me, definitely worth taking a look at</li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>. Invaluable if you are new to PureScript/Haskell</li>
<li><a href="https://github.com/andrevdm/pux-starter-app-with-effects">Source code for this example</a>. Diff on d621094abb4cb3a9bea2b1a831d50fbc5ef014a6 will show changes made for this post.</li>
</ol>

]]></summary>
</entry>

</feed>
