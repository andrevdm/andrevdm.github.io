<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Andre's Blog</title>
    <link href="http://www.andrevdm.com/atom.xml" rel="self" />
    <link href="http://www.andrevdm.com" />
    <id>http://www.andrevdm.com/atom.xml</id>
    <author>
        <name>Andre Van Der Merwe</name>
        <email>blog@andrevdm.com</email>
    </author>
    <updated>2018-01-15T00:00:00Z</updated>
    <entry>
    <title>bhoogle - Building a simple hoogle GUI with brick</title>
    <link href="http://www.andrevdm.com/posts/2018-01-15-bhoogle.html" />
    <id>http://www.andrevdm.com/posts/2018-01-15-bhoogle.html</id>
    <published>2018-01-15T00:00:00Z</published>
    <updated>2018-01-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 15, 2018
    
</div>

<h1 id="overview">Overview</h1>
<p>bhoogle is a simple hoogle terminal GUI written using <a href="https://hackage.haskell.org/package/brick">brick</a>. This post is the annotated source code that should give you an idea of how to use brick and how easy brick makes building terminal UIs.</p>
<h2 id="bhoogle">bhoogle</h2>
<p><img src="/images/bhoogle.png" /></p>
<p>bhoogle is possibly useful as a local hoogle UI as well as a demo app. You can get the full code from <a href="https://github.com/andrevdm/bhoogle">github</a>.</p>
<h3 id="setup">Setup</h3>
<p>You will need an existing local hoogle database. If you do not already have one or are unsure, then do this</p>
<ol type="1">
<li>Install hoogle (e.g. <code>stack install hoogle</code>)</li>
<li>Generate the default database (<code>hoogle generate</code>)</li>
</ol>
<h3 id="build">Build</h3>
<p>You can then <a href="https://github.com/andrevdm/bhoogle">clone the code</a>, or download one of the pre-build <a href="https://github.com/andrevdm/bhoogle/releases">linux releases</a></p>
<h3 id="usage">Usage</h3>
<ol type="1">
<li>Enter a type search in the “type” edit box</li>
<li>Press <strong>enter</strong> to search: focus goes directly to the results list</li>
<li>Or press <strong>tab</strong> to search and focus will go to the “text” edit box</li>
<li>You can then filter the results by typing in the “text” edit box, any result containing the sub-string typed will be shown</li>
<li>Navigate the results by using <strong>arrow</strong> or vi (<strong>hjkl</strong>) keys</li>
<li>Pressing <strong>‘s’</strong> in the results list will toggle the sort order</li>
<li><strong>Escape</strong> to exit</li>
<li>Search-ahead is enable for any type search longer than three characters</li>
</ol>
<h1 id="brick">Brick</h1>
<p>There are a few conventions to get used to when building a brick UI, but I don’t think it should take you too long to get the hang of things.</p>
<p>The <a href="https://github.com/jtdaugherty/brick/blob/master/docs/guide.rst">brick user guide</a> and documentation are fantastic. Brick comes with multiple example apps that show controls and features being used. There are also third party tutorials e.g. <a href="https://github.com/jtdaugherty/brick/blob/master/docs/samtay-tutorial.md">Samuel Tay’s brick tutorial</a></p>
<h1 id="bhoogle-0.1.1.0-source">bhoogle 0.1.1.0 source</h1>
<p>If you have looked at the user guide or Samuel Tay’s tutorial you’ll already have some idea of the fundamental concepts. Below is the annotated source for bhoogle. As always feel free to email or contact me on <a href="https://twitter.com/andrevdm">twitter</a> if anything is unclear and I’ll do my best to assist.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Control.Lens</span> ((^.), (.~), (%~))</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span>           <span class="dt">Control.Lens.TH</span> (makeLenses)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">Lst</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Time</span> <span class="kw">as</span> <span class="dt">Tm</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Txt</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vec</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Brick</span> ((&lt;+&gt;), (&lt;=&gt;))</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.BChan</span> <span class="kw">as</span> <span class="dt">BCh</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Focus</span> <span class="kw">as</span> <span class="dt">BF</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.AttrMap</span> <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.List</span> <span class="kw">as</span> <span class="dt">BL</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.Edit</span> <span class="kw">as</span> <span class="dt">BE</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.Border</span> <span class="kw">as</span> <span class="dt">BB</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Brick.Widgets.Border.Style</span> <span class="kw">as</span> <span class="dt">BBS</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="kw">import</span>           <span class="dt">Control.Concurrent</span> (threadDelay, forkIO)</a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Graphics.Vty</span> <span class="kw">as</span> <span class="dt">V</span></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Graphics.Vty.Input.Events</span> <span class="kw">as</span> <span class="dt">K</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26"></a>
<a class="sourceLine" id="cb1-27" data-line-number="27"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Hoogle</span> <span class="kw">as</span> <span class="dt">H</span></a></code></pre></div>
<p>Import all the modules we’ll need. I’m using <a href="https://github.com/sdiehl/protolude">protolude</a> as my custom prelude, changing to one of the others e.g. <a href="https://hackage.haskell.org/package/classy-prelude">classy</a> should be pretty simple if you prefer that.</p>
<p>I’m also using lens. The brick examples use lens so its worth getting used to. However I’m only using three of the simpler lenses, so if you don’t like lens or template haskell it should be easy enough to remove them.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- | Events that can be sent</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- | Here there is just one event for updating the time</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">Event</span> <span class="fu">=</span> <span class="dt">EventUpdateTime</span> <span class="dt">Tm.LocalTime</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">-- | Names use to identify each of the controls</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">TypeSearch</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">          <span class="fu">|</span> <span class="dt">TextSearch</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">          <span class="fu">|</span> <span class="dt">ListResults</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">          <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>Next we need to define the type of custom events that our brick application can handle and a sum type defining the “name” for each control we want to use.</p>
<p>In this example there is only a single event <strong>EventUpdateTime</strong>. It is sent once a second with the current time. This gets displayed by brick in the top right corner</p>
<p>There are three controls</p>
<ol type="1">
<li>The edit box for the type to search for</li>
<li>The edit box for the substring search</li>
<li>The results listbox</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- | Sort order</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">data</span> <span class="dt">SortBy</span> <span class="fu">=</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">            <span class="fu">|</span> <span class="dt">SortAsc</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">            <span class="fu">|</span> <span class="dt">SortDec</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">            <span class="kw">deriving</span> (<span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co">-- | State of the brick app. Contains the controls and any other required state</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">data</span> <span class="dt">BrickState</span> <span class="fu">=</span> <span class="dt">BrickState</span> </a>
<a class="sourceLine" id="cb3-10" data-line-number="10">     {<span class="ot"> _stEditType ::</span> <span class="fu">!</span>(<span class="dt">BE.Editor</span> <span class="dt">Text</span> <span class="dt">Name</span>)      <span class="co">-- ^ Editor for the type to search for</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">     ,<span class="ot"> _stEditText ::</span> <span class="fu">!</span>(<span class="dt">BE.Editor</span> <span class="dt">Text</span> <span class="dt">Name</span>)      <span class="co">-- ^ Editor for a text search in the results</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">     ,<span class="ot"> _stResultsList ::</span> <span class="fu">!</span>(<span class="dt">BL.List</span> <span class="dt">Name</span> <span class="dt">H.Target</span>) <span class="co">-- ^ List for the search results</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">     ,<span class="ot"> _stFocus ::</span> <span class="fu">!</span>(<span class="dt">BF.FocusRing</span> <span class="dt">Name</span>)           <span class="co">-- ^ Focus ring - a circular list of focusable controls</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">     ,<span class="ot"> _stTime ::</span> <span class="fu">!</span><span class="dt">Tm.LocalTime</span>                   <span class="co">-- ^ The current time</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">     ,<span class="ot"> _stResults ::</span> [<span class="dt">H.Target</span>]                   <span class="co">-- ^ The last set of search results from hoohle</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">     ,<span class="ot"> _stSortResults ::</span> <span class="dt">SortBy</span>                   <span class="co">-- ^ Current sort order for the results</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">     }</a>
<a class="sourceLine" id="cb3-18" data-line-number="18"></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">makeLenses <span class="ch">&#39;&#39;</span><span class="dt">BrickState</span></a></code></pre></div>
<p><strong>BrickState</strong> contains the current state of the brick application. Any event e.g. the custom update time event, or any key press event can result in the state being updated. There is a separate draw function that renders the state.</p>
<p>I.e. one part of the code deals with events, roughly <code>state -&gt; event -&gt; state</code> and another handles the drawing <code>state -&gt; GUI</code></p>
<p>Here the state contains</p>
<ol type="1">
<li>The three controls mentioned above (two edit + one listbox)</li>
<li>A focus ring. (A <a href="https://hackage.haskell.org/package/brick-0.33/docs/Brick-Focus.html">focus ring</a> is a circular list of control names that helps your code keep track of which control has the current focus).</li>
<li>The last updated current time</li>
<li>The last search result</li>
<li>The current sort order, so that it can be toggled between ascending and descending</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- | Defines how the brick application will work / handle events</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">app ::</span> <span class="dt">B.App</span> <span class="dt">BrickState</span> <span class="dt">Event</span> <span class="dt">Name</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">app <span class="fu">=</span> <span class="dt">B.App</span> { B.appDraw <span class="fu">=</span> drawUI</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">            , B.appChooseCursor <span class="fu">=</span> B.showFirstCursor</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">            , B.appHandleEvent <span class="fu">=</span> handleEvent</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">            , B.appStartEvent <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">            , B.appAttrMap <span class="fu">=</span> const theMap</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">            }</a></code></pre></div>
<p>The <strong>App</strong> type defines how the brick app operates, but defining how events are handled (<code>appHandleEvent</code>) and how the GUI is drawn (<code>appDraw</code>)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  chan <span class="ot">&lt;-</span> BCh.newBChan <span class="dv">5</span> <span class="co">-- ^ create a bounded channel for events</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="co">-- Send a tick event every 1 seconds with the current time</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="co">-- Brick will send this to our event handler which can then update the stTime field</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  void <span class="fu">.</span> forkIO <span class="fu">$</span> forever <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    t <span class="ot">&lt;-</span> getTime </a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    BCh.writeBChan chan <span class="fu">$</span> <span class="dt">EventUpdateTime</span> t</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    threadDelay <span class="fu">$</span> <span class="dv">1</span> <span class="fu">*</span> <span class="dv">1000000</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  <span class="co">-- Initial current time value</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  t <span class="ot">&lt;-</span> getTime</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  <span class="co">-- Construct the initial state values</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="kw">let</span> st <span class="fu">=</span> <span class="dt">BrickState</span> { _stEditType <span class="fu">=</span> BE.editor <span class="dt">TypeSearch</span> (<span class="dt">Just</span> <span class="dv">1</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">                      , _stEditText <span class="fu">=</span> BE.editor <span class="dt">TextSearch</span> (<span class="dt">Just</span> <span class="dv">1</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">                      , _stResultsList <span class="fu">=</span> BL.list <span class="dt">ListResults</span> Vec.empty <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">                      , _stTime <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">                      , _stFocus <span class="fu">=</span> BF.focusRing [<span class="dt">TypeSearch</span>, <span class="dt">TextSearch</span>, <span class="dt">ListResults</span>]</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">                      , _stResults <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">                      , _stSortResults <span class="fu">=</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb5-23" data-line-number="23">                      }</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">          </a>
<a class="sourceLine" id="cb5-25" data-line-number="25">  <span class="co">-- Run brick</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">  void <span class="fu">$</span> B.customMain (V.mkVty V.defaultConfig) (<span class="dt">Just</span> chan) app st</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">    <span class="co">-- | Get the local time</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    getTime <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">      t <span class="ot">&lt;-</span> Tm.getCurrentTime</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">      tz <span class="ot">&lt;-</span> Tm.getCurrentTimeZone</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">      pure <span class="fu">$</span> Tm.utcToLocalTime tz t</a></code></pre></div>
<p>In <strong>main</strong> some setup is preformed and then brick is started by calling <code>customMain</code>.</p>
<p>For bhoogle the steps are</p>
<ol type="1">
<li>Construct the channel for brick events (passed to <code>customMain</code>)</li>
<li>Create a new thread to send the current time every second</li>
<li>Construct an initial state, with empty controls and search results</li>
<li><code>B.customMain</code> to run brick</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- | Main even handler for brick events</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">handleEvent ::</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">B.BrickEvent</span> <span class="dt">Name</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">B.EventM</span> <span class="dt">Name</span> (<span class="dt">B.Next</span> <span class="dt">BrickState</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">handleEvent st ev <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">case</span> ev <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    (<span class="dt">B.AppEvent</span> (<span class="dt">EventUpdateTime</span> time)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      <span class="co">-- Update the time in the state</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">      B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stTime <span class="fu">.~</span> time</a></code></pre></div>
<p><strong>handleEvent</strong> gets all the brick events, updates the state and decides how to continue.</p>
<p>Here the code matches the custom (<strong>B.AppEvent</strong>) event looking for our update time event (<strong>EventUpdateTime</strong>) and then updates the state with the current time. <code>B.continue</code> means that brick continues after updating the state. Note that the UI is not changed in any way here, we are just altering the current state.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">    <span class="co">-- Handle keyboard events</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="co">--   k is the key</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="co">--   ms are the modifier keys</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    (<span class="dt">B.VtyEvent</span> ve<span class="fu">@</span>(<span class="dt">V.EvKey</span> k ms)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">      <span class="kw">case</span> (k, ms) <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        <span class="co">-- Escape quits the app, no matter what control has focus</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        (<span class="dt">K.KEsc</span>, []) <span class="ot">-&gt;</span> B.halt st</a></code></pre></div>
<p>Then the code matches any keyboard event (<strong>B.VtyEvent</strong>) here matching on the escape key (<strong>K.KEsc</strong>). So when the user clicks the escape key this handler will call <code>B.halt</code> which will terminate the app. As this is done at the top level, this means that no matter which control has the focus, escape will exit.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">        _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">          <span class="co">-- How to interpret the key press depends on which control is focused</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="kw">case</span> BF.focusGetCurrent <span class="fu">$</span> st <span class="fu">^.</span> stFocus <span class="kw">of</span></a></code></pre></div>
<p>For the rest of the key press logic, what bhoogle does depends on which control has the focus. <code>BF.focusGetCurrent</code> is used to get that from the state’s focus ring.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">            <span class="dt">Just</span> <span class="dt">TypeSearch</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">              <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                <span class="dt">K.KChar</span> <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">                  <span class="co">-- Search, clear sort order, focus next</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">                  found <span class="ot">&lt;-</span> doSearch st</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusNext</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">                                                  <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">                                                  <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">                <span class="dt">K.KBackTab</span> <span class="ot">-&gt;</span><span class="kw">do</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">                  <span class="co">-- Search, clear sort order, focus prev</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">                  found <span class="ot">&lt;-</span> doSearch st</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">                  B.continue  <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusPrev</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">                                                   <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">                                                   <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a></code></pre></div>
<p>If the user is typing in the “type” edit box and tabs out (either tab or shift-tab) then</p>
<ol type="1">
<li>Perform the search (see <strong>doSearch</strong> below)</li>
<li>Update the current set of results</li>
<li>Reset the sort order, default to the order that hoogle uses</li>
<li>Move the focus to the next/previous control</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">                <span class="dt">K.KEnter</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">                  <span class="co">-- Search, clear sort order, focus on results</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">                  <span class="co">--  This makes it faster if you want to search and navigate </span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                  <span class="co">--  results without tabing through the text search box</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                  found <span class="ot">&lt;-</span> doSearch st</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                                                  <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">                                                  <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusSetCurrent <span class="dt">ListResults</span></a></code></pre></div>
<p>If the user presses <strong>enter</strong> while in the type search edit box, then</p>
<ol type="1">
<li>Perform the search (see <strong>doSearch</strong> below)</li>
<li>Update the current set of results</li>
<li>Reset the sort order, default to the order that hoogle uses</li>
<li>Move the focus directly to the results lisbox so they can navigate and see the current item’s details &amp; help text</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">                _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">                  <span class="co">-- Let the editor handle all other events</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">                  r <span class="ot">&lt;-</span> BE.handleEditorEvent ve <span class="fu">$</span> st <span class="fu">^.</span> stEditType</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">                  next <span class="ot">&lt;-</span> liftIO <span class="fu">.</span> searchAhead doSearch <span class="fu">$</span> st <span class="fu">&amp;</span> stEditType <span class="fu">.~</span> r </a>
<a class="sourceLine" id="cb11-5" data-line-number="5">                  B.continue next</a></code></pre></div>
<p>For all other key events for the type search, let the editor control handle the key press. This gives us editing, navigation etc for free.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">            <span class="dt">Just</span> <span class="dt">TextSearch</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">              <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                <span class="dt">K.KChar</span> <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusNext <span class="co">-- Focus next</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">                <span class="dt">K.KBackTab</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusPrev   <span class="co">-- Focus previous</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">                _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">                  <span class="co">-- Let the editor handle all other events</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">                  r <span class="ot">&lt;-</span> BE.handleEditorEvent ve <span class="fu">$</span> st <span class="fu">^.</span> stEditText</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stEditText <span class="fu">.~</span> r</a></code></pre></div>
<p>For the text edit box</p>
<ol type="1">
<li>Change focus on tab / shift-tab</li>
<li>For all other keys
<ol type="1">
<li>Let the editor handle the key press</li>
<li>Filter the hoogle results</li>
</ol></li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">            <span class="dt">Just</span> <span class="dt">ListResults</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">              <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">                <span class="dt">K.KChar</span> <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusNext <span class="co">-- Focus next</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">                <span class="dt">K.KBackTab</span> <span class="ot">-&gt;</span> B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stFocus <span class="fu">%~</span> BF.focusPrev   <span class="co">-- Focus previous</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">                <span class="dt">K.KChar</span> <span class="ch">&#39;s&#39;</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">                  <span class="co">-- Toggle the search order between ascending and descending,</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">                  <span class="co">--  use asc if sort order was &#39;none&#39;</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">                  <span class="kw">let</span> sortDir <span class="fu">=</span> <span class="kw">if</span> (st <span class="fu">^.</span> stSortResults) <span class="fu">==</span> <span class="dt">SortAsc</span> </a>
<a class="sourceLine" id="cb13-9" data-line-number="9">                                  <span class="kw">then</span> <span class="dt">SortDec</span> </a>
<a class="sourceLine" id="cb13-10" data-line-number="10">                                  <span class="kw">else</span> <span class="dt">SortAsc</span> </a>
<a class="sourceLine" id="cb13-11" data-line-number="11">                  <span class="kw">in</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">                  <span class="kw">let</span> sorter <span class="fu">=</span> <span class="kw">if</span> sortDir <span class="fu">==</span> <span class="dt">SortDec</span> </a>
<a class="sourceLine" id="cb13-13" data-line-number="13">                                 <span class="kw">then</span> (Lst.sortBy <span class="fu">$</span> flip compareType) </a>
<a class="sourceLine" id="cb13-14" data-line-number="14">                                 <span class="kw">else</span> (Lst.sortBy compareType) </a>
<a class="sourceLine" id="cb13-15" data-line-number="15">                  <span class="kw">in</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                  B.continue <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">%~</span> sorter</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">                                                  <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> sortDir</a>
<a class="sourceLine" id="cb13-18" data-line-number="18"></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">                _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20">                  <span class="co">-- Let the list handle all other events</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">                  <span class="co">-- Using handleListEventVi which adds vi-style keybindings for navigation</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">                  <span class="co">--  and the standard handleListEvent as a fallback for all other events</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23">                  r <span class="ot">&lt;-</span> BL.handleListEventVi BL.handleListEvent ve <span class="fu">$</span> st <span class="fu">^.</span> stResultsList</a>
<a class="sourceLine" id="cb13-24" data-line-number="24">                  B.continue <span class="fu">$</span> st <span class="fu">&amp;</span> stResultsList <span class="fu">.~</span> r</a>
<a class="sourceLine" id="cb13-25" data-line-number="25"></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">            _ <span class="ot">-&gt;</span> B.continue st</a>
<a class="sourceLine" id="cb13-27" data-line-number="27"></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">    _ <span class="ot">-&gt;</span> B.continue st</a></code></pre></div>
<p>For the results listbox</p>
<ul>
<li>Handle tab / shift-tab</li>
<li>Pressing the <strong>‘s’</strong> key will sort the results. Pressing it again toggles the direction, so keep track of which order was used last.</li>
<li>For all other keys use <code>BL.handleListEventVi BL.handleListEvent</code> which gives us vi style navigation and uses the standard <strong>handleListEvent</strong> as the fallback, so that all the normal navigation (arrows) also work.</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    doSearch st&#39; <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-3" data-line-number="3">      liftIO <span class="fu">$</span> searchHoogle (Txt.strip <span class="fu">.</span> Txt.concat <span class="fu">$</span> BE.getEditContents (st&#39; <span class="fu">^.</span> stEditType))</a></code></pre></div>
<p>And finally for <strong>handleEvent</strong> the <strong>doSearch</strong> function which calls the <strong>searchHoogle</strong> function (below) to search on the text from the type editbox.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- | Search ahead for type strings longer than 3 chars.</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">searchAhead ::</span> (<span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">H.Target</span>]) <span class="ot">-&gt;</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">BrickState</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">searchAhead search st <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="kw">let</span> searchText <span class="fu">=</span> Txt.strip <span class="fu">.</span> Txt.concat <span class="fu">.</span> BE.getEditContents <span class="fu">$</span> st <span class="fu">^.</span> stEditType <span class="kw">in</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">if</span> Txt.length searchText <span class="fu">&gt;</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    <span class="co">-- Search</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    found <span class="ot">&lt;-</span> search st</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    pure <span class="fu">.</span> filterResults <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">.~</span> found</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">                              <span class="fu">&amp;</span> stSortResults <span class="fu">.~</span> <span class="dt">SortNone</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    <span class="co">-- Just clear</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">    pure <span class="fu">$</span> st <span class="fu">&amp;</span> stResults <span class="fu">.~</span> []</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">              <span class="fu">&amp;</span> stResultsList <span class="fu">%~</span> BL.listClear</a></code></pre></div>
<p><strong>searchAhead</strong> is a helper function that searches hoogle as the user types. As long as there are more than three characters being searched for. Without this limit hoogle seems a bit slow on my machine because of the large number of results.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- | Filter the results from hoogle using the search text</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">filterResults ::</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> <span class="dt">BrickState</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">filterResults st <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">let</span> allResults <span class="fu">=</span> st <span class="fu">^.</span> stResults <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  <span class="kw">let</span> filterText <span class="fu">=</span> Txt.toLower <span class="fu">.</span> Txt.strip <span class="fu">.</span> Txt.concat <span class="fu">.</span> BE.getEditContents <span class="fu">$</span> st <span class="fu">^.</span> stEditText <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  <span class="kw">let</span> results <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">        <span class="kw">if</span> Txt.null filterText</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">        <span class="kw">then</span> allResults</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">        <span class="kw">else</span> filter (\t <span class="ot">-&gt;</span> Txt.isInfixOf filterText <span class="fu">.</span> Txt.toLower <span class="fu">$</span> formatResult t) allResults</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  st <span class="fu">&amp;</span> stResultsList <span class="fu">.~</span> BL.list <span class="dt">ListResults</span> (Vec.fromList results) <span class="dv">1</span></a></code></pre></div>
<p>Filter the hoogle results by doing a sub-string search if the user has entered one</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- | Draw the UI</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">drawUI ::</span> <span class="dt">BrickState</span> <span class="ot">-&gt;</span> [<span class="dt">B.Widget</span> <span class="dt">Name</span>]</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">drawUI st <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  [B.padAll <span class="dv">1</span> contentBlock] </a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    contentBlock <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">      (B.withBorderStyle BBS.unicode <span class="fu">$</span> BB.border searchBlock)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">      B.padTop (<span class="dt">B.Pad</span> <span class="dv">1</span>) resultsBlock</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">      </a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    resultsBlock <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">      <span class="kw">let</span> total <span class="fu">=</span> show <span class="fu">.</span> length <span class="fu">$</span> st <span class="fu">^.</span> stResults <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">      <span class="kw">let</span> showing <span class="fu">=</span> show <span class="fu">.</span> length <span class="fu">$</span> st <span class="fu">^.</span> stResultsList <span class="fu">^.</span> BL.listElementsL <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">      (B.withAttr <span class="st">&quot;infoTitle&quot;</span> <span class="fu">$</span> B.txt <span class="st">&quot;Results: &quot;</span>) <span class="fu">&lt;+&gt;</span> B.txt (showing <span class="fu">&lt;&gt;</span> <span class="st">&quot;/&quot;</span> <span class="fu">&lt;&gt;</span> total)</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-17" data-line-number="17">      (B.padTop (<span class="dt">B.Pad</span> <span class="dv">1</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-18" data-line-number="18">       resultsContent <span class="fu">&lt;+&gt;</span> resultsDetail</a>
<a class="sourceLine" id="cb17-19" data-line-number="19">      )</a>
<a class="sourceLine" id="cb17-20" data-line-number="20"></a>
<a class="sourceLine" id="cb17-21" data-line-number="21">    resultsContent <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">      BL.renderList (\_ e <span class="ot">-&gt;</span> B.txt <span class="fu">$</span> formatResult e) <span class="dt">False</span> (st <span class="fu">^.</span> stResultsList)</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">    resultsDetail <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-25" data-line-number="25">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">1</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-26" data-line-number="26">      B.hLimit <span class="dv">60</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-27" data-line-number="27">      vtitle <span class="st">&quot;package:&quot;</span></a>
<a class="sourceLine" id="cb17-28" data-line-number="28">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-29" data-line-number="29">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">2</span>) (B.txt <span class="fu">$</span> getSelectedDetail (\t <span class="ot">-&gt;</span> maybe <span class="st">&quot;&quot;</span> (Txt.pack <span class="fu">.</span> fst) (H.targetPackage t)))</a>
<a class="sourceLine" id="cb17-30" data-line-number="30">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-31" data-line-number="31">      vtitle <span class="st">&quot;module:&quot;</span></a>
<a class="sourceLine" id="cb17-32" data-line-number="32">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-33" data-line-number="33">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">2</span>) (B.txt <span class="fu">$</span> getSelectedDetail (\t <span class="ot">-&gt;</span> maybe <span class="st">&quot;&quot;</span> (Txt.pack <span class="fu">.</span> fst) (H.targetModule t)))</a>
<a class="sourceLine" id="cb17-34" data-line-number="34">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-35" data-line-number="35">      vtitle <span class="st">&quot;docs:&quot;</span></a>
<a class="sourceLine" id="cb17-36" data-line-number="36">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-37" data-line-number="37">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">2</span>) (B.txt <span class="fu">$</span> getSelectedDetail (Txt.pack <span class="fu">.</span> clean <span class="fu">.</span> H.targetDocs))</a>
<a class="sourceLine" id="cb17-38" data-line-number="38">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-39" data-line-number="39">      B.fill <span class="ch">&#39; &#39;</span></a>
<a class="sourceLine" id="cb17-40" data-line-number="40">  </a>
<a class="sourceLine" id="cb17-41" data-line-number="41">    searchBlock <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-42" data-line-number="42">      ((htitle <span class="st">&quot;Type: &quot;</span> <span class="fu">&lt;+&gt;</span> editor <span class="dt">TypeSearch</span> (st <span class="fu">^.</span> stEditType)) <span class="fu">&lt;+&gt;</span> time (st <span class="fu">^.</span> stTime))</a>
<a class="sourceLine" id="cb17-43" data-line-number="43">      <span class="fu">&lt;=&gt;</span></a>
<a class="sourceLine" id="cb17-44" data-line-number="44">      (htitle <span class="st">&quot;Text: &quot;</span> <span class="fu">&lt;+&gt;</span> editor <span class="dt">TextSearch</span> (st <span class="fu">^.</span> stEditText))</a>
<a class="sourceLine" id="cb17-45" data-line-number="45"></a>
<a class="sourceLine" id="cb17-46" data-line-number="46">    htitle t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-47" data-line-number="47">      B.hLimit <span class="dv">20</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-48" data-line-number="48">      B.withAttr <span class="st">&quot;infoTitle&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-49" data-line-number="49">      B.txt t</a>
<a class="sourceLine" id="cb17-50" data-line-number="50">      </a>
<a class="sourceLine" id="cb17-51" data-line-number="51">    vtitle t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-52" data-line-number="52">      B.withAttr <span class="st">&quot;infoTitle&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-53" data-line-number="53">      B.txt t</a>
<a class="sourceLine" id="cb17-54" data-line-number="54"></a>
<a class="sourceLine" id="cb17-55" data-line-number="55">    editor n e <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-56" data-line-number="56">      B.vLimit <span class="dv">1</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-57" data-line-number="57">      BE.renderEditor (B.txt <span class="fu">.</span> Txt.unlines) (BF.focusGetCurrent (st <span class="fu">^.</span> stFocus) <span class="fu">==</span> <span class="dt">Just</span> n) e</a>
<a class="sourceLine" id="cb17-58" data-line-number="58"></a>
<a class="sourceLine" id="cb17-59" data-line-number="59">    time t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-60" data-line-number="60">      B.padLeft (<span class="dt">B.Pad</span> <span class="dv">1</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-61" data-line-number="61">      B.hLimit <span class="dv">20</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-62" data-line-number="62">      B.withAttr <span class="st">&quot;time&quot;</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb17-63" data-line-number="63">      B.str (Tm.formatTime Tm.defaultTimeLocale <span class="st">&quot;%H-%M-%S&quot;</span> t)</a>
<a class="sourceLine" id="cb17-64" data-line-number="64"></a>
<a class="sourceLine" id="cb17-65" data-line-number="65">    getSelectedDetail fn <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-66" data-line-number="66">      <span class="kw">case</span> BL.listSelectedElement <span class="fu">$</span> st <span class="fu">^.</span> stResultsList <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-67" data-line-number="67">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb17-68" data-line-number="68">        <span class="dt">Just</span> (_, e) <span class="ot">-&gt;</span> fn e</a></code></pre></div>
<p><strong>drawUI</strong> renders the state and creates the GUI. At first this may take some getting used to, but you will soon be able to see the GUI structure from the code.</p>
<ul>
<li><code>&lt;=&gt;</code> means horizontal break, i.e. next “line”</li>
<li><code>&lt;+&gt;</code> means “next to”</li>
<li>I often end up formatting code slightly differently to how I would in the other functions to better communicate the structure</li>
<li><p>Create small GUI fragments/“controls” and combine them with <code>&lt;+&gt;</code> and <code>&lt;=&gt;</code></p>
For example <strong>htitle</strong> creates a “title” by
<ul>
<li>Limiting the max width to 20</li>
<li>Setting the attribute to <strong>infoTitle</strong></li>
<li>Displaying the text using <code>B.txt</code> (<code>B.txt</code> displays a Text, <code>B.str</code> displays a string/[char])</li>
</ul></li>
<li><p><code>B.fill ' '</code> is used to get brick to fill to the maximum width (here 60) rather that having the right detail pain growing/shrinking as the data changes.</p></li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">theMap ::</span> <span class="dt">BA.AttrMap</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">theMap <span class="fu">=</span> BA.attrMap V.defAttr [ (BE.editAttr        , V.black <span class="ot">`B.on`</span> V.cyan)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">                              , (BE.editFocusedAttr , V.black <span class="ot">`B.on`</span> V.yellow)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">                              , (BL.listAttr        , V.white <span class="ot">`B.on`</span> V.blue)</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">                              , (BL.listSelectedAttr, V.blue <span class="ot">`B.on`</span> V.white)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">                              , (<span class="st">&quot;infoTitle&quot;</span>        , B.fg V.cyan)</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">                              , (<span class="st">&quot;time&quot;</span>             , B.fg V.yellow)</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">                              ]</a></code></pre></div>
<p>The attribute map is where attributes for the controls and custom attributes are defined. This makes it easy to change how the GUI looks. There is even support <a href="https://hackage.haskell.org/package/brick-0.33/docs/Brick-Themes.html">for themes</a> and basic <a href="https://hackage.haskell.org/package/brick-0.33/docs/Brick-Markup.html">markup</a>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">----------------------------------------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="co">-- | Compare two hoogle results for sorting</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">compareType ::</span> <span class="dt">H.Target</span> <span class="ot">-&gt;</span> <span class="dt">H.Target</span> <span class="ot">-&gt;</span> <span class="dt">Ordering</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">compareType a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  compare (formatResult a) (formatResult b)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6"></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb19-8" data-line-number="8"><span class="co">-- | Search hoogle using the default hoogle database</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">searchHoogle ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">H.Target</span>]</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">searchHoogle f <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  d <span class="ot">&lt;-</span> H.defaultDatabaseLocation </a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  H.withDatabase d (\x <span class="ot">-&gt;</span> pure <span class="fu">$</span> H.searchDatabase x (Txt.unpack f))</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb19-14" data-line-number="14"></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="co">-- | Format the hoogle results so they roughly match what the terminal app would show</span></a>
<a class="sourceLine" id="cb19-16" data-line-number="16"><span class="ot">formatResult ::</span> <span class="dt">H.Target</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">formatResult t <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18">  <span class="kw">let</span> typ <span class="fu">=</span> clean <span class="fu">$</span> H.targetItem t <span class="kw">in</span></a>
<a class="sourceLine" id="cb19-19" data-line-number="19">  <span class="kw">let</span> m <span class="fu">=</span> (clean <span class="fu">.</span> fst) <span class="fu">&lt;$&gt;</span> H.targetModule t <span class="kw">in</span></a>
<a class="sourceLine" id="cb19-20" data-line-number="20">  Txt.pack <span class="fu">$</span> fromMaybe <span class="st">&quot;&quot;</span> m <span class="fu">&lt;&gt;</span> <span class="st">&quot; :: &quot;</span> <span class="fu">&lt;&gt;</span> typ</a>
<a class="sourceLine" id="cb19-21" data-line-number="21">  </a>
<a class="sourceLine" id="cb19-22" data-line-number="22"></a>
<a class="sourceLine" id="cb19-23" data-line-number="23"><span class="ot">clean ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb19-24" data-line-number="24">clean <span class="fu">=</span> unescapeHTML <span class="fu">.</span> stripTags</a>
<a class="sourceLine" id="cb19-25" data-line-number="25"></a>
<a class="sourceLine" id="cb19-26" data-line-number="26"></a>
<a class="sourceLine" id="cb19-27" data-line-number="27"><span class="co">-- | From hoogle source: https://hackage.haskell.org/package/hoogle-5.0.16/docs/src/General-Util.html</span></a>
<a class="sourceLine" id="cb19-28" data-line-number="28"><span class="ot">unescapeHTML ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb19-29" data-line-number="29">unescapeHTML (<span class="ch">&#39;&amp;&#39;</span><span class="fu">:</span>xs)</a>
<a class="sourceLine" id="cb19-30" data-line-number="30">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;lt;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;&lt;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-31" data-line-number="31">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;gt;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;&gt;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-32" data-line-number="32">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;amp;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;&amp;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-33" data-line-number="33">    <span class="fu">|</span> <span class="dt">Just</span> x <span class="ot">&lt;-</span> Lst.stripPrefix <span class="st">&quot;quot;&quot;</span> xs <span class="fu">=</span> <span class="ch">&#39;\&quot;&#39;</span> <span class="fu">:</span> unescapeHTML x</a>
<a class="sourceLine" id="cb19-34" data-line-number="34">unescapeHTML (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> unescapeHTML xs</a>
<a class="sourceLine" id="cb19-35" data-line-number="35">unescapeHTML [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb19-36" data-line-number="36">  </a>
<a class="sourceLine" id="cb19-37" data-line-number="37"></a>
<a class="sourceLine" id="cb19-38" data-line-number="38"><span class="co">-- | From hakyll source: https://hackage.haskell.org/package/hakyll-4.1.2.1/docs/src/Hakyll-Web-Html.html#stripTags</span></a>
<a class="sourceLine" id="cb19-39" data-line-number="39"><span class="ot">stripTags ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb19-40" data-line-number="40">stripTags []         <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb19-41" data-line-number="41">stripTags (<span class="ch">&#39;&lt;&#39;</span> <span class="fu">:</span> xs) <span class="fu">=</span> stripTags <span class="fu">$</span> drop <span class="dv">1</span> <span class="fu">$</span> dropWhile (<span class="fu">/=</span> <span class="ch">&#39;&gt;&#39;</span>) xs</a>
<a class="sourceLine" id="cb19-42" data-line-number="42">stripTags (x <span class="fu">:</span> xs)   <span class="fu">=</span> x <span class="fu">:</span> stripTags xs</a></code></pre></div>
<p>The remainder of the code is non-brick code for searching and formatting hoogle results</p>
<ul>
<li><strong>compareType</strong> compares two results by formatting them first and then comparing the resulting text</li>
<li><strong>searchHoogle</strong> searches hoogle using the default database</li>
<li><strong>formatResults</strong> formats the hoogle results</li>
<li><strong>unescapeHTML</strong> and <strong>stripTags</strong> are used to get plain text from the HTML. Note that this code comes from the <a href="https://hackage.haskell.org/package/hakyll-4.1.2.1/docs/src/Hakyll-Web-Html.html#stripTags">hakyll</a> and <a href="https://hackage.haskell.org/package/hoogle-5.0.16/docs/src/General-Util.html">hoogle</a> source code</li>
</ul>
<h1 id="section"></h1>
<p>Hopefully this example helps you get started with brick and demonstrates how easy brick makes creating terminal UIs</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://github.com/andrevdm/bhoogle/tree/blog">Code on github</a></li>
<li><a href="https://github.com/andrevdm/bhoogle/releases">Releases with prebuilt linux binaries</a></li>
<li><a href="https://github.com/jtdaugherty/brick/blob/master/docs/guide.rst">Brick user guide</a></li>
<li><a href="https://github.com/jtdaugherty/brick/blob/master/docs/samtay-tutorial.md">Samuel Tay’s brick tutorial</a></li>
<li><a href="https://hackage.haskell.org/package/bhoogle">Latest version on hackage</a> - NB code does not match the annotated source above</li>
<li><a href="https://github.com/andrevdm/bhoogle">Latest version on github</a> - NB code does not match the annotated source above</li>
</ul>

]]></summary>
</entry>
<entry>
    <title>Refactoring exception handling using a free monad</title>
    <link href="http://www.andrevdm.com/posts/2018-01-08-refactor-free.html" />
    <id>http://www.andrevdm.com/posts/2018-01-08-refactor-free.html</id>
    <published>2018-01-08T00:00:00Z</published>
    <updated>2018-01-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January  8, 2018
    
</div>

<h1 id="overview">Overview</h1>
<p>In my <a href="http://www.andrevdm.com/posts/2017-10-31-refactor-away-io.html">previous post</a> I showed how I was managing exceptions by using a “wrapper” around a record of functions. In this post I’ll show how a free monad approach can be used to achieve the same goal and compare the two techniques.</p>
<h1 id="recap">Recap</h1>
<h2 id="requirements">Requirements</h2>
<p>This is the requirement for the example app, which is a pipeline of jobs</p>
<ol type="1">
<li>Job
<ol type="1">
<li>Can run any IO action and as a result these actions can fail with exceptions</li>
<li>This is custom code and can fail for any number of reasons, network errors, disk permissions etc</li>
</ol></li>
<li>Pipeline
<ol type="1">
<li>Must run impure jobs but be as pure as possible itself</li>
<li>Must be able to handle job failure (exceptions)</li>
<li>Supports different storage mechanisms, e.g. on disk for local dev vs cloud for production</li>
</ol></li>
<li>Both jobs and the pipeline should be testable</li>
</ol>
<h2 id="intent">Intent</h2>
<p>The idea was to have a record of operations, different implementations of this record are possible (e.g. run locally vs run in cloud). Then a function is called to create a wrapper function for each record field and a wrapper record is created. The functions in the wrapper record catch all synchronous exceptions and convert them to ExceptT.</p>
<p>The benefit of this approach was that more of the code could be written with pure functions without losing the ability to deal with exceptions that could occur at any point if the operations were specialized to IO.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> m <span class="fu">=</span> <span class="dt">Operations</span> {<span class="ot"> opRead ::</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">                               ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">                               }</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">OperationsWrapper</span> m <span class="fu">=</span> <span class="dt">OperationsWrapper</span> {<span class="ot"> opRead ::</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">                                             ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m ()</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">                                             }</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">                                             </a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">mkOpsWrapper ::</span> (<span class="dt">MonadCatch</span> m) <span class="ot">=&gt;</span> <span class="dt">I2.Operations</span> m <span class="ot">-&gt;</span> <span class="dt">OperationsWrapper</span> m</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">mkOpsWrapper o <span class="fu">=</span> <span class="dt">OperationsWrapper</span> { opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opRead o) <span class="ot">`catch`</span> readError)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">                                   , <span class="fu">...</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                                   }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="ot">    readError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    readError e <span class="fu">=</span> pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrRead</span> <span class="fu">$</span> <span class="st">&quot;Error reading: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">      </a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    <span class="fu">...</span></a></code></pre></div>
<h2 id="observations">Observations</h2>
<p>Here is roughly how it worked</p>
<p><img src="/images/free_wrapper.png" /></p>
<ul>
<li>It seems like a fair amount of code is required to add the exception handling and the wrapper record.</li>
<li>The wrapper is specialized to ExceptT. E.g. The test’s are pure, so using the IO exception handling -&gt; ExceptT pattern is unnecessary</li>
<li>Not only is it a lot of code, but the mkOpsWrapper code is also a little messy</li>
</ul>
<h1 id="a-quick-overview-of-free-monads">A quick overview of free monads</h1>
<p>There are many great articles on what free monads are and how they are implemented, see the links below for some of them. So I wont be going into detail about how they work, rather I’ll show how they can be used. But even if you’ve never used a free monad before, you may well be able to follow along with how I use them here.</p>
<h2 id="what-are-they">What are they?</h2>
<p>A free monad way to build a monad from any functor. The rest of the article demonstrates why you might want to use them.</p>
<h2 id="how-will-this-help">How will this help?</h2>
<p>With a free monad you have a function that builds the free monad structure and one or more functions that interpret/run the AST.</p>
<p><img src="/images/free_free.png" /></p>
<p>As the image above illustrates createAst generates the AST. The AST can then be passed to different interpreters that run the AST. With the record based approach you varied the implementation by choosing which record of functions to pass in. Here you use a different interpreter over the same free monad output to vary the implementation. This results in a clean separation of concerns.</p>
<p>Note that you don’t need to use free monads to implement this pattern. You could create an AST using sum types and have interpreters that run that. The advantage of using free is that since it is monadic you get to use Haskell’s <code>do</code> notation. This makes the code that generates the AST feel “natural”, it is a simple embedded domain specific language</p>
<h1 id="the-free-operations">The free operations</h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Control.Monad.Free</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Control.Monad.Free.TH</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="kw">data</span> <span class="dt">OpsF</span> m next <span class="fu">=</span> <span class="dt">OpRead</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> next)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">                 <span class="fu">|</span> <span class="dt">OpWrite</span> <span class="dt">Text</span> next</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">                 <span class="fu">|</span> <span class="dt">OpLog</span> <span class="dt">Text</span> next</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">                 <span class="fu">|</span> <span class="dt">OpRun</span> <span class="dt">Text</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> m <span class="dt">Text</span>) <span class="dt">Text</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> next)</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">                 <span class="kw">deriving</span> (<span class="dt">Functor</span>)</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">makeFree <span class="ch">&#39;&#39;</span><span class="dt">OpsF</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="kw">type</span> <span class="dt">Ops</span> m <span class="fu">=</span> <span class="dt">Free</span> (<span class="dt">OpsF</span> m)</a></code></pre></div>
<p>I’m using template haskell and DeriveFunctor to do all the heavy lifting. I.e. it creates all the types that lift your operations into the Free monad. Not having to manually do this makes creating free monads pretty simple. If you have not used free before I’d suggest reading some of the articles I’ve linked to below to understand the detail, or you can just follow this pattern for now</p>
<ol type="1">
<li>The last type in the data constructor is the “return type”</li>
<li><code>next</code> is what enables the chaining</li>
<li>If the last type is a function returning next, that means that you can bind the value</li>
</ol>
<p>E.g. for OpWrite</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- data OpsF m next = OpWrite Text next</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">--                  | ...</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">do</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  opWrite <span class="st">&quot;param1&quot;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  opWrite <span class="st">&quot;param2&quot;</span></a></code></pre></div>
<ol type="1">
<li><strong>opWrite</strong> is the function created by template Haskell that constructs a <strong>OpWrite</strong>.</li>
<li><strong>opWrite</strong> takes a single param, the <strong>Text</strong> from “OpWrite Text next”</li>
<li>Since there is a <strong>next</strong> you can have multiple statements in the <strong>do</strong> block</li>
</ol>
<p>E.g. for OpRead</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- data OpsF m next = OpRead (Text -&gt; next)</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">--                  | ...</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">do</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  r <span class="ot">&lt;-</span> opRead </a></code></pre></div>
<ol type="1">
<li><strong>opRead</strong> is the function created by template Haskell that constructs a <strong>OpRead</strong>.</li>
<li><strong>opRead</strong> takes no parameters</li>
<li>We can bind to the Text result the <strong>(Text -&gt; next)</strong> from “OpRead (Text -&gt; next)”</li>
</ol>
<p>And here is an example using several of the DSL operations together</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Ops</span> m) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  opLog <span class="fu">$</span> <span class="st">&quot;starting: &quot;</span> <span class="fu">&lt;&gt;</span> x</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  r <span class="ot">&lt;-</span> opRead</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  opWrite <span class="fu">$</span> r <span class="fu">&lt;&gt;</span> x</a></code></pre></div>
<h2 id="interpreting">Interpreting</h2>
<p>After running the <strong>createAst</strong> function what you have is an AST. opRead etc do nothing on their own. This is the magic of using free with do notation. We go to write normal, pure, code and we end up with an AST.</p>
<p>Given this AST it is possible to write different interpreters that act in various ways. E.g. one for testing, one for local, one for running in the cloud etc.</p>
<h1 id="was-this-not-about-exceptions">Was this not about exceptions?</h1>
<p>Yes, lets write an interpreter that, similar to the record wrapper approach, catches exceptions.</p>
<p>However before starting its worth reiterating a few points about exceptions from my previous post. Remember that it is usually a very bad idea to catch all exceptions as you may end up catching exceptions that you ought not to catch. See <a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in Haskell</a> for a good overview. There are several ways to ensure that you are only catch asynchronous exceptions. In these examples I’m going to be using the <a href="https://hackage.haskell.org/package/safe-exceptions">safe exceptions</a> package which does exactly that.</p>
<p>Right, back to the code. In this example interpreterFile is a function that interprets the AST and uses a file to store/load the state</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- Make sure that the SafeException functions are used</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Protolude</span> <span class="kw">hiding</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Exception.Safe</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">interpreterFile ::</span> (<span class="dt">Ops</span> <span class="dt">IO</span>) <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">interpreterFile o <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">case</span> o <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="dt">Pure</span> a <span class="ot">-&gt;</span> pure a   <span class="co">-- no next action</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    (<span class="dt">Free</span> (<span class="dt">OpRead</span> n)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        r <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> Txt.readFile <span class="st">&quot;data.txt&quot;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">        interpreterFile <span class="fu">$</span> n r  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">      <span class="ot">`catch`</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">        handler <span class="dt">ErrRead</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17"></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    (<span class="dt">Free</span> (<span class="dt">OpWrite</span> t n)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">      <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">        liftIO <span class="fu">$</span> Txt.writeFile <span class="st">&quot;data.txt&quot;</span> t</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">        interpreterFile n  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">      <span class="ot">`catch`</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">        handler <span class="dt">ErrWrite</span></a>
<a class="sourceLine" id="cb6-24" data-line-number="24">      </a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    (<span class="dt">Free</span> (<span class="dt">OpRun</span> name fn t n)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">      <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-27" data-line-number="27">        r <span class="ot">&lt;-</span> lift <span class="fu">$</span> fn t</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">        interpreterFile <span class="fu">$</span> n r  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-29" data-line-number="29">      <span class="ot">`catch`</span></a>
<a class="sourceLine" id="cb6-30" data-line-number="30">        handler (<span class="dt">ErrRunning</span> name)</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">      </a>
<a class="sourceLine" id="cb6-32" data-line-number="32">    (<span class="dt">Free</span> (<span class="dt">OpLog</span> t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-33" data-line-number="33">      putText <span class="fu">$</span> <span class="st">&quot;log: &quot;</span> <span class="fu">&lt;&gt;</span> t</a>
<a class="sourceLine" id="cb6-34" data-line-number="34">      interpreterFile n  <span class="co">-- run next</span></a>
<a class="sourceLine" id="cb6-35" data-line-number="35"></a>
<a class="sourceLine" id="cb6-36" data-line-number="36">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-37" data-line-number="37"><span class="ot">    handler ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">OpsError</span>) <span class="ot">-&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-38" data-line-number="38">    handler ope e <span class="fu">=</span> throwE <span class="fu">.</span> ope <span class="fu">$</span> show e  <span class="co">-- catch exception and use ExceptT&#39;s throwE</span></a></code></pre></div>
<p>The operations are run and any synchronous exception is caught and handled in the ExceptT. This looks pretty similar to the record based approach but I think is simpler.</p>
<h2 id="testing">Testing</h2>
<p>Here is an interpreter for testing which uses a state monad to store/retrieve the state</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TestState</span> <span class="fu">=</span> <span class="dt">TestState</span> {<span class="ot"> tstValue ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">                           ,<span class="ot"> tstLog ::</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">                           } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="ot">interpreterState ::</span> (<span class="dt">Ops</span> (<span class="dt">S.State</span> <span class="dt">TestState</span>)) <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">S.State</span> <span class="dt">TestState</span>) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">interpreterState o <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">case</span> o <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    <span class="dt">Pure</span> a <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">      modify (\s <span class="ot">-&gt;</span> s { tstValue <span class="fu">=</span> a })</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">      tstValue <span class="fu">&lt;$&gt;</span> get</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    (<span class="dt">Free</span> (<span class="dt">OpRead</span> n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">      st <span class="ot">&lt;-</span> S.get </a>
<a class="sourceLine" id="cb7-14" data-line-number="14">      interpreterState <span class="fu">$</span> n (tstValue st)</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">    (<span class="dt">Free</span> (<span class="dt">OpWrite</span> t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">      S.modify (\s <span class="ot">-&gt;</span> s { tstValue <span class="fu">=</span> t } )</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">      interpreterState n</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">      </a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    (<span class="dt">Free</span> (<span class="dt">OpRun</span> _ fn t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">      r <span class="ot">&lt;-</span> fn t</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">      interpreterState <span class="fu">$</span> n r</a>
<a class="sourceLine" id="cb7-23" data-line-number="23">      </a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    (<span class="dt">Free</span> (<span class="dt">OpLog</span> t n)) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">      S.modify (\(<span class="dt">TestState</span> s ls) <span class="ot">-&gt;</span> <span class="dt">TestState</span> s <span class="fu">$</span> ls <span class="fu">&lt;&gt;</span> [t])</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">      interpreterState n</a></code></pre></div>
<p>Compare that to the previous approach’s tests</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">testPipeline ::</span> [<span class="dt">I2.Job</span> (<span class="dt">S.State</span> <span class="dt">Text</span>)] <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">S.State</span> <span class="dt">Text</span> (<span class="dt">Either</span> <span class="dt">I3.OpsError</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">testPipeline jobs initial <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">let</span> ops <span class="fu">=</span> <span class="dt">I3.OperationsWrapper</span> { I3.opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                                     r <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> r</a></code></pre></div>
<p>The big advantage here is that the tests are no longer forced to use ExceptT. Each interpreter, for testing or otherwise, can use whatever stack is appropriate</p>
<h1 id="problems">Problems</h1>
<p>As always there are trade offs, see the <a href="https://markkarpov.com/post/free-monad-considered-harmful.html">Free monad considered harmful</a> article for example. While some of these issues can be address (e.g. see church encoding below) it is worth considering alternatives.</p>
<p>Personally, so far, I’ve found free to be a great fit for what I need (e.g. selecting implementation not based on type), but its definitely worth deciding on a case by case basis</p>
<h1 id="church-encoding">Church encoding</h1>
<p>The <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-Church.html">Control.Monad.Free.Church</a> package handles church encoding of a free monad. This can be important to do because, as it says in <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-Church.html">Control.Monad.Free.Church</a>:</p>
<p><em><code>Even if the Haskell runtime optimizes some of the overhead through laziness and generational garbage collection, the asymptotic runtime is still quadratic. On the other hand, if the Church encoding is used, the tree only needs to be constructed once.</code></em></p>
<p>Given how easy this package makes church encoding, and how bad O(n^2) performance can be, it is almost always a good idea to do the encoding.</p>
<p><em>(I originally found getting the types correct for Church encoding a bit tricky. This <a href="https://github.com/queertypes/free-tutorial">Free monad and church encoding example</a> helped clear up a lot of the confusion for me. Be sure to look at it as well if my explanation below does not help you).</em></p>
<p>To get Church encoding, the only requirement is that you use a MonadFree constraint rather than your more specific data type for the function that generates the DSL.</p>
<p>In the example above createAst looked like this.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Ops</span> m) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a></code></pre></div>
<p>The problem is that I’ve used the “<code>Ops m</code>” type, rather than MonadFree.</p>
<p>Here is what it should look like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadFree</span> (<span class="dt">OpsF</span> m) a) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span> m] <span class="ot">-&gt;</span> a <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a></code></pre></div>
<p>The important parts being</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">createAst ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadFree</span> (<span class="dt">OpsF</span> m) a) <span class="ot">=&gt;</span> <span class="fu">...............</span> <span class="ot">-&gt;</span> a <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">createAst x <span class="fu">=</span> <span class="kw">do</span></a></code></pre></div>
<ul>
<li>Change from Ops to OpsF</li>
<li>Add “<code>MonadFree (...) a</code>”</li>
</ul>
<p>This is how it would be run without Church encoding</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="co">-- Example in IO with exception</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="kw">let</span> ioJobs <span class="fu">=</span> [ <span class="dt">Job</span> <span class="st">&quot;j1&quot;</span> ioJob1</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">               , <span class="dt">Job</span> <span class="st">&quot;j2&quot;</span> ioJob2</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">               , <span class="dt">Job</span> <span class="st">&quot;j3&quot;</span> ioJob3</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">               ]</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  a <span class="ot">&lt;-</span> runExceptT <span class="fu">$</span> interpreterFile <span class="fu">$</span> createAst <span class="st">&quot;test1&quot;</span> ioJobs</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  print a</a></code></pre></div>
<p>And this is how its run with Church encoding using <code>improve</code> from Control.Monad.Free.Church</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="co">-- Example in IO with exception</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="co">--------------------------------------------------</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">let</span> ioJobs <span class="fu">=</span> [ <span class="dt">Job</span> <span class="st">&quot;j1&quot;</span> ioJob1</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">               , <span class="dt">Job</span> <span class="st">&quot;j2&quot;</span> ioJob2</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">               , <span class="dt">Job</span> <span class="st">&quot;j3&quot;</span> ioJob3</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">               ]</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb13-9" data-line-number="9">        <span class="co">-- Note that createAst must be run inline here to avoid an error about the monad constraints</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  ai <span class="ot">&lt;-</span> runExceptT <span class="fu">$</span> interpreterFile (C.improve <span class="fu">$</span> createAst <span class="st">&quot;test1&quot;</span> ioJobs)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  print ai</a></code></pre></div>
<p>That is all it takes, we can now use free without O(n^2) concerns</p>
<h1 id="conclusion">Conclusion</h1>
<p>Free monads give us a nice way to separate pure and impure code while also handling exceptions. Overall I think this approach is more flexible and easier to read that the record of functions approach.</p>
<h1 id="links">Links</h1>
<ul>
<li><p><a href="https://gist.github.com/andrevdm/4d1625e6504e3f1fef9ee9fbc1298b34">Code on github (gist)</a></p></li>
<li>Free monad tutorials
<ul>
<li><a href="http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html">Purify code using free monads</a></li>
<li><a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">Why free monads matter</a></li>
<li><a href="http://www.parsonsmatt.org/2017/09/22/what_does_free_buy_us.html">What does Free buy us?</a></li>
</ul></li>
<li><a href="https://hackage.haskell.org/package/free">Control.Monad.Free</a></li>
<li><a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free-Church.html">Control.Monad.Free.Church</a></li>
<li><a href="https://markkarpov.com/post/free-monad-considered-harmful.html">Free monad considered harmful</a></li>
<li><a href="https://github.com/queertypes/free-tutorial">Free monad and church encoding example</a></li>
<li><p><a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in Haskell</a></p></li>
<li><p><a href="https://gist.github.com/brandonhamilton/2a87b8d66aa6bd7872c3848cd99318e1">Port of example code to use operational monad by @brandonhamilton</a></p></li>
</ul>

]]></summary>
</entry>
<entry>
    <title>Refactoring to pure code and dealing with exceptions.</title>
    <link href="http://www.andrevdm.com/posts/2017-10-31-refactor-away-io.html" />
    <id>http://www.andrevdm.com/posts/2017-10-31-refactor-away-io.html</id>
    <published>2017-10-31T00:00:00Z</published>
    <updated>2017-10-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October 31, 2017
    
</div>

<h1 id="overview">Overview</h1>
<p><em>(TL;DR: I use a record of functions &amp; a record of wrapper functions that catch all synchronous exceptions and convert to ExceptT for the pure code) </em></p>
<p>See also the followup post on <a href="2018-01-08-refactor-free.html">using Free as an alternative</a></p>
<p>This is a quick overview of how I refactored one of my first production haskell application that had a majority of IO code to be more pure. I’ve seen several approaches with different trade offs but none that fit exactly what I was doing 100%.</p>
<p>The design I needed was a pipeline of actions that needs to be performed, where each job in the pipeline is considered user code (think plugin)</p>
<p>Some design notes</p>
<ol type="1">
<li>Job
<ol type="1">
<li>Can run any IO action and as a result these actions can fail with exceptions</li>
<li>I don’t want to constrain what a job can do in any way, i.e. full IO access</li>
<li>This is custom code and can fail for any number of reasons, network errors, disk permissions etc</li>
</ol></li>
<li>Pipeline
<ol type="1">
<li>Must run impure jobs but be as pure as possible itself</li>
<li>Must be able to handle job failure (exceptions)</li>
<li>Supports different storage mechanisms, e.g. on disk for local dev vs cloud for production</li>
</ol></li>
</ol>
<p>Both jobs and the pipeline should be testable</p>
<h1 id="step-1---just-use-io-and-refactor-later">Step 1 - Just use IO and refactor later</h1>
<h2 id="jobs">Jobs</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Job</span> <span class="fu">=</span> <span class="dt">Job</span> {<span class="ot"> jobName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">               ,<span class="ot"> jobFn ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">               }</a></code></pre></div>
<p>A job has a name and an IO action to perform. In this demo a job takes a text value, does some transformation and returns a resulting text value. In a real world application this record would contain more operations and probably be polymorphic</p>
<h2 id="operations">Operations</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> <span class="fu">=</span> <span class="dt">Operations</span> {<span class="ot"> opRead ::</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                             ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                             }</a></code></pre></div>
<p>Operations is a record of operations that the pipeline uses to persist job results. I.e. this is the pluggable storage and related functions</p>
<p>I’ve chosen to pass a record of functions rather than using a type class. For discussion on records vs typeclass for this type of design see</p>
<ol type="1">
<li><a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">ReaderT design pattern</a></li>
<li><a href="https://github.com/lexi-lambda/mtl-style-example">mtl-style-example: A small, self-contained example of using mtl style to unit test effectful code in a pure way</a></li>
<li><a href="https://chris-martin.org/2017/interfaces-and-records">Java interfaces map to Haskell records</a></li>
</ol>
<p>A pluggable set of operations feels more natural as a record of functions to me than a typeclass. For me this is because they are just a named set of functions rather than something that has a set of rules (“an algebra”).</p>
<h2 id="pipeline">Pipeline</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">runPipeline ::</span> <span class="dt">Operations</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">runPipeline ops init jobs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  opWrite ops init</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  id <span class="ot">&lt;-</span> foldlM runJob <span class="dv">0</span> jobs</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  putText <span class="fu">$</span> <span class="st">&quot;\nfinal job id = &quot;</span> <span class="fu">&lt;&gt;</span> show id</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  opRead ops</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    runJob (id<span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dt">Job</span> name fn) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">      putText <span class="fu">$</span> <span class="st">&quot;running job: &quot;</span> <span class="fu">&lt;&gt;</span> name</a>
<a class="sourceLine" id="cb3-12" data-line-number="12"></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">      prev <span class="ot">&lt;-</span> opRead ops</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">      r <span class="ot">&lt;-</span> fn prev</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">      opWrite ops r</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">      </a>
<a class="sourceLine" id="cb3-17" data-line-number="17">      putText <span class="fu">$</span> <span class="st">&quot;  = &quot;</span> <span class="fu">&lt;&gt;</span> r</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">      putText <span class="st">&quot;  ----&quot;</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">      pure <span class="fu">$</span> id <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>Run each job in order, for each job</p>
<ol type="1">
<li>Load the last data</li>
<li>Run the job</li>
<li>Store the result</li>
<li>Pass a unique (for the run) id to each step</li>
</ol>
<p><em>(Obviously I could simply pass the previous state as part of the fold and do away with the load and store. Its done this way for the demonstration)</em></p>
<h2 id="storage">Storage</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">Txt</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step1.Impl1</span> <span class="kw">as</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">readFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">readFileOp <span class="fu">=</span> Txt.readFile</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="ot">writeFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">writeFileOp <span class="fu">=</span> Txt.writeFile</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="ot">mkFileOps ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">I.Operations</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">mkFileOps p <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="dt">I.Operations</span> { I.opRead <span class="fu">=</span> readFileOp p</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">               , I.opWrite <span class="fu">=</span> writeFileOp p</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">               }</a></code></pre></div>
<p>Here the operations are implemented by reading and writing to a file, using Data.Text.IO. The <a href="https://github.com/andrevdm/refactorAwayIO">example code</a> in github also has a STM backed storage implementation</p>
<h2 id="example-jobs">Example jobs</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">job1 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">job1 v <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  putText <span class="st">&quot;in job1&quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  pure <span class="fu">$</span> <span class="st">&quot;1:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">job2 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">job2 v <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  putText <span class="st">&quot;in job2&quot;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  void <span class="fu">.</span> throwIO <span class="fu">$</span> <span class="dt">DemoException</span> <span class="st">&quot;oops&quot;</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  pure <span class="fu">$</span> <span class="st">&quot;2:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="ot">job3 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">job3 v <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  putText <span class="st">&quot;in job3&quot;</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  pure <span class="fu">$</span> <span class="st">&quot;3:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17"></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="kw">newtype</span> <span class="dt">DemoException</span> <span class="fu">=</span> <span class="dt">DemoException</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"></a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">DemoException</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">  show (<span class="dt">DemoException</span> s) <span class="fu">=</span> Txt.unpack s</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">DemoException</span></a></code></pre></div>
<p>These are three example jobs. Notice that the second one explicitly throws an exception. A job can explicitly throw an exception like this or it could throw an exception on failure (e.g. network error)</p>
<h2 id="running">Running</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span> <span class="kw">hiding</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step1.Impl1</span> <span class="kw">as</span> <span class="dt">I1</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step1.Storage1</span> <span class="kw">as</span> <span class="dt">S1</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I1.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">             , <span class="dt">I1.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">             , <span class="dt">I1.Job</span> <span class="st">&quot;j3&quot;</span> job3</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">             ]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">let</span> ops <span class="fu">=</span> S1.mkFileOps</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  r <span class="ot">&lt;-</span> I1.runPipeline ops <span class="st">&quot;0&quot;</span> jobs</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  putText r</a></code></pre></div>
<p>When run this will fail with an exception in job 2 and result in the application terminating</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb7-1" data-line-number="1">---------</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"> Demo1: in memory</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">---------</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">running job: j1</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">in job1</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  = 1:0</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  ----</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">running job: j2</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">in job2</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="fu">Exception: </span>oops</a></code></pre></div>
<h1 id="step-2---monad-m">Step 2 - (Monad m)</h1>
<p>So far the example has a working pipeline but everything is in IO and it does nothing about exceptions.</p>
<p>Lets remove some IO constraints.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Step2.Impl2</span> ( <span class="dt">Operations</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                   , <span class="dt">Job</span> (<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                   , runPipeline</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                   ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="kw">data</span> <span class="dt">Operations</span> m <span class="fu">=</span> <span class="dt">Operations</span> {<span class="ot"> opRead ::</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">                               ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">                               ,<span class="ot"> opLog ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">                               }</a>
<a class="sourceLine" id="cb8-17" data-line-number="17"></a>
<a class="sourceLine" id="cb8-18" data-line-number="18"></a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="kw">data</span> <span class="dt">Job</span> m <span class="fu">=</span> <span class="dt">Job</span> {<span class="ot"> jobName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">                 ,<span class="ot"> jobFn ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">                 }</a>
<a class="sourceLine" id="cb8-22" data-line-number="22"></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="ot">runPipeline ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Operations</span> m <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span> m] <span class="ot">-&gt;</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">runPipeline ops init jobs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  opWrite ops init</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">  id <span class="ot">&lt;-</span> foldlM runJob <span class="dv">0</span> jobs</a>
<a class="sourceLine" id="cb8-27" data-line-number="27"></a>
<a class="sourceLine" id="cb8-28" data-line-number="28">  opLog ops <span class="fu">$</span> <span class="st">&quot;\nfinal job id = &quot;</span> <span class="fu">&lt;&gt;</span> show id</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">  opRead ops</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"></a>
<a class="sourceLine" id="cb8-31" data-line-number="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32">    runJob (id<span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dt">Job</span> name fn) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-33" data-line-number="33">      opLog ops <span class="fu">$</span> <span class="st">&quot;running job: &quot;</span> <span class="fu">&lt;&gt;</span> name</a>
<a class="sourceLine" id="cb8-34" data-line-number="34"></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">      prev <span class="ot">&lt;-</span> opRead ops</a>
<a class="sourceLine" id="cb8-36" data-line-number="36">      r <span class="ot">&lt;-</span> fn prev</a>
<a class="sourceLine" id="cb8-37" data-line-number="37">      opWrite ops r</a>
<a class="sourceLine" id="cb8-38" data-line-number="38">      </a>
<a class="sourceLine" id="cb8-39" data-line-number="39">      opLog ops <span class="fu">$</span> <span class="st">&quot;  = &quot;</span> <span class="fu">&lt;&gt;</span> r</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">      opLog ops <span class="st">&quot;  ----&quot;</span></a>
<a class="sourceLine" id="cb8-41" data-line-number="41"></a>
<a class="sourceLine" id="cb8-42" data-line-number="42">      pure <span class="fu">$</span> id <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>Here I’ve removed all explicit IO actions for the pipeline types and functions</p>
<h2 id="opread">opRead</h2>
<p>opRead has changed from</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">opRead ::</span> <span class="dt">IO</span> <span class="dt">Text</span></a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">opRead ::</span> m <span class="dt">Text</span></a></code></pre></div>
<p>i.e. the type no longer explicitly says IO but now accepts any kind * -&gt; * (e.g. any monad)</p>
<h2 id="operations-1">Operations</h2>
<p>The Operations type has changed from</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> <span class="fu">=</span> <span class="dt">Operations</span> {<span class="fu">..</span>}</a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operations</span> m <span class="fu">=</span> <span class="dt">Operations</span> {<span class="fu">..</span>}</a></code></pre></div>
<h2 id="runpipeline">runPipeline</h2>
<p>runPipeline has changed from</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">runPipeline ::</span> <span class="dt">Operations</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">runPipeline ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Operations</span> m <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Job</span> m] <span class="ot">-&gt;</span> m <span class="dt">Text</span></a></code></pre></div>
<p>There is a constraint saying that m must be a monad. This is so that we can use the monadic type class (pure, &gt;&gt;= etc)</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">(<span class="dt">Monad</span> m) <span class="ot">=&gt;</span></a></code></pre></div>
<p>And we use the <strong>Operations m</strong> and <strong>Job m</strong> types</p>
<h2 id="storage-1">Storage</h2>
<p>These changes mean that the pipeline and its types no longer require IO</p>
<p>The storage implementations need IO so you specialize the m to IO. Apart from that nothing changes I.e.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">readFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">readFileOp <span class="fu">=</span> Txt.readFile</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">writeFileOp ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">writeFileOp <span class="fu">=</span> Txt.writeFile</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="ot">mkFileOps ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Operations</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">mkFileOps p <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">  <span class="dt">Operations</span> { opRead <span class="fu">=</span> readFileOp p</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">             , opWrite <span class="fu">=</span> writeFileOp p</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">             , opLog <span class="fu">=</span> putText</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">             }</a></code></pre></div>
<p>Notice that I added <strong>opLog</strong>. It is used for logging rather than calling putText etc which can not be done since there is no IO (or MonadIO constraint)</p>
<h2 id="running-1">Running</h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span> <span class="kw">hiding</span> (catch, throwIO)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Storage2</span> <span class="kw">as</span> <span class="dt">S2</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Impl2</span> <span class="kw">as</span> <span class="dt">I2</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I2.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">             , <span class="dt">I2.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">             , <span class="dt">I2.Job</span> <span class="st">&quot;j3&quot;</span> job3</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">             ]</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  <span class="kw">let</span> ops <span class="fu">=</span> S2.mkFileOps</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">  r <span class="ot">&lt;-</span> I2.runPipeline ops <span class="st">&quot;0&quot;</span> jobs</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  putText r</a></code></pre></div>
<p>Note that we can use the same jobs as we did in step 1 (job1, job2 and job3).</p>
<h2 id="and-so">And… so?</h2>
<p>This simple change has already resulted in a few nice improvements.</p>
<ol type="1">
<li>The pipeline code is pure, no IO at all</li>
<li>This means that the pipeline can already be tested as pure code.</li>
<li>The pipeline can be specialized to IO and can run IO jobs or as above kept pure when testing or running non-IO jobs</li>
<li>The types are now compatible with monad transformers since a concrete monad type was not specified</li>
<li>The jobs can be used as is.</li>
</ol>
<p>That is a pretty good for not much extra work. However I have done nothing about exceptions and when this code runs it still breaks with an exception as it did before.</p>
<h1 id="step-3---exceptions">Step 3 - Exceptions</h1>
<p>If you have not seen the <a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in haskell</a> article, I think its worth looking at before continuing. The two points from the article I want to address are</p>
<ol type="1">
<li>Mixing ExceptT and exceptions mean you have to deal with multiple failure modes</li>
<li>When you are using IO anything can fail and throw an exception</li>
</ol>
<p>Not only must we accept that jobs can fail with exceptions but we should treat this as normal. I.e. when someone is writing a IO job they should be able to throw exceptions and the pipeline should handle them.</p>
<p>However I don’t want the pure code to have to deal with exceptions, I’d much rather deal with an Either type there. Which may seem to contradict point 1 from the article above. But this is not the case, remember that jobs perform IO and thus should deal with exceptions and the pipeline is pure and should not, so ExceptT/Either is fine.</p>
<p>And so we need something to bridge the gap between the two worlds.</p>
<h2 id="the-wrapper-type">The wrapper type</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">OpsError</span> <span class="fu">=</span> <span class="dt">ErrRead</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">              <span class="fu">|</span> <span class="dt">ErrWrite</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">              <span class="fu">|</span> <span class="dt">ErrLogging</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">              <span class="fu">|</span> <span class="dt">ErrRunning</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">              <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6"></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="kw">data</span> <span class="dt">OperationsWrapper</span> m <span class="fu">=</span> <span class="dt">OperationsWrapper</span> {<span class="ot"> opRead ::</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">                                             ,<span class="ot"> opWrite ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m ()</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">                                             ,<span class="ot"> opLog ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m ()</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">                                             ,<span class="ot"> opRun ::</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> m <span class="dt">Text</span>) <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> <span class="dt">OpsError</span> m <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">                                             }</a></code></pre></div>
<p>OperationsWrapper is a record with a wrapper function for each function from the Operations record. Each function will run the corresponding Operation function, catch any synchronous exception and covert it into an ExceptT transformer type. (See the section on catching all exceptions below)</p>
<p>The code for the wrapper is not terribly pretty, but I feel its a fair price to pay for separating the two concerns without resorting to any higher level magic (that I’m not comfortable with yet)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">mkOpsWrapper ::</span> (<span class="dt">MonadCatch</span> m) <span class="ot">=&gt;</span> <span class="dt">I2.Operations</span> m <span class="ot">-&gt;</span> <span class="dt">OperationsWrapper</span> m</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">mkOpsWrapper o <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="dt">OperationsWrapper</span> { opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opRead o) <span class="ot">`catch`</span> readError)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">                    , opWrite <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opWrite o t) <span class="ot">`catch`</span> writeError)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">                    , opLog <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opLog o t) <span class="ot">`catch`</span> logError)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                    , opRun <span class="fu">=</span> \fn t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> ((<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> fn t) <span class="ot">`catch`</span> logError)</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                    }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">    readError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">    readError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb19-11" data-line-number="11">      pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrRead</span> <span class="fu">$</span> <span class="st">&quot;Error reading: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    </a>
<a class="sourceLine" id="cb19-13" data-line-number="13"><span class="ot">    writeError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    writeError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb19-15" data-line-number="15">      pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrWrite</span> <span class="fu">$</span> <span class="st">&quot;Error writing: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">    </a>
<a class="sourceLine" id="cb19-17" data-line-number="17"><span class="ot">    logError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">    logError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb19-19" data-line-number="19">      pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrLogging</span> <span class="fu">$</span> <span class="st">&quot;Error logging: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a></code></pre></div>
<p>Each function works as follows</p>
<ol type="1">
<li><p>Call the “wrapped” corresponding function and on success return the result as a Right value</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> I2.opRead o</a></code></pre></div></li>
<li><p>Catch any exception and return it as a Left OpsError</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">...</span> <span class="ot">`catch`</span> readError</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">readError ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> b)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">readError e <span class="fu">=</span> </a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  pure <span class="fu">.</span> <span class="dt">Left</span> <span class="fu">.</span> <span class="dt">ErrRead</span> <span class="fu">$</span> <span class="st">&quot;Error reading: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a></code></pre></div></li>
</ol>
<h2 id="pipeline-using-the-wrapper">Pipeline using the wrapper</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">runPipeline ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">OperationsWrapper</span> m <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">I2.Job</span> m] <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">OpsError</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">runPipeline ops init jobs <span class="fu">=</span> runExceptT <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  opWrite ops init</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  id <span class="ot">&lt;-</span> foldlM runJob <span class="dv">0</span> jobs</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">  opLog ops <span class="fu">$</span> <span class="st">&quot;\nfinal job id = &quot;</span> <span class="fu">&lt;&gt;</span> show id</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  opRead ops</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    runJob (id<span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dt">I2.Job</span> name fn) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">      opLog ops <span class="fu">$</span> <span class="st">&quot;running job: &quot;</span> <span class="fu">&lt;&gt;</span> name</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"></a>
<a class="sourceLine" id="cb22-13" data-line-number="13">      prev <span class="ot">&lt;-</span> opRead ops</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">      r <span class="ot">&lt;-</span> opRun ops fn prev <span class="co">-- don&#39;t just lift, use opRun</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15">      opWrite ops r</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb22-17" data-line-number="17">      opLog ops <span class="fu">$</span> <span class="st">&quot;  = &quot;</span> <span class="fu">&lt;&gt;</span> r</a>
<a class="sourceLine" id="cb22-18" data-line-number="18">      opLog ops <span class="st">&quot;  ----&quot;</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19"></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">      pure <span class="fu">$</span> id <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>The changes from Step2 are</p>
<ol type="1">
<li>The result type is an Either. I.e. failure is now explicit</li>
<li>Its using OperationsWrapper not Operations</li>
<li>It is using the ExceptT monad, so <strong>runExceptT</strong> is used</li>
<li>Each function from the wrapper will abort the monad if it returns a Left (i.e. if the wrapped function throws)</li>
</ol>
<p>Also notice that I added a <strong>opRun</strong> function to wrap the running of the job. If you just lifted the job’s run function, then the exception would not be handled. So we need a wrapper function for this as well.</p>
<h2 id="running-2">Running</h2>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Protolude</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Storage2</span> <span class="kw">as</span> <span class="dt">S2</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Impl2</span> <span class="kw">as</span> <span class="dt">I2</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step3.Impl3</span> <span class="kw">as</span> <span class="dt">I3</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I2.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">             , <span class="dt">I2.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">             , <span class="dt">I2.Job</span> <span class="st">&quot;j3&quot;</span> job3</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">             ]</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb23-15" data-line-number="15">  <span class="kw">let</span> ops <span class="fu">=</span> S2.mkFileOps</a>
<a class="sourceLine" id="cb23-16" data-line-number="16"></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">  r <span class="ot">&lt;-</span> I3.runPipeline (I3.mkOpsWrapper ops) <span class="st">&quot;0&quot;</span> jobs</a>
<a class="sourceLine" id="cb23-18" data-line-number="18"></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">  <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20">    <span class="dt">Right</span> x <span class="ot">-&gt;</span> putText <span class="fu">$</span> <span class="st">&quot;Success: &quot;</span> <span class="fu">&lt;&gt;</span> x</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> putText <span class="fu">$</span> <span class="st">&quot;Exception: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a></code></pre></div>
<p>When run this will catch the exception in job 2 and correctly report the error, i.e. no runtime failure</p>
<pre><code> Demo3: use file
---------
running job: j1
in job1
  = 1:0
  ----
running job: j2
in job2
Exception: ErrLogging &quot;Error logging: oops&quot;</code></pre>
<h1 id="testing">Testing</h1>
<p>For completeness here is an example of how the pipeline can be tested using only pure code. I’m using the State monad (which you may not want to use in production but for my test and this example its just fine). Skip this the section if you are not interested in the tests</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="kw">module</span> <span class="dt">PipelineSpec</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Protolude</span> </a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.Except</span> <span class="kw">as</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.State.Strict</span> <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step2.Impl2</span> <span class="kw">as</span> <span class="dt">I2</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Step3.Impl3</span> <span class="kw">as</span> <span class="dt">I3</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14"><span class="ot">spec ::</span> <span class="dt">Spec</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">spec <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  describe <span class="st">&quot;simple pipeline&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-17" data-line-number="17">    it <span class="st">&quot;should run in correct order&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">      <span class="kw">let</span> jobs <span class="fu">=</span> [ <span class="dt">I2.Job</span> <span class="st">&quot;j1&quot;</span> job1</a>
<a class="sourceLine" id="cb25-19" data-line-number="19">                 , <span class="dt">I2.Job</span> <span class="st">&quot;j2&quot;</span> job2</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">                 ]</a>
<a class="sourceLine" id="cb25-21" data-line-number="21">      </a>
<a class="sourceLine" id="cb25-22" data-line-number="22">      <span class="kw">let</span> (r, _) <span class="fu">=</span> S.runState (testPipeline jobs <span class="st">&quot;0&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb25-23" data-line-number="23">      r <span class="ot">`shouldBe`</span> (<span class="dt">Right</span> <span class="st">&quot;2:1:0&quot;</span>)</a>
<a class="sourceLine" id="cb25-24" data-line-number="24"></a>
<a class="sourceLine" id="cb25-25" data-line-number="25"></a>
<a class="sourceLine" id="cb25-26" data-line-number="26"></a>
<a class="sourceLine" id="cb25-27" data-line-number="27"><span class="ot">testPipeline ::</span> [<span class="dt">I2.Job</span> (<span class="dt">S.State</span> <span class="dt">Text</span>)] <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">S.State</span> <span class="dt">Text</span> (<span class="dt">Either</span> <span class="dt">I3.OpsError</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb25-28" data-line-number="28">testPipeline jobs initial <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-29" data-line-number="29">  <span class="kw">let</span> ops <span class="fu">=</span> <span class="dt">I3.OperationsWrapper</span> { I3.opRead <span class="fu">=</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-30" data-line-number="30">                                     r <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb25-31" data-line-number="31">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> r</a>
<a class="sourceLine" id="cb25-32" data-line-number="32"></a>
<a class="sourceLine" id="cb25-33" data-line-number="33">                                 , I3.opWrite <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-34" data-line-number="34">                                     put <span class="fu">$</span> t</a>
<a class="sourceLine" id="cb25-35" data-line-number="35">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> ()</a>
<a class="sourceLine" id="cb25-36" data-line-number="36"></a>
<a class="sourceLine" id="cb25-37" data-line-number="37">                                 , I3.opRun <span class="fu">=</span> \fn t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-38" data-line-number="38">                                     r <span class="ot">&lt;-</span> fn t</a>
<a class="sourceLine" id="cb25-39" data-line-number="39">                                     pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> r</a>
<a class="sourceLine" id="cb25-40" data-line-number="40"></a>
<a class="sourceLine" id="cb25-41" data-line-number="41">                                 , I3.opLog <span class="fu">=</span> \t <span class="ot">-&gt;</span> <span class="dt">E.ExceptT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Right</span> <span class="fu">$</span> ()</a>
<a class="sourceLine" id="cb25-42" data-line-number="42">                                 }</a>
<a class="sourceLine" id="cb25-43" data-line-number="43"></a>
<a class="sourceLine" id="cb25-44" data-line-number="44">  I3.runPipeline ops initial jobs</a>
<a class="sourceLine" id="cb25-45" data-line-number="45"></a>
<a class="sourceLine" id="cb25-46" data-line-number="46"></a>
<a class="sourceLine" id="cb25-47" data-line-number="47"><span class="ot">job1 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">S.State</span> <span class="dt">Text</span>) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb25-48" data-line-number="48">job1 v <span class="fu">=</span> pure <span class="fu">$</span> <span class="st">&quot;1:&quot;</span> <span class="fu">&lt;&gt;</span> v</a>
<a class="sourceLine" id="cb25-49" data-line-number="49"></a>
<a class="sourceLine" id="cb25-50" data-line-number="50"><span class="ot">job2 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">S.State</span> <span class="dt">Text</span>) <span class="dt">Text</span></a>
<a class="sourceLine" id="cb25-51" data-line-number="51">job2 v <span class="fu">=</span> pure <span class="fu">$</span> <span class="st">&quot;2:&quot;</span> <span class="fu">&lt;&gt;</span> v</a></code></pre></div>
<h1 id="notes-on-exceptions">Notes on exceptions</h1>
<h2 id="catching-all-exceptions">Catching all exceptions</h2>
<p>Catching all exceptions is generally considered to be a bad idea. See for example the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#g:4">docs for Control.Exception</a>.</p>
<p>For a thorough discussion of alternatives see <a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions">Catching all exceptions</a> from www.schoolofhaskell.com</p>
<h2 id="safe-exceptions">Safe-exceptions</h2>
<p>In this example I am using the <a href="https://hackage.haskell.org/package/safe-exceptions-0.1.6.0/docs/Control-Exception-Safe.html">safe-exceptions package</a>. The catch function comes from Control.Exception.Safe not Control.Exception so only synchronous exceptions are caught. Take a look at the <a href="https://github.com/andrevdm/refactorAwayIO">source code</a> to see the cabal file and the explicit imports from Control.Exception.Safe</p>
<h2 id="using-async">Using async</h2>
<p>Another approach that <a href="https://twitter.com/thumphriees">@thumphriees</a> pointed out to me on twitter (and is discussed in the “Catching All Exceptions” article) is to use the async library to help with exceptions. This is the approach I’ll probably be using with the production version of this code as it for almost no extra cost gives me simple timeout and cancellation control.</p>
<p>As you can see from the code below this is a pretty simple to use</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">demoAsyncCatch ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">demoAsyncCatch <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  r <span class="ot">&lt;-</span> async jobBad <span class="fu">&gt;&gt;=</span> waitCatch</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="dt">Right</span> _ <span class="ot">-&gt;</span> putText <span class="st">&quot;demo async - Right&quot;</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> putText <span class="fu">$</span> <span class="st">&quot;demo async - Left: &quot;</span> <span class="fu">&lt;&gt;</span> show e</a>
<a class="sourceLine" id="cb26-8" data-line-number="8"></a>
<a class="sourceLine" id="cb26-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    jobBad <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-11" data-line-number="11">      putText <span class="st">&quot;in jobBad&quot;</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12">      void <span class="fu">.</span> throwIO <span class="fu">$</span> <span class="dt">DemoException</span> <span class="st">&quot;oops&quot;</span></a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<ul>
<li>The wrapper record separates the pure and effectful worlds and converts all synchronous IO exceptions into Eithers.</li>
<li>Passing around a record of functions is a alternative to using a typeclass and I believe makes more sense in many cases.</li>
<li>It is not that hard to refactor much of the impure code from a codebase</li>
</ul>
<p>The obvious downside to this method is that you end up with boilerplate code for the wrapper. You’ll have to decide on if this is a problem for you or not. For me this is working really well so far.</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://github.com/andrevdm/refactorAwayIO">Sample code on github</a></li>
<li><a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions best practices in haskell</a></li>
<li><a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">ReaderT design pattern</a></li>
<li><a href="https://github.com/lexi-lambda/mtl-style-example">mtl-style-example: A small, self-contained example of using mtl style to unit test effectful code in a pure way</a></li>
<li><a href="https://chris-martin.org/2017/interfaces-and-records">Java interfaces map to Haskell records</a></li>
<li><a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#g:4">docs for Control.Exception</a></li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions">Catching all exceptions</a></li>
<li><a href="https://hackage.haskell.org/package/safe-exceptions-0.1.6.0/docs/Control-Exception-Safe.html">safe-exceptions package</a></li>
</ul>
<p><img src="/images/pumpkin.png" /></p>

]]></summary>
</entry>
<entry>
    <title>Raspbery Pi GPIO using PureScript</title>
    <link href="http://www.andrevdm.com/posts/2016-10-05-purescript-raspberrypi-gpio.html" />
    <id>http://www.andrevdm.com/posts/2016-10-05-purescript-raspberrypi-gpio.html</id>
    <published>2016-10-05T00:00:00Z</published>
    <updated>2016-10-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October  5, 2016
    
</div>

<h1 id="overview">Overview</h1>
<p>This is a quick overview of how you can use PureScript on a RaspberryPi to do GPIO</p>
<h2 id="installing-node-js">Installing Node JS</h2>
<p>The version of NodeJs available in most of the distros is quite old. There are a few ways to get a new version. Personally I found that installing the same version of node that I have on my desktop on the pi worked best. To do this get the version you need from <a href="https://nodejs.org/dist/" class="uri">https://nodejs.org/dist/</a>.</p>
<p>Then run the commands with the appropriate version numbers</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">tar</span> -xvf node-v4nnn</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="bu">cd</span> node-v4nnn</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">sudo</span> cp -R . /usr/local</a></code></pre></div>
<p>if you prefer to get the latest, and a more automated install, then you can follow the instructions here <a href="http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/">Beginner’s Guide to Installing Node.js on a Raspberry Pi</a></p>
<h2 id="purescript-on-the-pi">PureScript on the Pi</h2>
<p>PureScript itself does not seem to install on the pi, so you’ll need to compile on a desktop machine and copy the resulting JavaScript files across</p>
<h2 id="raspberry-pi-gpio">Raspberry Pi GPIO</h2>
<p>GPIO can quite easily be done using unix files. This is not particularly fast but it should be more that sufficient for many use cases. It is also simple enough that it can even be done directly from the shell. If you need faster access FFI to one of the broadcom libraries is probably the way to go.</p>
<p>The GPIO ports are exposed here</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">/sys/class/gpio/gpio</span></a></code></pre></div>
<p>To use a GPIO pin for basic IO you need to do the following</p>
<ol type="1">
<li>Ensure that the port is “open”. Write the port number to <code>/sys/class/gpio/export</code></li>
<li>Set the direction by writing “in” or “out” to <code>/sys/class/gpio/gpioNN/direction</code> (where NN is the pin number)</li>
<li>Set the pin value by writing “on” or “off” to <code>/sys/class/gpio/gpioNN/value</code></li>
<li>Read the pin value by reading from <code>/sys/class/gpio/gpioNN/value</code></li>
</ol>
<h2 id="raspberry-pi-pin-numbers">Raspberry Pi Pin numbers</h2>
<p>The Raspberry Pi pin numbers are a little confusing. There are different models of the pi (A, B, B+, rev 2 etc). There are also different numbering schemes i.e. pin numbers, gpio numbers, wiring pi numbers…</p>
<p>When you are looking at existing code or examples make sure you know which scheme is being used.</p>
<p><a href="http://raspi.tv/wp-content/uploads/2014/07/Raspberry-Pi-GPIO-pinouts.png">Here is a good reference</a> showing pin number and GPIO numbers</p>
<h1 id="purescript">PureScript</h1>
<h2 id="gpio-types">GPIO types</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Gpio</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Direction</span> <span class="fu">=</span> <span class="dt">In</span> <span class="fu">|</span> <span class="dt">Out</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">newtype</span> <span class="dt">Pin</span> <span class="fu">=</span> <span class="dt">Pin</span> <span class="dt">Int</span></a></code></pre></div>
<h2 id="dealing-with-the-various-pin-numbering-schemes">Dealing with the various pin numbering schemes</h2>
<p>As shown above the physical pin numbers are used when working with GPIO, so all the functions here work with a pin number (Pin newtype). Then there is a module per board that can be used to map from a logical GPIO number to a pin. In this example I’ve only defined the layout for the Rev 2 A &amp; B P1 boards.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Gpio</span> (<span class="dt">Pin</span> (..))</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">data</span> <span class="dt">GpioPin</span> <span class="fu">=</span> <span class="dt">GpioPin2</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">             <span class="fu">|</span> <span class="dt">GpioPin3</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">             <span class="fu">|</span> <span class="dt">GpioPin4</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">             <span class="fu">|</span> <span class="dt">GpioPin17</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">             <span class="fu">|</span> <span class="dt">GpioPin27</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">             <span class="fu">|</span> <span class="dt">GpioPin22</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">             <span class="fu">|</span> <span class="dt">GpioPin10</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">             <span class="fu">|</span> <span class="dt">GpioPin9</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">             <span class="fu">|</span> <span class="dt">GpioPin11</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">             <span class="fu">|</span> <span class="dt">GpioPin14</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">             <span class="fu">|</span> <span class="dt">GpioPin15</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">             <span class="fu">|</span> <span class="dt">GpioPin18</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">             <span class="fu">|</span> <span class="dt">GpioPin23</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">             <span class="fu">|</span> <span class="dt">GpioPin24</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">             <span class="fu">|</span> <span class="dt">GpioPin25</span></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">             <span class="fu">|</span> <span class="dt">GpioPin8</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">             <span class="fu">|</span> <span class="dt">GpioPin7</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="ot">toPin ::</span> <span class="dt">GpioPin</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">toPin g <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">  <span class="kw">case</span> g <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">    <span class="dt">GpioPin2</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">    <span class="dt">GpioPin3</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    <span class="dt">GpioPin4</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">    <span class="dt">GpioPin17</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">11</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">    <span class="dt">GpioPin27</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">13</span></a>
<a class="sourceLine" id="cb4-29" data-line-number="29">    <span class="dt">GpioPin22</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">15</span></a>
<a class="sourceLine" id="cb4-30" data-line-number="30">    <span class="dt">GpioPin10</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">19</span></a>
<a class="sourceLine" id="cb4-31" data-line-number="31">    <span class="dt">GpioPin9</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">    <span class="dt">GpioPin11</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">23</span></a>
<a class="sourceLine" id="cb4-33" data-line-number="33">    <span class="dt">GpioPin14</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb4-34" data-line-number="34">    <span class="dt">GpioPin15</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb4-35" data-line-number="35">    <span class="dt">GpioPin18</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb4-36" data-line-number="36">    <span class="dt">GpioPin23</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">16</span></a>
<a class="sourceLine" id="cb4-37" data-line-number="37">    <span class="dt">GpioPin24</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">18</span></a>
<a class="sourceLine" id="cb4-38" data-line-number="38">    <span class="dt">GpioPin25</span> <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">22</span></a>
<a class="sourceLine" id="cb4-39" data-line-number="39">    <span class="dt">GpioPin8</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">24</span></a>
<a class="sourceLine" id="cb4-40" data-line-number="40">    <span class="dt">GpioPin7</span>  <span class="ot">-&gt;</span> <span class="dt">Pin</span> <span class="dv">26</span></a></code></pre></div>
<h2 id="gpio">GPIO</h2>
<p>To “open” a port you write the port number to the export file. This function first checks if the port is open</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">open ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">open (<span class="dt">Pin</span> pin) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  e <span class="ot">&lt;-</span> S.exists <span class="fu">$</span> <span class="st">&quot;/sys/class/gpio/gpio&quot;</span> <span class="fu">&lt;&gt;</span> show pin</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">if</span> not e </a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">then</span> </a>
<a class="sourceLine" id="cb5-6" data-line-number="6">      S.writeTextFile <span class="dt">E.ASCII</span> <span class="st">&quot;/sys/class/gpio/export&quot;</span> (show pin)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">      pure unit</a></code></pre></div>
<p>Set a port to be <em>in</em> or <em>out</em>. Remember that you can read a value from a port that is set to be output, you read if the port was set to on or off. Reading from a port set to <em>in</em> means that you are reading the value from the pin, i.e. is the pin being held high or low by an external input.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">setDirection ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> <span class="dt">Direction</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">setDirection (<span class="dt">Pin</span> pin) dir <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">let</span> dirStr <span class="fu">=</span> <span class="kw">case</span> dir <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">                  <span class="dt">In</span> <span class="ot">-&gt;</span> <span class="st">&quot;in&quot;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">                  <span class="dt">Out</span> <span class="ot">-&gt;</span> <span class="st">&quot;out&quot;</span> </a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  S.writeTextFile <span class="dt">E.ASCII</span> <span class="st">&quot;/sys/class/gpio/gpio18/direction&quot;</span> dirStr</a></code></pre></div>
<p>Set an <em>output</em> pin to high or low</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">setValue ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">setValue (<span class="dt">Pin</span> pin) on <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span> val <span class="fu">=</span> <span class="kw">if</span> on <span class="kw">then</span> <span class="st">&quot;1&quot;</span> <span class="kw">else</span> <span class="st">&quot;0&quot;</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  S.writeTextFile <span class="dt">E.ASCII</span> (<span class="st">&quot;/sys/class/gpio/gpio&quot;</span> <span class="fu">&lt;&gt;</span> (show pin) <span class="fu">&lt;&gt;</span> <span class="st">&quot;/value&quot;</span>) val</a></code></pre></div>
<p>Read the current value from the pin</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">getValue ::</span> <span class="dt">Pin</span> <span class="ot">-&gt;</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Boolean</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">getValue (<span class="dt">Pin</span> pin) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  val <span class="ot">&lt;-</span> (Str.trim <span class="fu">&lt;$&gt;</span> S.readTextFile <span class="dt">E.ASCII</span> <span class="st">&quot;/sys/class/gpio/gpio18/value&quot;</span>)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  pure <span class="fu">$</span> val <span class="fu">/=</span> <span class="st">&quot;0&quot;</span></a></code></pre></div>
<h2 id="e.g.-toggle-gpio-24">E.g. Toggle GPIO 24</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">main ::</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">CONSOLE</span>,<span class="ot"> fs ::</span> <span class="dt">FS</span>,<span class="ot"> err ::</span> <span class="dt">EXCEPTION</span> <span class="fu">|</span> e) <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">let</span> pin <span class="fu">=</span> R.toPin <span class="dt">R.GpioPin24</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  R.open pin </a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  v <span class="ot">&lt;-</span> R.getValue pin</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  R.setDirection pin <span class="dt">R.Out</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  R.setValue pin <span class="fu">$</span> not v</a></code></pre></div>
<h1 id="building-and-running">Building and running</h1>
<h2 id="build-the-purescript">Build the purescript</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ex">pulp</span> build --optimise --to ripiTest.js</a></code></pre></div>
<p>You then need to copy everything from the output folder to a folder on the pi</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">scp</span> -r ./output pi@192.168.0.99:/home/pi/ripiTest/output</a></code></pre></div>
<p>Finally copy your compiled bundle across</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">scp</span> -r ./ripiTest.js pi@192.168.0.99:/home/pi/ripiTest/</a></code></pre></div>
<p>Note that you only need to copy the <em>output</em> folder again when you add more imports. Otherwise just copy your bundle to save time.</p>
<h2 id="running">Running</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="bu">cd</span> /home/pi/ripiTest</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="fu">sudo</span> node ripiTest.js</a></code></pre></div>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://github.com/andrevdm/raspberryPiGpio">Source code</a></li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Haskell text classification using Tf-Idf</title>
    <link href="http://www.andrevdm.com/posts/2016-09-21-haskell-tfidf.html" />
    <id>http://www.andrevdm.com/posts/2016-09-21-haskell-tfidf.html</id>
    <published>2016-09-21T00:00:00Z</published>
    <updated>2016-09-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 21, 2016
    
</div>

<p>This is part two in a two part blog series about haskell terminal applications, this blog shows a simple text classification implementation using techniques from <a href="2016-09-20-haskell-shell.html">part one</a>.</p>
<h1 id="text-classification-with-tf-idf">Text Classification with Tf-Idf</h1>
<p>There are many ways to classify documents ranging from simple to very complex. The algorithm I’m using here is called Tf-Idf or “term frequency / inverse document frequency”. There are a number of sites that explain how it works better in detail than I would. See for example</p>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">Wikipedia</a></li>
<li><a href="http://www.tfidf.com/">What does tf-idf mean?</a></li>
</ol>
<p>Basically Tf-Idf counts the number of times a term occurs (term frequency) and combines that with a negative weighting for the number of times the term occurs in all categories. This means that common words that exist in multiple categories are going to count less towards the final score.</p>
<p>There are also multiple ways that TfIdf itself can be implemented e.g. with different algorithms for weighting the Tf vs the Idf or using n-grams (where n &gt; 1). I’m going with a pretty simple implementation but even with that I’ve seen pretty accurate results with the classifications I’m doing. I’m primarily using this for classifying short sentences of text. So it has been tested for simple matching on relatively small documents.</p>
<h1 id="the-textclassification-application">The TextClassification application</h1>
<p>You can get the source for TextClassify at <a href="https://github.com/andrevdm/TextClassify" class="uri">https://github.com/andrevdm/TextClassify</a>. The code is reasonably well commented IMO, so I wont go into too much detail here on every line of code</p>
<p>Below I’ll discuss some implementation details not covered by the code comments.</p>
<h1 id="using-the-application">Using the application</h1>
<ol type="1">
<li>The user sets up a directory of text files, one file per category.
<ul>
<li>These files contain the text that each category should match against.</li>
<li>Since, in this implementation, I’m not using n-grams each file is treated as a “bag of words” and newlines etc are ignored.</li>
</ul></li>
<li>Given the set of categories (the training set) the user then provides an input file (or piped via stdin) containing the text to be matched.
<ul>
<li>The data can be provided in plain text or in a CSV</li>
</ul></li>
<li>The application will ‘clean’ the input data and classify it</li>
<li>The results will be written to stdout and can be piped to a file if required</li>
</ol>
<h1 id="using-sed-awk-and-column">Using sed, awk and column</h1>
<p>There are a large number of existing terminal applications so it often makes sense to use this existing functionality as well as writing terminal applications so that they too can be reused.</p>
<h2 id="removing-lines-with-awk">Removing lines with awk</h2>
<p>The CSV files I work with have a header that needs to be removed. Here is a awk script (removePrefix.awk) to do that</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode awk"><code class="sourceCode awk"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">#!/usr/bin/awk -f</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="cf">BEGIN</span> <span class="kw">{</span><span class="bu">FS</span> <span class="op">=</span> <span class="st">&quot;,&quot;</span><span class="op">;</span><span class="kw">}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="bu">NR</span><span class="op">&lt;</span><span class="dv">7</span> <span class="kw">{next}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="bu">NF</span> <span class="kw">{</span> <span class="kw">print</span> <span class="kw">}</span> </a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="cf">END</span> <span class="kw">{</span> <span class="kw">}</span></a></code></pre></div>
<p>This script can be used to pre-process the CSV file</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">removePrevfix.awk</span> souceFile.csv</a></code></pre></div>
<h2 id="cleaning-text-with-sed">Cleaning text with sed</h2>
<p>The higher the quality of the input data to the classification algorithm the better the results will be. Some regular expressions can clean up the input text nicely. Here is a sed script that does this</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sed"><code class="sourceCode sed"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">#!/bin/sed -uf</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">s</span><span class="st">/c</span><span class="ch">\*</span><span class="st">/ /</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">s</span><span class="st">/jan</span><span class="ch">\|</span><span class="st">feb</span><span class="ch">\|</span><span class="st">mar</span><span class="ch">\|</span><span class="st">apr</span><span class="ch">\|</span><span class="st">may</span><span class="ch">\|</span><span class="st">jun</span><span class="ch">\|</span><span class="st">jul</span><span class="ch">\|</span><span class="st">aug</span><span class="ch">\|</span><span class="st">sep</span><span class="ch">\|</span><span class="st">oct</span><span class="ch">\|</span><span class="st">nov</span><span class="ch">\|</span><span class="st">dec/ /</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">s</span><span class="st">/ </span><span class="ch">\+$</span><span class="st">//</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">s</span><span class="st">/</span><span class="ch">\[\(\)</span><span class="st">!\-</span><span class="ch">\/*\\\]</span><span class="st">/ /g</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="er">s/[\.*\/\(\)_,\]/ /g</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">s</span><span class="st">/-/ /</span><span class="dt">g</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">s</span><span class="st">/</span><span class="ch">\t</span><span class="st">/ /</span><span class="dt">g</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">s</span><span class="st">/  </span><span class="ch">\+</span><span class="st">/ /</span><span class="dt">g</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">s</span><span class="st">/ </span><span class="ch">\+$</span><span class="st">//</span><span class="dt">gi</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">s</span><span class="st">/</span><span class="ch">^</span><span class="st"> </span><span class="ch">\+</span><span class="st">//</span><span class="dt">gi</span></a></code></pre></div>
<p>This sed script removes some common words (the months), removes special characters and multiple spaces. You can customise this or create one per type of input as required. The -u parameter is important as it disables buffering which may interfere with line-by-line processing.</p>
<p>The TextClassification application will start sed and keep it running. A line of input data will be passed to it and the result read back a line at a time.</p>
<h2 id="displaying-csv-results-with-column">Displaying CSV results with column</h2>
<p><code>column</code> can be used to show CSV data as an aligned table in the terminal. I’ll use this later to show the results of the classification.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">cat</span> sourceFile.csv <span class="kw">|</span> <span class="ex">column</span> -s , -t</a></code></pre></div>
<h1 id="command-line-arguments">Command line arguments</h1>
<p><em>See Args.hs</em></p>
<p>As <a href="2016-09-20-haskell-shell.html">part one</a> showed I’m using <a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a> to parse the command line arguments.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Arguments</span> <span class="fu">=</span> <span class="dt">Arguments</span> {<span class="ot">train ::</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Path to training data&quot;</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">                           ,<span class="ot">input ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Input file to categorise. If missing stdin will be used&quot;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">                           ,<span class="ot">parser ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser type, defaults to lines. Options are lines/detail/csv&quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">                           ,<span class="ot">popts ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser options&quot;</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">                           ,<span class="ot">clean ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Options name of text cleaner - see docs&quot;</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">                           } <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">ParseRecord</span> <span class="dt">Arguments</span></a></code></pre></div>
<p>This is the resulting help text from these arguments</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb6-1" data-line-number="1">  Usage: txtcls --train STRING [--input STRING] [--parser TEXT] [--popts TEXT]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">                [--clean TEXT]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  Available options:</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    -h,--help                Show this help text</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    --train TEXT             Path to training data</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    --input TEXT             Input file to categorise. If missing stdin will be</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">                             used</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    --parser TEXT            Parser type, defaults to lines. Options are</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">                             lines/detail/csv</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    --popts TEXT             Parser options</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    --clean TEXT             Options name of text cleaner - see docs</a></code></pre></div>
<p>These arguments are then interpreted and stored in the Options type</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Options</span> <span class="fu">=</span> <span class="dt">Options</span> {<span class="ot">trainingPath ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">                       ,<span class="ot">parserType ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">                       ,<span class="ot">parserOptions ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                       ,<span class="ot">txtCleaner ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">                       ,<span class="ot">hin ::</span> <span class="dt">Handle</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">                       ,<span class="ot">hout ::</span> <span class="dt">Handle</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">                       } </a></code></pre></div>
<h2 id="input-handle">Input handle</h2>
<p>hin is set to the handle of the input stream, stdin if no <code>--input</code> parameter is present else the handle for the file</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">hin_ <span class="ot">&lt;-</span> <span class="kw">case</span> unHelpful <span class="fu">$</span> input args <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">           <span class="dt">Just</span> t <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb8-3" data-line-number="3">             openFile (Txt.unpack t) <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">           <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              pure stdin</a></code></pre></div>
<h1 id="text-cleaning-with-the-cleaning-script">Text cleaning with the cleaning script</h1>
<p>Above I showed a sed that could be used to clean the input text. However because this application can use a CSV as the input it can’t simply apply the cleaning to the entire file or even an entire line. Only the text being classified should be cleaned. To do this an instance of sed is started and fed the text to clean one line at a time. (Actually any app could be used as long as it reads and writes one line at a time). The name of the app / script to use is defined by the <code>--clean</code> parameter</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">-- | Build a &#39;cleaner&#39;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">getCleaner ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">getCleaner mcmd <span class="fu">=</span> </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">case</span> mcmd <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="co">-- | The cleaner uses the extenal process to do the actual cleaning. One line is writtent to the processes&#39; stdin and then a value is read from its stdout </span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="dt">Just</span> cmd <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      (<span class="dt">Just</span> inp, <span class="dt">Just</span> outp, _, phandle) <span class="ot">&lt;-</span> createProcess (proc (Txt.unpack cmd) []) { std_out <span class="fu">=</span> <span class="dt">CreatePipe</span>, std_in <span class="fu">=</span> <span class="dt">CreatePipe</span> }</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      hSetBuffering outp <span class="dt">NoBuffering</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">      hSetBuffering inp <span class="dt">LineBuffering</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">      pure <span class="fu">$</span> cleanText inp outp</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    <span class="co">-- | No external cleaner. Just make the text lower case</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">      pure <span class="fu">$</span> pure <span class="fu">.</span> Txt.toLower</a>
<a class="sourceLine" id="cb9-14" data-line-number="14"></a>
<a class="sourceLine" id="cb9-15" data-line-number="15"><span class="co">-- | Used by getCleaner to build a curried cleaner function</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="ot">cleanText ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">cleanText inp outp txt <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">  hPutStrLn inp <span class="fu">$</span> Txt.unpack (Txt.toLower txt)</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  pure <span class="fu">.</span> Txt.pack <span class="fu">=&lt;&lt;</span> hGetLine outp</a></code></pre></div>
<p>The <strong>getCleaner</strong> function is passed (the optional) name of the cleaner script. If a script was specified then a processes is started and a curried <strong>cleanText</strong> function is returned as the cleaning function. If no script was specified then the returned cleaning function simply performs a toLower on the text.</p>
<p><strong>cleanText</strong> writes a line to the input handle for the process and then immediately reads the response line.</p>
<h1 id="reading-the-input-data">Reading the input data</h1>
<p>TextClassifier has three parsers</p>
<ol type="1">
<li>CSV - one of the columns is the data column</li>
<li>Lines - each line is the data</li>
<li>Detail - same as line but additional information is printed for each input line</li>
</ol>
<p>whileM_ is used to read a line of input at a time. The line is then passed to the appropriate parsers, i.e. CSV, line or detail.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- | Read input a line at a time and pass it to the parser</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">whileM_ (not <span class="fu">&lt;$&gt;</span> <span class="dt">IO</span><span class="fu">.</span>hIsEOF (Args.hin opts)) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="co">-- | line of data</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  origChars <span class="ot">&lt;-</span> <span class="dt">IO</span><span class="fu">.</span>hGetLine <span class="fu">$</span> Args.hin opts</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">let</span> origLine <span class="fu">=</span> Txt.pack origChars</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="co">-- | parse the line and get the results to display</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  parsed <span class="ot">&lt;-</span> <span class="kw">case</span> parser <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">              <span class="co">---</span></a></code></pre></div>
<h1 id="parsing-the-csv-data">Parsing the CSV Data</h1>
<p><em>See ClassifyCsv.hs and Classify.hs</em></p>
<p>I’m using <a href="https://hackage.haskell.org/package/cassava">Cassava</a> to read the CSV file as well as creating the output csv. Since I’m not interpreting any of the data apart from the text to be classified I’m simply reading the CSV as a vector of Text.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">let</span> contents <span class="fu">=</span> BL8.pack <span class="fu">.</span> Txt.unpack <span class="fu">$</span> line <span class="kw">in</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">let</span> parsed <span class="fu">=</span> decode <span class="dt">NoHeader</span><span class="ot"> contents ::</span> <span class="dt">Either</span> [<span class="dt">Char</span>] (<span class="dt">V.Vector</span> [<span class="dt">Text</span>]) <span class="kw">in</span></a></code></pre></div>
<p>Given a vector of Text it is simple to get the column containing the text to classify. The <strong>parseCsvLine</strong> function returns a <strong>ParsedLine a</strong> type which contains the text to be classified.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RawText</span> <span class="fu">=</span> <span class="dt">RawText</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">data</span> <span class="dt">ParsedLine</span> a <span class="fu">=</span> <span class="dt">ParsedLine</span> <span class="dt">RawText</span> a <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Remember that each line of data must be cleaned. Rather than having <strong>parseCsvLine</strong> live in IO it returns a <strong>ParsedLine a</strong> type. The code in Main then calls the cleaner and passes the resulting <strong>CleanedLine a</strong> to <strong>categoriseCsvLine</strong>. This limits the amount of code that needs to be in IO. It also make the code easier to test (e.g. from the REPL) as the two functions can be tested independently.</p>
<h1 id="tf-idf">Tf-Idf</h1>
<h2 id="training-set">Training set</h2>
<p><em>See ClassifyIO.hs</em></p>
<p>The training set is a directory with a file per category. Each file contains the words for that category. To load the files the <strong>loadTrainingSet</strong> function is used</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Category</span> <span class="fu">=</span> <span class="dt">Category</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">data</span> <span class="dt">TrainingSet</span> <span class="fu">=</span> <span class="dt">TrainingSet</span> [(<span class="dt">Category</span>, [<span class="dt">Text</span>])] <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">loadTrainingSet ::</span> <span class="dt">Args.Options</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TrainingSet</span></a></code></pre></div>
<p>All .txt files in the directory are loaded and result in a category of words.</p>
<h2 id="tf-idf-1">Tf-Idf</h2>
<p><em>See TfIdf.hs</em></p>
<p>To review the terminology</p>
<ul>
<li>Term - a single word</li>
<li>Category - category name</li>
<li>Document - a document of terms mapped to their TfIdf value</li>
</ul>
<p>the <strong>train</strong> function takes a <strong>TrainingSet</strong> and creates a <strong>TrainedData</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">-- | A term is a single word</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Term</span> <span class="fu">=</span> <span class="dt">Term</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co">-- | A category name</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">newtype</span> <span class="dt">Category</span> <span class="fu">=</span> <span class="dt">Category</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="co">-- | Term frequency value</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Tf</span> <span class="fu">=</span> <span class="dt">Tf</span> <span class="dt">Double</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="co">-- | Inverse document frequency value</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="kw">newtype</span> <span class="dt">Idf</span> <span class="fu">=</span> <span class="dt">Idf</span> <span class="dt">Double</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="co">-- | The combined Tf and Idf value</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="kw">newtype</span> <span class="dt">TfIdf</span> <span class="fu">=</span> <span class="dt">TfIdf</span> <span class="dt">Double</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="co">-- | A document is a map of terms to TfIdf</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="kw">newtype</span> <span class="dt">Document</span> <span class="fu">=</span> <span class="dt">Document</span> (<span class="dt">Map</span> <span class="dt">Term</span> <span class="dt">TfIdf</span>) <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"></a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="co">-- | Data making up the training set</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="kw">data</span> <span class="dt">TrainingSet</span> <span class="fu">=</span> <span class="dt">TrainingSet</span> [(<span class="dt">Category</span>, [<span class="dt">Text</span>])] <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"><span class="co">-- | The trained data, each category linked to a document</span></a>
<a class="sourceLine" id="cb14-17" data-line-number="17"><span class="kw">data</span> <span class="dt">TrainedData</span> <span class="fu">=</span> <span class="dt">TrainedData</span> [(<span class="dt">Category</span>, <span class="dt">Document</span>)] <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-18" data-line-number="18"></a>
<a class="sourceLine" id="cb14-19" data-line-number="19"></a>
<a class="sourceLine" id="cb14-20" data-line-number="20"><span class="ot">train ::</span> <span class="dt">TrainingSet</span> <span class="ot">-&gt;</span> <span class="dt">TrainedData</span></a></code></pre></div>
<p>Categorising text is handled by the <strong>categorise</strong> function. Given a collection of words it returns the best matching category if one was found. <strong>classifyDetail</strong> returns all possible matches sorted best match first. Both functions use cagegoriseWords to do the actual classification.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- | Classify a line of text and try get the best matching category</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">classify ::</span> <span class="dt">Args.Options</span> <span class="ot">-&gt;</span> <span class="dt">TrainedData</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Category</span>, <span class="dt">Double</span>) <span class="co">-- In Classify.hs</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="co">-- | Classify a line of text and get all matching categories, best first</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="ot">classifyDetail ::</span> <span class="dt">TrainedData</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [(<span class="dt">Category</span>, <span class="dt">Double</span>)] <span class="co">-- In Classify.hs</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="ot">categoriseWords ::</span> <span class="dt">TrainedData</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [(<span class="dt">Category</span>, <span class="dt">Double</span>)]  <span class="co">-- in TfIdf.hs</span></a></code></pre></div>
<p>To calculate the Tf and the Idf values the following two functions are used</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- | Calgulate the term frequency for a collection of words</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">-- | Tf = occurrence / terms in document.</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">calcTermFreq ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Map</span> <span class="dt">Term</span> <span class="dt">Tf</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">calcTermFreq terms <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  <span class="co">-- | Map of term to number of occurrences</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="kw">let</span> freq <span class="fu">=</span> Map.fromListWith (<span class="fu">+</span>) [(<span class="dt">Term</span> t, <span class="dv">1</span>) <span class="fu">|</span> t <span class="ot">&lt;-</span> terms] <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  <span class="co">-- | Document of Term to freq. Tf = occurrence count / terms in doc</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">  (\d <span class="ot">-&gt;</span> <span class="dt">Tf</span> <span class="fu">$</span> d <span class="fu">/</span> fromIntegral(length terms)) <span class="fu">&lt;$&gt;</span> freq</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"></a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="co">-- | Claculate the term&#39;s inverse document frequency</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="co">-- | Idf = (tf + 1) / (number of documents + 1)</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="co">-- | + 1 is used to avoid divide by zero</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13"><span class="ot">calcTermIdf ::</span> [<span class="dt">Map</span> <span class="dt">Term</span> a] <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Idf</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">calcTermIdf termToTfs term <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  <span class="kw">let</span> docsWithTerm <span class="fu">=</span> filter identity (Map.member term <span class="fu">&lt;$&gt;</span> termToTfs) <span class="kw">in</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  <span class="dt">Idf</span> <span class="fu">$</span> log ((fromIntegral <span class="fu">.</span> length <span class="fu">$</span> termToTfs) <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">/</span> ((fromIntegral <span class="fu">.</span> length <span class="fu">$</span> docsWithTerm) <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>Notice that there is no need for IO at all in the TfIdf module. It is given a loaded training set and cleaned text to classify.</p>
<p>The classification is then just finding the category with the closest matching tf-idf value</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- | Calculate how well terms matches categories</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">compareToCategory ::</span> [(<span class="dt">Term</span>,<span class="dt">TfIdf</span>)] <span class="ot">-&gt;</span> (<span class="dt">Category</span>, <span class="dt">Document</span>) <span class="ot">-&gt;</span> (<span class="dt">Category</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">compareToCategory searchTfIdf (cat, <span class="dt">Document</span> catMap) <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">let</span> catList <span class="fu">=</span> Map.toList catMap <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  <span class="co">-- | common words in the category and the search text</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  <span class="kw">let</span> common <span class="fu">=</span> Lst.intersectBy sameTerm catList searchTfIdf <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">  <span class="kw">let</span> commonV <span class="fu">=</span> sum <span class="fu">$</span> valFromTfIdf <span class="fu">.</span> snd <span class="fu">&lt;$&gt;</span> common <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  <span class="co">-- | Sum of all the TfIdf values</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  <span class="kw">let</span> allV <span class="fu">=</span> sum (valFromTfIdf <span class="fu">.</span> snd <span class="fu">&lt;$&gt;</span> searchTfIdf) <span class="fu">+</span> sum (valFromTfIdf <span class="fu">.</span> snd <span class="fu">&lt;$&gt;</span> catList) <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  <span class="co">-- | Similarity = ((common a) + (common b)) / (sum all tfIdf)</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  (cat, (commonV <span class="fu">*</span> <span class="dv">2</span>) <span class="fu">/</span> allV)</a></code></pre></div>
<h1 id="using-txtcls">Using txtcls</h1>
<h2 id="building">Building</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="fu">git</span> clone git@github.com:andrevdm/TextClassify.git</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="ex">stack</span> build</a></code></pre></div>
<h2 id="installing">Installing</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ex">stack</span> install</a></code></pre></div>
<p>This will install txtcls into your local stack bin folder.</p>
<h2 id="usage-instructions">Usage Instructions</h2>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ex">txtcls</span> --help</a></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb21-1" data-line-number="1">txtcls - Text Classifier. Version 0.1.2</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">Usage: txtcls --train TEXT [--input TEXT] [--parser TEXT] [--popts TEXT]</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">              [--clean TEXT]</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">Available options:</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  -h,--help                Show this help text</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  --train TEXT             Path to training data</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">  --input TEXT             Input file to categorise. If missing stdin will be</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">                           used</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">  --parser TEXT            Parser type, defaults to lines. Options are</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">                           lines/detail/csv</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">  --popts TEXT             Parser options</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">  --clean TEXT             Options name of text cleaner - see docs</a></code></pre></div>
<h2 id="usage-examples">Usage examples</h2>
<p>The examples folder contains scripts showing how txtcls can be used. The files are</p>
<ol type="1">
<li>cleanText.sed - sed script for cleaning the words</li>
<li>skipLines.awk - awk script for skipping lines in the input CSV</li>
<li>egLines.txt - example of data where each line is the data</li>
<li>egCsv.csv - example of data in csv</li>
<li>egCsvWithHeader.csv - example of data in CSV with a header text</li>
<li>demoCsv.sh - run the example on egCsv.csv</li>
<li>demoLines.sh - run the example on egLines.txt<br />
</li>
<li>demoDetail.sh - run the example on egLines.txt using the detail output</li>
<li>demoCsvWithHeader.sh - run the example on egCsvWithHeader.csv</li>
<li>demoDetailInteractive.sh - run the detail parser interactively, read a line from stdin and write to stdout</li>
<li>trainingData/cs.txt</li>
<li>trainingData/hasekll.txt</li>
</ol>
<h2 id="lines">Lines</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --input egLines.txt --parser lines --clean ./cleanText.sed</a></code></pre></div>
<p>Where</p>
<ul>
<li><code class="sourceCode bash"><span class="ex">--train</span> ./trainingData</code>
<ul>
<li>is the path to the folder with the training data</li>
</ul></li>
<li><code class="sourceCode bash"><span class="ex">--input</span> egLines.txt</code>
<ul>
<li>is the data source to classify</li>
</ul></li>
<li><code class="sourceCode bash"><span class="ex">--parser</span> lines</code>
<ul>
<li>is the parser to use</li>
</ul></li>
<li><code class="sourceCode bash"><span class="ex">--clean</span> ./cleanText.sed</code>
<ul>
<li>is the external process or script to use to clean the text</li>
</ul></li>
</ul>
<h3 id="detail">Detail</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --input egLines.txt --parser detail --clean ./cleanText.sed</a></code></pre></div>
<p>Where</p>
<ul>
<li><code>--parser detail</code> {.bash}
<ul>
<li>is the parser to use</li>
</ul></li>
</ul>
<h3 id="csv">CSV</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --input egCsv.csv --parser csv --popts 2 --clean ./cleanText.sed <span class="kw">|</span> <span class="ex">column</span> -s , -t</a></code></pre></div>
<p>Where</p>
<ul>
<li><code>--popts 2</code> {.bash}
<ul>
<li>is column in the CSV data that contains the data to classify</li>
</ul></li>
<li><code>| column -s , -t</code> {.bash}
<ul>
<li>pipes the resulting CSV to column to display it as a table in the terminal window</li>
</ul></li>
</ul>
<h3 id="csv-with-header-text">CSV with header text</h3>
<pre class="./bash"><code>skipLines.awk egCsvWithHeader.csv | txtcls --train ./trainingData --parser csv --popts 2 --clean ./cleanText.sed | column -s , -t</code></pre>
<p>Where</p>
<ul>
<li><code class="sourceCode bash"><span class="ex">./skipLines.awk</span> egCsvWithHeader.csv <span class="kw">|</span></code>
<ul>
<li>uses the awk script to remove 4 lines from the input CSV. Note that there is no <code>--input</code> paramter so the input is read from stdin (here the output of awk)</li>
</ul></li>
</ul>
<h3 id="interactive">interactive</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ex">txtcls</span> --train ./trainingData --parser detail --clean ./cleanText.sed</a></code></pre></div>
<h1 id="in-conclusion">In conclusion</h1>
<p>The source code for TextClassify is available and commented. You should hopefully be able to look at it and understand how it was implemented.</p>
<p>The important things to notice are</p>
<ul>
<li>How little needs to be in IO</li>
<li>How to use an external process (like sed) as part of your application’s pipeline</li>
<li>How to write your application so that it can be part of a larger pipeline (e.g. pipe the results of awk to it)</li>
<li>Selecting input from stdin or a file</li>
<li>Tf-Idf is a relatively simple but quite accurate way to classify simple documents</li>
</ul>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://github.com/andrevdm/TextClassify">Source code for the examples</a></li>
<li><a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a></li>
<li><a href="https://hackage.haskell.org/package/cassava">Cassava</a></li>
<li><a href="https://www.haskellstack.org/">Stack</a>.</li>
<li><a href="https://github.com/sdiehl/protolude">Protolude</a></li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>.</li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Haskell shell applications techniques</title>
    <link href="http://www.andrevdm.com/posts/2016-09-20-haskell-shell.html" />
    <id>http://www.andrevdm.com/posts/2016-09-20-haskell-shell.html</id>
    <published>2016-09-20T00:00:00Z</published>
    <updated>2016-09-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 20, 2016
    
</div>

<h1 id="haskell-terminal-applications">Haskell terminal applications</h1>
<p>This is part one in a two part blog series about haskell terminal applications. In this blog I’ll cover some techniques for writing a haskell application that behaves well as a shell application. In <a href="2016-09-21-haskell-tfidf.html">part two</a> I’ll show a simple text classification implementation using these techniques.</p>
<h1 id="interacting-with-the-terminal">Interacting with the terminal</h1>
<h2 id="parsing-command-line-arguments">Parsing command line arguments</h2>
<p><a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a> makes parsing command line arguments easy. Doing this manually is tedious and not terribly interesting so its great to have a simple library that handles this well.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Arguments</span> <span class="fu">=</span> <span class="dt">Arguments</span> {<span class="ot">train ::</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Path to training data&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">                           ,<span class="ot">input ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Input file to categorise. If missing stdin will be used&quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">                           ,<span class="ot">parser ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser type, defaults to lines. Options are lines/detail/csv&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">                           ,<span class="ot">popts ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Parser options&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">                           ,<span class="ot">clean ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Options name of text cleaner - see docs&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                           } <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">ParseRecord</span> <span class="dt">Arguments</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ot">getArgs ::</span> <span class="dt">IO</span> <span class="dt">Arguments</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">getArgs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  args <span class="ot">&lt;-</span> getRecord <span class="st">&quot;Your app name here.&quot;</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  pure (<span class="ot">args ::</span> <span class="dt">Arguments</span>)</a></code></pre></div>
<p>The <code>&lt;?&gt;</code> operator here lets you specify help text for each argument. Running your app with –help will print the help message using this text</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb2-1" data-line-number="1">  Usage: appName --train STRING [--input STRING] [--parser TEXT] [--popts TEXT]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                [--clean TEXT]</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  Available options:</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    -h,--help                Show this help text</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    --train TEXT             Path to training data</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    --input TEXT             Input file to categorise. If missing stdin will be</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">                             used</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    --parser TEXT            Parser type, defaults to lines. Options are</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">                             lines/detail/csv</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    --popts TEXT             Parser options</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    --clean TEXT             Options name of text cleaner - see docs</a></code></pre></div>
<h2 id="input-from-stdin-or-a-file">Input from stdin or a file</h2>
<p>It is often useful to allow terminal apps to get their input data either from an input file or have it piped to the app (stdin). <code>System.IO</code> defines a set of functions for reading and writing IO that all take an explicit handle. For example hGetLine</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">hGetLine ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></a></code></pre></div>
<p>System.IO also defines the stdin, stdout and stderr standard IO handles.</p>
<p>This means that you can pass either stdin or a file handle to hGetLine and it will work the same.</p>
<p>In the example arguments above I’ve allowed the user to specify an input file by using the –input option. If that is missing stdin is used.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">handle <span class="ot">&lt;-</span> <span class="kw">case</span> unHelpful <span class="fu">$</span> input args <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">            <span class="dt">Just</span> t <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb4-3" data-line-number="3">              openFile (Txt.unpack t) <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">               pure stdin</a></code></pre></div>
<p>Notice that <code>unHelpful</code> is called to get the value from a record field with a description</p>
<p>While you could use the parsed data directly I chose to rather create another record populated from the parsed command line arguments. This allows me to have names tailored for command line in one record and for my code in another. In this interpreted record I also store the handle to use for input</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">getOptions ::</span> <span class="dt">IO</span> <span class="dt">Options</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">getOptions <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  args <span class="ot">&lt;-</span> getRecord <span class="st">&quot;Your app name here.&quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  hin_ <span class="ot">&lt;-</span> <span class="kw">case</span> unHelpful <span class="fu">$</span> input args <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">             <span class="dt">Just</span> t <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb5-6" data-line-number="6">               openFile (Txt.unpack t) <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">                pure stdin</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  pure <span class="dt">Options</span> {trainingPath <span class="fu">=</span> unHelpful (train args)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">               ,parserType <span class="fu">=</span> fromMaybe <span class="st">&quot;lines&quot;</span> <span class="fu">$</span> unHelpful (parser args)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">               ,parserOptions <span class="fu">=</span> unHelpful (popts args)</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">               ,hout <span class="fu">=</span> stdout</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">               ,hin <span class="fu">=</span> hin_</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">               }</a></code></pre></div>
<h2 id="processing-a-line-at-a-time">Processing a line at a time</h2>
<p>It is often desirable to allow terminal applications to process and respond to a single line of data at a time (e.g. sed). There are several ways to do this in haskell. One of the simplest it to use <code>whileM_</code> and check for EOF.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="co">--where inputH is the input handle stdin or a file as above</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">hSetBuffering inputH <span class="dt">LineBuffering</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">whileM_ (not <span class="fu">&lt;$&gt;</span> hIsEOF inputH) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  line <span class="ot">&lt;-</span> hGetLine inputH</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="co">--</span></a></code></pre></div>
<h2 id="using-another-terminal-app-for-processing">Using another terminal app for processing</h2>
<p>Using an existing terminal application is a quick way to leverage existing functionality. For example you may want to use sed to manipulate some text. This is fairly strait-forward in haskell.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.IO</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">import</span> <span class="dt">System.Process</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">(<span class="dt">Just</span> inp, <span class="dt">Just</span> outp, _, phandle) <span class="ot">&lt;-</span> createProcess (proc <span class="st">&quot;command_name_here&quot;</span> []) { std_out <span class="fu">=</span> <span class="dt">CreatePipe</span>, std_in <span class="fu">=</span> <span class="dt">CreatePipe</span> }</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">hSetBuffering outp <span class="dt">NoBuffering</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">hSetBuffering inp <span class="dt">LineBuffering</span></a></code></pre></div>
<p>You now have and an input (inp) and output (outp) handle for the application. If the application supports line at a time input from stdin you can simply write your data and read the result back. Alternatively you may need to write the entire contents and wait for a result.</p>
<p>See <a href="2016-09-21-haskell-tfidf">part two</a> to see these techniques in use in a text classification application</p>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://hackage.haskell.org/package/optparse-generic">OptParse-generic</a></li>
<li><a href="https://www.haskellstack.org/">Stack</a>.</li>
<li><a href="https://github.com/sdiehl/protolude">Protolude</a></li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>.</li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Row span with PureScript pux and JavaScript redux</title>
    <link href="http://www.andrevdm.com/posts/2016-09-01-rowSpan-pux-redux.html" />
    <id>http://www.andrevdm.com/posts/2016-09-01-rowSpan-pux-redux.html</id>
    <published>2016-09-01T00:00:00Z</published>
    <updated>2016-09-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September  1, 2016
    
</div>

<h1 id="row-spans">Row spans</h1>
<p>I’ve always found creating tables that need rowspans a bit awkward. Having to skip TDs in the rows means that the logic to create each row can get a bit ugly. Typically I just want to map over an array of and get an array of TDs. Fortunately its quite easy to create a function to help make this easier. To keep it interesting I’m going to implement it in PureScript and JavaScript and compare a Haskell version of the function too.</p>
<h1 id="the-data">The data</h1>
<p>As an example imagine I have a set of data to display that shows the days an event occurred per month per day. Starting at the end, this is what I want the result to look like. You can see that the each year spans over the months + days and each month spans over the days.</p>
<p><img src="../images/rowSpan_final.png" /></p>
<h2 id="purescript">PureScript</h2>
<p>Here is how the data could be represented in PureScript using records</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">  <span class="kw">let</span> dates <span class="fu">=</span> [{year<span class="fu">:</span><span class="dv">2016</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">              ,months<span class="fu">:</span>[{month<span class="fu">:</span><span class="dv">11</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">                       ,days<span class="fu">:</span>[{day<span class="fu">:</span><span class="dv">30</span>}</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">                             ,{day<span class="fu">:</span><span class="dv">10</span>}</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">                             ]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">                       }</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">                      ,{month<span class="fu">:</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">                       ,days<span class="fu">:</span>[{day<span class="fu">:</span><span class="dv">15</span>}</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">                             ,{day<span class="fu">:</span><span class="dv">3</span>}</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">                             ,{day<span class="fu">:</span><span class="dv">1</span>}</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">                             ]</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                       }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">                      ]</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">              }</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">             ,{year<span class="fu">:</span><span class="dv">2015</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">              ,months<span class="fu">:</span>[{month<span class="fu">:</span><span class="dv">5</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">                       ,days<span class="fu">:</span>[{day<span class="fu">:</span><span class="dv">20</span>}</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">                             ,{day<span class="fu">:</span><span class="dv">17</span>}</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">                             ]</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">                       }</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">                      ]</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">              }</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">             ]</a></code></pre></div>
<p>Now we need something to map this data to. The simplest thing to do is to map it to a structure where each row contains the same number of columns and have a secondary function manage the shenanigans of omitting TDs that are spanned over.</p>
<p>Here is a definition for the row and column types</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Col</span> c <span class="fu">=</span> {span<span class="ot"> ::</span> <span class="dt">Int</span> <span class="fu">|</span> c}</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">type</span> <span class="dt">Row</span> r c <span class="fu">=</span> {<span class="ot">cols ::</span> <span class="dt">Array</span> (<span class="dt">Col</span> c) <span class="fu">|</span> r}</a></code></pre></div>
<p>Each row has columns and each column has a span. PureScript has extensible record types that support row polymorphism. What that means here is that we can define a function that accepts these types but the data actually passed to the function can be a superset of the required values. React for example needs a unique element id and obviously each column needs a value to be displayed. Rather than forcing this on the user of the rowSpan algorithm however we just get PureScript to check for the actual fields we need and let the caller add whatever extra data they need.</p>
<p>Here is a function to take the data above and creates an array of <strong>Row</strong>s.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">  <span class="kw">let</span> rowData <span class="fu">=</span> concat <span class="fu">$</span> concat <span class="fu">$</span> map</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">                (\y <span class="ot">-&gt;</span> map</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">                       (\m <span class="ot">-&gt;</span> map</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">                              (\d <span class="ot">-&gt;</span> {rid<span class="fu">:</span>y<span class="fu">.</span>year <span class="fu">*</span> <span class="dv">100</span> <span class="fu">+</span> m<span class="fu">.</span>month</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">                                     ,cols<span class="fu">:</span>[{val<span class="fu">:</span>show y<span class="fu">.</span>year,  span<span class="fu">:</span>length <span class="fu">$</span> concat <span class="fu">$</span> map (\a <span class="ot">-&gt;</span> a<span class="fu">.</span>days) y<span class="fu">.</span>months}</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">                                           ,{val<span class="fu">:</span>show m<span class="fu">.</span>month, span<span class="fu">:</span>length m<span class="fu">.</span>days}</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">                                           ,{val<span class="fu">:</span>show d<span class="fu">.</span>day,   span<span class="fu">:</span><span class="dv">1</span>}</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">                                           ]</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">                                     })</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">                              m<span class="fu">.</span>days)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                       y<span class="fu">.</span>months)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">                dates</a></code></pre></div>
<p>The result of this is an array of Rows. I.e. the data has been flattened and looks something like this</p>
<p><img src="../images/rowSpan_flat.png" /></p>
<p>Each <strong>Row</strong> has a rid (row id) field. Each column has a val (value) and a span field. The <strong>Col</strong>’s val contains the text to display and the span is the number of columns to span. This is simple to calculate. For months its the number of days in that month, for a year its the total number of days in all months in the year.</p>
<h1 id="the-rowspan-algorithm">The rowSpan algorithm</h1>
<p>Given a grid of data (<strong>Array</strong> of <strong>Row</strong>) we need a function that can remove the cols that are to be spanned over. This result can then be mapped over to generate the required TRs and TDs.</p>
<p>Effectively the function must do this</p>
<p><img src="../images/rowSpan_remove.png" /></p>
<p>Here is one way to achieve this</p>
<ol type="1">
<li>For each column have a <em>collapse</em> integer showing how many more times the col in its position should be skipped</li>
<li>Start with a 0 for each column, i.e. the first row always has all the columns</li>
<li>For each col in a row
<ol type="1">
<li>If <em>collapse</em> is zero then
<ol type="1">
<li>Include the column.</li>
<li>Use the <em>span</em> from the <strong>Col</strong> as the next <em>collapse</em> value</li>
</ol></li>
<li>Else if <em>collapse</em> is not zero then
<ol type="1">
<li>Ignore the column</li>
<li>Use the <em>collapse</em> value minus one as the next <em>collapse</em> value</li>
</ol></li>
</ol></li>
</ol>
<p>In the image below you can see the grid with the initial collapse value per row. As above notice that a column is removed unless the <em>collapse</em> value is zero.</p>
<p><img src="../images/rowSpan_collapse.png" /></p>
<p>And here is the PureScript code to do this</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">collapseTableArray ::</span> forall r c<span class="fu">.</span> <span class="dt">Array</span> (<span class="dt">Row</span> r c) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Row</span> r c)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">collapseTableArray rows <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="co">-- | To create the initial collapse array, we need to know the number of cols in a row</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="co">-- | Get the number of cols in each row and then  get the minimum value</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="co">-- | PureScript being safe ensures that the empty list case is handled</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">case</span> minimum <span class="fu">$</span> (\r <span class="ot">-&gt;</span> length r<span class="fu">.</span>cols) <span class="fu">&lt;$&gt;</span> rows <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="dt">Just</span> m <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">      <span class="co">-- | Initial collapse array of zeros</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      <span class="kw">let</span> collapse <span class="fu">=</span> replicate m <span class="dv">0</span> <span class="kw">in</span> </a>
<a class="sourceLine" id="cb4-10" data-line-number="10">      <span class="co">-- | fold rows with collapseRow</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">      <span class="kw">let</span> fixed <span class="fu">=</span> foldl collapseRow {collapse<span class="fu">:</span> collapse, st<span class="fu">:</span> []} rows <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">      fixed<span class="fu">.</span>st</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    _ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="co">-- | The fold function</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17"><span class="ot">    collapseRow ::</span> forall rr cc ss<span class="fu">.</span> (<span class="dt">CollapseState</span> rr cc ss) <span class="ot">-&gt;</span> <span class="dt">Row</span> rr cc <span class="ot">-&gt;</span> (<span class="dt">CollapseState</span> rr cc ss)</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    collapseRow state row <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">      <span class="co">-- | Zip the previous collapse array and the current cols array</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">      <span class="co">-- | This results in an array of [collapse, col]</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">      <span class="kw">let</span> skipCols <span class="fu">=</span> zip state<span class="fu">.</span>collapse row<span class="fu">.</span>cols <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">      <span class="co">-- | Get all cols where the collapse value is less than 1</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">      <span class="co">-- | First the list is filtered by checking the collapse value (fst in array)</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">      <span class="co">-- | Then snd is called (fmapped over) each itemm to get only the column</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">      <span class="co">-- | Note that this results in the selected columns being unaltered and all additional information (fields)</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">      <span class="co">-- |  in the columns being retained</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">      <span class="kw">let</span> nextCols <span class="fu">=</span> snd <span class="fu">&lt;$&gt;</span> filter (\t <span class="ot">-&gt;</span> fst t <span class="fu">&lt;=</span> <span class="dv">0</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      <span class="co">-- | If current collapse is zero then next skip is the span value - 1 else its collapse - 1</span></a>
<a class="sourceLine" id="cb4-29" data-line-number="29">      <span class="kw">let</span> nextSkip <span class="fu">=</span> map (\t <span class="ot">-&gt;</span> <span class="kw">if</span> fst t <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> (snd t)<span class="fu">.</span>span <span class="fu">-</span> <span class="dv">1</span> <span class="kw">else</span> (fst t) <span class="fu">-</span> <span class="dv">1</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-30" data-line-number="30">      <span class="co">-- | Construct the row, change only the cols</span></a>
<a class="sourceLine" id="cb4-31" data-line-number="31">      <span class="co">-- | Again, note that the other fields in the row are returned unaltered</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">      <span class="kw">let</span> resRow <span class="fu">=</span> row { cols <span class="fu">=</span> nextCols } <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-33" data-line-number="33">      <span class="co">-- | Next state</span></a>
<a class="sourceLine" id="cb4-34" data-line-number="34">      state {collapse <span class="fu">=</span> nextSkip, st <span class="fu">=</span> snoc state<span class="fu">.</span>st resRow }</a></code></pre></div>
<p>Finally here is the Pux code to generate the HTML from the result of <em>collapseTableArray</em></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">getTable ::</span> forall a<span class="fu">.</span> <span class="dt">Html</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">getTable <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">let</span> rowData <span class="fu">=</span> <span class="co">-- See above</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">let</span> c <span class="fu">=</span> collapseTableArray rowData <span class="kw">in</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">let</span> tableRows <span class="fu">=</span> map buildRow c <span class="kw">in</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  div</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    []</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    [table</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">       []</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">       [thead</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">          []</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">          [tr</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">             []</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">             [th [] [text <span class="st">&quot;year&quot;</span>]</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">             ,th [] [text <span class="st">&quot;month&quot;</span>]</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">             ,th [] [text <span class="st">&quot;day&quot;</span>]</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">             ]</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">          ]</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">       ,tbody</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">          []</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">          (buildRow <span class="fu">&lt;$&gt;</span> c)</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">       ]</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    ]</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">    buildRow r <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">      tr</a>
<a class="sourceLine" id="cb5-28" data-line-number="28">      []</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">      (buildCol <span class="fu">&lt;$&gt;</span> r<span class="fu">.</span>cols)</a>
<a class="sourceLine" id="cb5-30" data-line-number="30"></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">    buildCol c <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-32" data-line-number="32">      td</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">        [attr <span class="st">&quot;rowSpan&quot;</span> c<span class="fu">.</span>span]</a>
<a class="sourceLine" id="cb5-34" data-line-number="34">        [text <span class="fu">$</span> c<span class="fu">.</span>val]</a></code></pre></div>
<h1 id="javascript-and-redux">JavaScript and Redux</h1>
<p>Here is what that would look like in JavaScript. The example uses <a href="https://github.com/reactjs/redux">Redux</a> (react-redux) for the rendering and <a href="http://ramdajs.com/">Ramda</a> for the functional programming features. The code is compiled with babel with ES2015 syntax and the object spread operator enabled.</p>
<p>The data looks very similar to the PureScript data.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" data-line-number="1">  [<span class="op">{</span><span class="dt">year</span><span class="op">:</span><span class="dv">2016</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="dt">months</span><span class="op">:</span>[<span class="op">{</span><span class="dt">month</span><span class="op">:</span><span class="dv">11</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">             <span class="dt">days</span><span class="op">:</span>[<span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">30</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">10</span><span class="op">}</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">                  ]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">            <span class="op">},</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">            <span class="op">{</span><span class="dt">month</span><span class="op">:</span><span class="dv">2</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">             <span class="dt">days</span><span class="op">:</span>[<span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">15</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">3</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">1</span><span class="op">}</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">                  ]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">            <span class="op">}</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">           ]</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">   <span class="op">},</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">   <span class="op">{</span><span class="dt">year</span><span class="op">:</span><span class="dv">2015</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="dt">months</span><span class="op">:</span>[<span class="op">{</span><span class="dt">month</span><span class="op">:</span><span class="dv">5</span><span class="op">,</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">             <span class="dt">days</span><span class="op">:</span>[<span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">20</span><span class="op">},</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                   <span class="op">{</span><span class="dt">day</span><span class="op">:</span><span class="dv">17</span><span class="op">}</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">                  ]</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">            <span class="op">}</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">           ]</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">   <span class="op">}</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  ]<span class="op">;</span></a></code></pre></div>
<p>As with the PureScript example the first step is to create a flattened grid of the data and then call collapseTableArray on it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" data-line-number="1">  <span class="kw">const</span> daysInYear <span class="op">=</span> y <span class="op">=&gt;</span> <span class="va">R</span>.<span class="at">flatten</span>( <span class="va">R</span>.<span class="at">map</span>( m <span class="op">=&gt;</span> <span class="va">m</span>.<span class="at">days</span><span class="op">,</span> <span class="va">y</span>.<span class="at">months</span> ) )<span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">const</span> rows <span class="op">=</span> <span class="va">R</span>.<span class="at">flatten</span>( <span class="va">R</span>.<span class="at">map</span>(</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    y <span class="op">=&gt;</span> <span class="va">R</span>.<span class="at">map</span>(</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">      m <span class="op">=&gt;</span> <span class="va">R</span>.<span class="at">map</span>(</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        d <span class="op">=&gt;</span> (<span class="op">{</span><span class="dt">rowId</span><span class="op">:</span> <span class="va">y</span>.<span class="at">year</span> <span class="op">+</span> <span class="st">&quot;.&quot;</span> <span class="op">+</span> <span class="va">m</span>.<span class="at">month</span> <span class="op">+</span> <span class="st">&quot;.&quot;</span> <span class="op">+</span> <span class="va">d</span>.<span class="at">day</span><span class="op">,</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">               <span class="dt">cols</span><span class="op">:</span>[<span class="op">{</span><span class="dt">val</span><span class="op">:</span> <span class="va">y</span>.<span class="at">year</span><span class="op">,</span>  <span class="dt">span</span><span class="op">:</span> <span class="at">daysInYear</span>(y).<span class="at">length</span><span class="op">}</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">                    <span class="op">,{</span><span class="dt">val</span><span class="op">:</span> <span class="va">m</span>.<span class="at">month</span><span class="op">,</span> <span class="dt">span</span><span class="op">:</span> <span class="va">m</span>.<span class="va">days</span>.<span class="at">length</span><span class="op">}</span> </a>
<a class="sourceLine" id="cb7-9" data-line-number="9">                    <span class="op">,{</span><span class="dt">val</span><span class="op">:</span> <span class="va">d</span>.<span class="at">day</span><span class="op">,</span>   <span class="dt">span</span><span class="op">:</span> <span class="dv">1</span><span class="op">}</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">                    ]</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">              <span class="op">}</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">        <span class="va">m</span>.<span class="at">days</span> )<span class="op">,</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">      <span class="va">y</span>.<span class="at">months</span> )<span class="op">,</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    data )</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  )<span class="op">;</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">  <span class="kw">var</span> collapsed <span class="op">=</span> <span class="at">collapseTableArray</span>( rows )<span class="op">;</span></a></code></pre></div>
<p>The JavaScript version of the collapseTableArray function works in exactly the same way. Using Rambda and the ES2015 syntax (lambdas, destructuring etc) allows the JavaScript code to be nice and functional.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" data-line-number="1">  <span class="kw">const</span> collapseTableArray <span class="op">=</span> (tableArray) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="cf">if</span>( <span class="va">R</span>.<span class="at">isEmpty</span>(tableArray) )<span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      <span class="cf">return</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="co">//First collapse array is just a 0 for each col on first row</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="kw">var</span> collapse <span class="op">=</span> <span class="va">R</span>.<span class="at">map</span>( a <span class="op">=&gt;</span> <span class="dv">0</span><span class="op">,</span> tableArray[<span class="dv">0</span>].<span class="at">cols</span> )<span class="op">;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="kw">var</span> fixed <span class="op">=</span> <span class="va">R</span>.<span class="at">reduce</span>(</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      ([skip<span class="op">,</span> acc]<span class="op">,</span>row) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        <span class="co">//combine the skip list and cols</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        <span class="kw">const</span> skipCols <span class="op">=</span> <span class="va">R</span>.<span class="at">zip</span>( skip<span class="op">,</span> <span class="va">row</span>.<span class="at">cols</span> )</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        <span class="co">//Get the col that should not be skipped (2nd item from each of the filtered pair)</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        <span class="kw">const</span> nextCols <span class="op">=</span> <span class="va">R</span>.<span class="at">map</span>( p <span class="op">=&gt;</span> p[<span class="dv">1</span>]<span class="op">,</span> <span class="va">R</span>.<span class="at">filter</span>( f <span class="op">=&gt;</span> f[<span class="dv">0</span>] <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">,</span> skipCols ) )</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        <span class="co">//Calculate next skip. Look at prev skip, use the rowSpan from tableArray once the previous span has been used up</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">        <span class="kw">const</span> nextSkip <span class="op">=</span> <span class="va">R</span>.<span class="at">map</span>( p <span class="op">=&gt;</span> p[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> p[<span class="dv">1</span>].<span class="at">span</span> <span class="op">-</span> <span class="dv">1</span> : p[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> skipCols )</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  </a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        <span class="kw">const</span> res <span class="op">=</span> <span class="va">R</span>.<span class="at">concat</span>( acc<span class="op">,</span> [<span class="op">{</span>...<span class="at">row</span><span class="op">,</span> <span class="dt">cols</span><span class="op">:</span>nextCols<span class="op">}</span>] )<span class="op">;</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        <span class="cf">return</span> [nextSkip<span class="op">,</span> res]<span class="op">;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">      <span class="op">},</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">      [collapse<span class="op">,</span>[]]<span class="op">,</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">      tableArray )<span class="op">;</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  </a>
<a class="sourceLine" id="cb8-24" data-line-number="24">    <span class="cf">return</span> fixed[<span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  <span class="op">}</span></a></code></pre></div>
<p>Finally the data is rendered with react</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb9-1" data-line-number="1">  return (</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="kw">&lt;div&gt;</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">      <span class="kw">&lt;table&gt;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="kw">&lt;thead&gt;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">          <span class="kw">&lt;tr&gt;</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">            <span class="kw">&lt;th&gt;</span>Year<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">            <span class="kw">&lt;th&gt;</span>Month<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">            <span class="kw">&lt;th&gt;</span>Day<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">          <span class="kw">&lt;/tr&gt;</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="kw">&lt;/thead&gt;</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        <span class="kw">&lt;tbody&gt;</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">          {R.map( r =&gt; (<span class="kw">&lt;tr</span><span class="ot"> key=</span><span class="st">{r.rowId}</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">                         {R.map( c =&gt; (<span class="kw">&lt;td</span><span class="ot"> rowSpan=</span><span class="st">{c.span}</span><span class="ot"> key=</span><span class="st">{r.rowId</span> <span class="er">+</span> <span class="er">&quot;.&quot;</span> <span class="er">+</span><span class="ot"> c.val</span><span class="er">}</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">                                         {c.val}</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">                                       <span class="kw">&lt;/td&gt;</span>),</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">                                 r.cols )}</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">                        <span class="kw">&lt;/tr&gt;</span>),</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">                  collapsed )}</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">        <span class="kw">&lt;/tbody&gt;</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      <span class="kw">&lt;/table&gt;</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">    <span class="kw">&lt;/div&gt;</span></a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  );</a></code></pre></div>
<h1 id="haskell">Haskell</h1>
<p>While I’ve not implemented the HTML rendering with GHCJS I think its interesting to compare the PureScript and Haskell version of the collapseTableArray functions</p>
<p>Starting with the Haskell types</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Col</span> c <span class="fu">=</span> <span class="dt">Col</span> {span<span class="ot"> ::</span> <span class="dt">Int</span>,<span class="ot"> cval ::</span> c} <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Row</span> r c <span class="fu">=</span> <span class="dt">Row</span> {<span class="ot">cols ::</span> [<span class="dt">Col</span> c],<span class="ot"> rval ::</span> r} <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>Haskell does not have row polymorphism (e.g. extensible records) so to allow the <strong>Row</strong> and <strong>Col</strong> types to have user defined values I’ve used a record with type params</p>
<p>In this example I’m using <strong>Rid</strong> and <strong>Cval</strong> as defined below</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Rid</span> <span class="fu">=</span> <span class="dt">Rid</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Cval</span> <span class="fu">=</span> <span class="dt">Cval</span> <span class="dt">Text</span> <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>The Haskell collapseTableArray is very similar to the PureScript version</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">  <span class="co">-- | same as minimum but check for an empty list</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">  minimumSafe ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  minimumSafe xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      _ <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> minimum xs</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">  collapseTableArray ::</span> [<span class="dt">Row</span> r c] <span class="ot">-&gt;</span> [<span class="dt">Row</span> r c]</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  collapseTableArray rows <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    <span class="co">-- | To create the initial collapse array, we need to know the number of cols in a row</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    <span class="co">-- | Get the number of cols in each row and then  get the minimum value</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    <span class="co">-- | Use minimumSafe to guard against an empty list</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    <span class="kw">case</span> minimumSafe <span class="fu">$</span> (\r <span class="ot">-&gt;</span> length <span class="fu">$</span> cols r) <span class="fu">&lt;$&gt;</span> rows <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14">      <span class="dt">Just</span> i <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">        <span class="co">-- | Initial collapse array of zeros</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">        <span class="kw">let</span> collapse <span class="fu">=</span> replicate i <span class="dv">0</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">        <span class="co">-- | fold rows with collapseRow</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">        <span class="kw">let</span> (c,res) <span class="fu">=</span> foldl collapseRow (collapse, []) rows <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19">        res</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">      _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">        []</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb12-23" data-line-number="23">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24">      <span class="co">-- | The fold function</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25"><span class="ot">      collapseRow ::</span> ([<span class="dt">Int</span>], [<span class="dt">Row</span> r c]) <span class="ot">-&gt;</span> <span class="dt">Row</span> r c <span class="ot">-&gt;</span> ([<span class="dt">Int</span>], [<span class="dt">Row</span> r c])</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">      collapseRow (collapse, res) row <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27">        <span class="co">-- | Zip the previous collapse array and the current cols array</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28">        <span class="co">-- | This results in a tuple of (collapse, col)</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29">        <span class="kw">let</span> skipCols <span class="fu">=</span> zip collapse <span class="fu">$</span> cols row <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-30" data-line-number="30">        <span class="co">-- | Get all cols where the collapse value is less than 1</span></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">        <span class="co">-- | First the list is filtered by checking the collapse value (the first value in the tuple)</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32">        <span class="co">-- | Then snd is called (fmapped over) each tuple to get only the column</span></a>
<a class="sourceLine" id="cb12-33" data-line-number="33">        <span class="kw">let</span> nextCols <span class="fu">=</span> snd <span class="fu">&lt;$&gt;</span> filter (\(c,_) <span class="ot">-&gt;</span> c <span class="fu">&lt;=</span> <span class="dv">0</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-34" data-line-number="34">        <span class="co">-- | If current collapse is zero then next skip is the span value - 1 else its collapse - 1</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35">        <span class="kw">let</span> nextSkip <span class="fu">=</span> map (\(c,r) <span class="ot">-&gt;</span> <span class="kw">if</span> c <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> (span r) <span class="fu">-</span> <span class="dv">1</span> <span class="kw">else</span> c <span class="fu">-</span> <span class="dv">1</span>) skipCols <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36">        <span class="co">-- | Construct the row, change only the cols</span></a>
<a class="sourceLine" id="cb12-37" data-line-number="37">        <span class="kw">let</span> resRow <span class="fu">=</span> row { cols <span class="fu">=</span> nextCols } <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-38" data-line-number="38">        (nextSkip, res <span class="fu">&lt;&gt;</span> [resRow])</a></code></pre></div>
<p>A few differences to note from PureScript</p>
<ol type="1">
<li><code>deriving show</code> makes printing values easy. The sample project prints the result to the console</li>
<li><em>minimum</em> is not safe by default, so I’m using a custom <em>safeMinimum</em> to check for empty lists</li>
<li>Support for tuples and tuple destructuring</li>
<li>record functions to get values rather than field access</li>
</ol>
<p>Overall though the differences are small.</p>
<h1 id="building-the-sample-projects">Building the sample projects</h1>
<p>All the code for the <a href="https://github.com/andrevdm/rowSpanPureScriptJs">examples is on github</a></p>
<ul>
<li>PureScript
<ol type="1">
<li>In the ps directory run <code>setupPs.sh</code></li>
<li>Run <code>pulp build</code> to build</li>
<li>Run <code>npm sttart</code> to build and run the site.</li>
<li>Browse to http://localhost:3000/</li>
</ol></li>
<li>JavaScript
<ol type="1">
<li>In the js directory run <code>setupBable.sh</code></li>
<li>Run <code>runBabelAndWatch.sh</code> to build the bable js</li>
<li>Start a web server in the js/demo directory (e.g. node’s http-server)</li>
</ol></li>
<li>Haskell
<ol type="1">
<li>Ensure you have stack installed</li>
<li>In the hs directory run <code>stack build</code></li>
<li>Run <code>buildAndRun.sh</code></li>
</ol></li>
</ul>
<h1 id="links">Links</h1>
<ol type="1">
<li><a href="https://github.com/andrevdm/rowSpanPureScriptJs">Source code for the examples</a>.</li>
<li><a href="https://github.com/alexmingoia/pux-starter-app">Purescript pux starter app</a>.</li>
<li><a href="http://ramdajs.com/">Ramda</a>.</li>
<li><a href="https://github.com/reactjs/redux">Redux</a>.</li>
<li><a href="https://www.haskellstack.org/">Stack</a>.</li>
<li><a href="https://github.com/sdiehl/protolude">Protolude</a></li>
<li><a href="https://leanpub.com/purescript">PureScript By Example</a>. The PureScript book</li>
<li><a href="http://www.alexmingoia.com/purescript-pux/index.html">Pux Tutorial</a></li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>.</li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Composing components with PureScript Pux</title>
    <link href="http://www.andrevdm.com/posts/2016-08-15-PureScript-Pux-Compose.html" />
    <id>http://www.andrevdm.com/posts/2016-08-15-PureScript-Pux-Compose.html</id>
    <published>2016-08-15T00:00:00Z</published>
    <updated>2016-08-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on August 15, 2016
    
</div>

<h2 id="purescript-pux">PureScript Pux</h2>
<p>Pux is a PureScript interface to React. The tutorial at <a href="http://www.alexmingoia.com/purescript-pux/index.html" class="uri">http://www.alexmingoia.com/purescript-pux/index.html</a> gives a good introduction to the library. The section titled <strong>Multiple components</strong> shows how you can easily compose simple components. What it does not show however is how to compose components that have effects (eff or aff).</p>
<p>I battled with this for a bit and so decided to document the solution in the hopes it helps other beginners. The explanation below shows how to compose components in the framework of the <a href="https://github.com/alexmingoia/pux-starter-app">starter app</a>.</p>
<p>I’m assuming that you have read the pux tutorial at least up to the fetching data section so I wont be covering the same detail here.</p>
<h2 id="the-starter-app">The starter app</h2>
<p>The starter app has a counter component that is rendered in the Laout.purs file</p>
<h3 id="the-original-counter">The original counter</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Action</span> <span class="fu">=</span> <span class="dt">Increment</span> <span class="fu">|</span> <span class="dt">Decrement</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">init<span class="ot"> ::</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">init <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">update <span class="dt">Increment</span> state <span class="fu">=</span> state <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">update <span class="dt">Decrement</span> state <span class="fu">=</span> state <span class="fu">-</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="the-original-layout">The original layout</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Child</span> (<span class="dt">Counter.Action</span>)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">PageView</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  {<span class="ot"> route ::</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  ,<span class="ot"> count ::</span> <span class="dt">Counter.State</span> }</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">init<span class="ot"> ::</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">init <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  { route<span class="fu">:</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  , count<span class="fu">:</span> Counter.init }</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">update (<span class="dt">PageView</span> route) state <span class="fu">=</span> state { route <span class="fu">=</span> route }</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">update (<span class="dt">Child</span> action) state <span class="fu">=</span> state { count <span class="fu">=</span> Counter.update action state<span class="fu">.</span>count }</a></code></pre></div>
<h2 id="making-the-counter-effectful">Making the counter effectful</h2>
<h3 id="effmodel">EffModel</h3>
<p>The type of an update function with no effects (as above) is</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">State</span></a></code></pre></div>
<p>For it to be effectful it should return an EffModel. The EffModel looks like this</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">type</span> <span class="dt">EffModel</span> state action eff <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    {<span class="ot"> state ::</span> state</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    ,<span class="ot"> effects ::</span> <span class="dt">Array</span> (<span class="dt">Aff</span> (<span class="ot">channel ::</span> <span class="dt">CHANNEL</span> <span class="fu">|</span> eff) action) </a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    }</a></code></pre></div>
<p>The update type will then be</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a></code></pre></div>
<h3 id="changing-the-counter">Changing the counter</h3>
<p>To keep things simple I’ll make the counter component act as if its effectual without doing any actual IO. To perform effects the component returns a list of effects that should be performed in the EffModel’s effects. The counter needs to do three things</p>
<ol type="1">
<li>Increment</li>
<li>Decrement</li>
<li>Apply the effects</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">update (<span class="dt">ReceiveInc</span> i) state<span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  noEffects <span class="fu">$</span> state <span class="fu">+</span> i</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">update <span class="dt">Increment</span> state <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  { state<span class="fu">:</span> state</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  , effects<span class="fu">:</span> [ <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">                  pure <span class="fu">$</span> <span class="dt">ReceiveInc</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">             ]</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">update <span class="dt">Decrement</span> state <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  { state<span class="fu">:</span> state</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  , effects<span class="fu">:</span> [ <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">                  pure <span class="fu">$</span> <span class="dt">ReceiveInc</span> (<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">             ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17"><span class="ot">view ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Html</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">view state <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">  div</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    []</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">    [ button [ onClick (const <span class="dt">Increment</span>) ] [ text <span class="st">&quot;Increment&quot;</span> ]</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">    , span [] [ text (show state) ]</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">    , button [ onClick (const <span class="dt">Decrement</span>) ] [ text <span class="st">&quot;Decrement&quot;</span> ]</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">    ]</a></code></pre></div>
<p>The increment and decrement cases return a ReceiveInc effect that will then be passed to the component and applied by the ReceiveInc case. In a real world component there would be an actual IO action e.g. using AJAX with affjax etc. But ultimately you are returning the effect in the array to be applied.</p>
<h3 id="changing-the-layout">Changing the layout</h3>
<p>The layout’s update function must also be changed to use an EffModel</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">update (<span class="dt">PageView</span> route) state <span class="fu">=</span> noEffects <span class="fu">$</span> state { route <span class="fu">=</span> route }</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a></code></pre></div>
<p>The problem is that the counter’s EffModel does not have the same type as the layout’s EffModel, so you can’t simply use the result from the child components. Rather you need to map both the state and the effects using the mapState and mapEffects functions.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">let</span> efm <span class="fu">=</span> Counter.update action state<span class="fu">.</span>count <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">let</span> st <span class="fu">=</span> mapState (\s <span class="ot">-&gt;</span> state {count <span class="fu">=</span> s}) efm <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">let</span> ef <span class="fu">=</span> mapEffects (\e <span class="ot">-&gt;</span> <span class="dt">PostCounter</span> e) st <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  ef</a></code></pre></div>
<p>So first the Counter’s update function is called. Then the state is mapped to change the state. Finally the effects are mapped by creating a PostCounter instance for each event. This can be cleaned up a bit, e.g. using the <strong><em>#</em></strong> operator</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  Counter.update action state<span class="fu">.</span>count</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">#</span> mapState (state {count <span class="fu">=</span> _}) </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="fu">#</span> mapEffects <span class="dt">PostCounter</span> </a></code></pre></div>
<p>The final layout code looks like this</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">PostCounter</span> (<span class="dt">Counter.Action</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">PostCounter2</span> (<span class="dt">Counter.Action</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">PageView</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  {<span class="ot"> route ::</span> <span class="dt">Route</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  ,<span class="ot"> count ::</span> <span class="dt">Counter.State</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  ,<span class="ot"> count2 ::</span> <span class="dt">Counter.State</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">init<span class="ot"> ::</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">init <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">  {</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    route<span class="fu">:</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">  , count<span class="fu">:</span> Counter.init</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">  , count2<span class="fu">:</span> Counter.init</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb10-19" data-line-number="19"></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"><span class="ot">update ::</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">EffModel</span> <span class="dt">State</span> <span class="dt">Action</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX</span>)</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">update (<span class="dt">PageView</span> route) state <span class="fu">=</span> noEffects <span class="fu">$</span> state { route <span class="fu">=</span> route }</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">update (<span class="dt">PostCounter</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">  Counter.update action state<span class="fu">.</span>count</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">  <span class="fu">#</span> mapState (state {count <span class="fu">=</span> _}) </a>
<a class="sourceLine" id="cb10-25" data-line-number="25">  <span class="fu">#</span> mapEffects <span class="dt">PostCounter</span> </a>
<a class="sourceLine" id="cb10-26" data-line-number="26">update (<span class="dt">PostCounter2</span> action) state <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27">  Counter.update action state<span class="fu">.</span>count2</a>
<a class="sourceLine" id="cb10-28" data-line-number="28">  <span class="fu">#</span> mapState (state {count2 <span class="fu">=</span> _}) </a>
<a class="sourceLine" id="cb10-29" data-line-number="29">  <span class="fu">#</span> mapEffects <span class="dt">PostCounter2</span> </a>
<a class="sourceLine" id="cb10-30" data-line-number="30"></a>
<a class="sourceLine" id="cb10-31" data-line-number="31"><span class="ot">view ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Html</span> <span class="dt">Action</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32">view state <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">  div</a>
<a class="sourceLine" id="cb10-34" data-line-number="34">    []</a>
<a class="sourceLine" id="cb10-35" data-line-number="35">    [ h1 [] [ text <span class="st">&quot;Pux Starter App&quot;</span> ]</a>
<a class="sourceLine" id="cb10-36" data-line-number="36">    , p [] [ text <span class="st">&quot;Change src/Layout.purs and watch me hot-reload.&quot;</span> ]</a>
<a class="sourceLine" id="cb10-37" data-line-number="37">    , <span class="kw">case</span> state<span class="fu">.</span>route <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38">        <span class="dt">Home</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39">          div</a>
<a class="sourceLine" id="cb10-40" data-line-number="40">            []</a>
<a class="sourceLine" id="cb10-41" data-line-number="41">            [</a>
<a class="sourceLine" id="cb10-42" data-line-number="42">              map <span class="dt">PostCounter</span> <span class="fu">$</span> Counter.view state<span class="fu">.</span>count</a>
<a class="sourceLine" id="cb10-43" data-line-number="43">            , hr [] [] </a>
<a class="sourceLine" id="cb10-44" data-line-number="44">            , map <span class="dt">PostCounter2</span> <span class="fu">$</span> Counter.view state<span class="fu">.</span>count2</a>
<a class="sourceLine" id="cb10-45" data-line-number="45">            ]</a>
<a class="sourceLine" id="cb10-46" data-line-number="46">        <span class="dt">NotFound</span> <span class="ot">-&gt;</span> NotFound.view state</a>
<a class="sourceLine" id="cb10-47" data-line-number="47">    ]</a></code></pre></div>
<h3 id="changing-main">Changing main</h3>
<p>The only remaining changes are a few minor modifications to Main.purs</p>
<ol type="1">
<li>Import <code>Network.HTTP.Affjax (AJAX)</code></li>
<li><p>Add AJAX to the AppEfects type</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="dt">AppEffects</span> <span class="fu">=</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span>,<span class="ot"> ajax ::</span> <span class="dt">AJAX0</span>)</a></code></pre></div></li>
<li><p>The update function no longer needs the <code>fromSimple</code></p></li>
</ol>
<h2 id="summary">Summary</h2>
<p>The full code for this example is available in this fork of the start app <a href="https://github.com/andrevdm/pux-starter-app-with-effects" class="uri">https://github.com/andrevdm/pux-starter-app-with-effects</a></p>
<h2 id="links">Links</h2>
<ol type="1">
<li><a href="https://leanpub.com/purescript">PureScript By Example</a>. The PureScript book</li>
<li><a href="http://www.alexmingoia.com/purescript-pux/index.html">Pux Tutorial</a></li>
<li><a href="https://github.com/dariooddenino/pux-blog">Pux blog sample project</a>. Shows this and more in a real world project. This helped clear up some of the confusion for me, definitely worth taking a look at</li>
<li><a href="http://haskellbook.com/">Haskell Programming from first principles</a>. Invaluable if you are new to PureScript/Haskell</li>
<li><a href="https://github.com/andrevdm/pux-starter-app-with-effects">Source code for this example</a>. Diff on d621094abb4cb3a9bea2b1a831d50fbc5ef014a6 will show changes made for this post.</li>
</ol>

]]></summary>
</entry>
<entry>
    <title>Creating a Stack Machine with Haskell</title>
    <link href="http://www.andrevdm.com/posts/2016-05-28-haskellStackVm.html" />
    <id>http://www.andrevdm.com/posts/2016-05-28-haskellStackVm.html</id>
    <published>2016-05-28T00:00:00Z</published>
    <updated>2016-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on May 28, 2016
    
</div>

<h2 id="about-the-project">About the Project</h2>
<p>This is a small demonstration project showing how a simple byte code interpreting stack machine (virtual machine) can be built with Haskell. It is not a production VM nor of any particular practical use but is rather a simple demonstration of how a stack machine can be built. All code is available in the github repo <a href="https://github.com/andrevdm/SimpleHaskellStackVM" class="uri">https://github.com/andrevdm/SimpleHaskellStackVM</a></p>
<p>I built this for mainly as a project for learning Haskell, i.e. something a little bigger to work on. So NB this is probably not idiomatic Haskell, and may have some newbie mistakes. Hopefully it is interesting enough despite this…</p>
<h3 id="stack-machines">Stack Machines</h3>
<blockquote>
<p>A stack machine is a real or emulated computer that uses a pushdown stack rather than individual machine registers to evaluate each sub-expression in the program. A stack computer is programmed with a reverse Polish notation instruction set. - <a href="https://en.wikipedia.org/wiki/Stack_machine">wikipedia [1]</a></p>
</blockquote>
<p>Stack machines are simpler to implement than <a href="https://en.wikipedia.org/wiki/Register_machine">register machines</a> but are still practical even for production VMs.</p>
<h3 id="writing-the-vm-in-haskell">Writing the VM in Haskell</h3>
<p>Virtual machines are typically written in a low level language like C for maximum efficiency. They also are typically written using mutable data structures. Here I’m using Haskell and pure functional data structures. I have absolutely no performance goals, so there are no constraints I need to worry about.</p>
<p>A few design decisions</p>
<ol type="1">
<li><p>I’m using a Data.Sequence rather than a list. While I’m not concerned about performance using a linked list to do random access is still a bad idea</p></li>
<li><p>Try to avoid bottom (⊥), so use “safe” versions whenever ⊥ could otherwise be returned (toEnum, index, head etc)</p></li>
<li><p>I’m using <a href="https://github.com/sdiehl/protolude">Stephen Diehl’s Protolude [2]</a> and removing the default prelude</p></li>
</ol>
<p>Using the immutable data structures like Data.Sequence had worked out nicely and means that as the VM runs you can keep a full history of the VM’s state. So you have everything (apart from time) you need to build a nice visualiser / ‘time travelling’ debugger.</p>
<h2 id="the-vm">The VM</h2>
<h3 id="opcodes-byte-code">Opcodes &amp; byte code</h3>
<p>The opcodes are the operations that the virtual CPU can perform. These are simple operations like push, pop, add and jump. The opcodes are encoded as bytes together with the opcode parameters (e.g. the value to push) this forms the byte code.</p>
<p>Here is the current set of opcodes understood by the CPU</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Nop</span>       <span class="co">-- No operation</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">               <span class="fu">|</span> <span class="dt">Halt</span>      <span class="co">-- Stop CPU execution</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">               <span class="fu">|</span> <span class="dt">Push</span>      <span class="co">-- Push a value onto the stack</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">               <span class="fu">|</span> <span class="dt">Pop</span>       <span class="co">-- Pop the most recent value from the stack</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">               <span class="fu">|</span> <span class="dt">PopPrev</span>   <span class="co">-- Pop n values before the most recent value from the stack</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">               <span class="fu">|</span> <span class="dt">Add</span>       <span class="co">-- Add the top two items on the stack</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">               <span class="fu">|</span> <span class="dt">Inc</span>       <span class="co">-- Increment the top item on the stack</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">               <span class="fu">|</span> <span class="dt">Dup</span>       <span class="co">-- Duplicate the most recent item on the stack</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">               <span class="fu">|</span> <span class="dt">Jmp</span>       <span class="co">-- Jump unconditionally to a location</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">               <span class="fu">|</span> <span class="dt">Bne</span>       <span class="co">-- Pop the top two items, compare and branch if the values are not equal</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">               <span class="fu">|</span> <span class="dt">Beq</span>       <span class="co">-- Pop the top two items, compare and branch if the values are equal</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">               <span class="fu">|</span> <span class="dt">Bgt</span>       <span class="co">-- Pop the top two items, compare and branch if value 1 is greater than value 2</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">               <span class="fu">|</span> <span class="dt">Bgte</span>      <span class="co">-- Pop the top two items, compare and branch if value 1 is greater or equal to value 2</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">               <span class="fu">|</span> <span class="dt">Blt</span>       <span class="co">-- Pop the top two items, compare and branch if value 1 is less than value 2</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">               <span class="fu">|</span> <span class="dt">Blte</span>      <span class="co">-- Pop the top two items, compare and branch if value 1 is less than or equal to value 2</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">               <span class="fu">|</span> <span class="dt">Call</span>      <span class="co">-- Call a function</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">               <span class="fu">|</span> <span class="dt">Ret</span>       <span class="co">-- Return from a function</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">               <span class="fu">|</span> <span class="dt">LdArg</span>     <span class="co">-- Push local value n onto the stack</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">               <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>)</a></code></pre></div>
<h3 id="the-virtual-cpu">The virtual CPU</h3>
<p>The data structure representing the CPU is defined below</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cpu</span> <span class="fu">=</span> <span class="dt">Cpu</span> {<span class="ot"> ip ::</span> <span class="dt">Int</span>               <span class="co">-- Instruction pointer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">               ,<span class="ot"> fp ::</span> <span class="dt">Int</span>               <span class="co">-- Frame pointer</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">               ,<span class="ot"> cpuStack ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span>   <span class="co">-- The stack</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">               ,<span class="ot"> cpuGlobals ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="co">-- Gloal variables</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">               ,<span class="ot"> ranOp ::</span> <span class="dt">Int</span>            <span class="co">-- The last opcode that was executed</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">               ,<span class="ot"> state ::</span> <span class="dt">Text</span>           <span class="co">-- Debugging message</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">               ,<span class="ot"> debug ::</span> <span class="dt">Bool</span>           <span class="co">-- Enable/disable debugging</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">               ,<span class="ot"> panic ::</span> <span class="dt">Bool</span>           <span class="co">-- Is the CPU in a faulted state</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">               }</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">         <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11"></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">-- | Default empty/initial CPU state</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="ot">emptyCpu ::</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">emptyCpu <span class="fu">=</span> <span class="dt">Cpu</span> { ip <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">               , fp <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">               , cpuStack <span class="fu">=</span> S.empty</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">               , cpuGlobals <span class="fu">=</span> S.empty</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">               , state <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">               , debug <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">               , ranOp <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">               , panic <span class="fu">=</span> <span class="dt">False</span> </a>
<a class="sourceLine" id="cb2-22" data-line-number="22">               }</a></code></pre></div>
<p>This is fairly minimal but it’s more than enough for a simple VM like this.</p>
<p>Some things to note</p>
<ul>
<li>The stack (cpuStack) is part of the CPU. This makes sense for a stack machine since a stack is core to everything it does. It also means that as the CPU runs you get a full history of each stack state along with the CPU flags at the time each opcode was run</li>
<li>There is no need for a stack pointer since the stack is a ‘dynamically’ growing Data.Sequence. I.e. sp always points to the head of cpuStack.</li>
<li>The instruction pointer (ip) points to the next instruction to run.</li>
<li>In this implementation the byte stream is fixed (no self-modifying code), so there is no need to copy it on each CPU operation</li>
<li>The frame pointer (fp) is discussed below in the section about function calls (Call &amp; Ret)</li>
</ul>
<h3 id="the-byte-code-assembler">The byte code assembler</h3>
<p>Rather than writing the byte code in hex a very simple assembler is used. Later on additional assemblers and compliers can be layer on top of this low level assembler which does little more than convert opcode mnemonics to byte code.</p>
<p>An operation can take parameters from the byte code stream. For instance a <strong><em>push</em></strong> instruction takes a parameter that is the value to push onto the stack. The type that represents this is the inventively named <strong><em>OpAndParam</em></strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- | A single CPU operator and its parameters</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">type</span> <span class="dt">OpAndParam</span> <span class="fu">=</span> (<span class="dt">Operation</span>, [<span class="dt">Int</span>])</a></code></pre></div>
<p>Having a type that defines the number of parameters an op takes and how many values it pops off the stack allows the assembler to perform some basic checks. The interpreter can also use this definition when running the code.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- | Configuration for an operation</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- | opParamCount = number of paramaters taken from the code stream</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">-- | opPopsCount = number of values this op pops from the stack</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">-- | opSimple = determines if the op needs full access to cpu state to change things like the fp and ip</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">-- |            note that &#39;complex&#39; instructions do not need to honour opParamCount and opPopsCount</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">-- |            e.g. a &#39;ret&#39; instruction pops a variable number of parameters</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Instruction</span> <span class="fu">=</span> <span class="dt">Instruction</span> {<span class="ot"> opCode ::</span> <span class="dt">Operation</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">                               ,<span class="ot"> opPopsCount ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">                               ,<span class="ot"> opParamCount ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">                               ,<span class="ot"> opSimple ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">                               }</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">                 <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a></code></pre></div>
<p>The instructions can then be setup and a map created from opcode to Instruction</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- | Config for the op codes</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">instructions ::</span> [<span class="dt">Instruction</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">instructions <span class="fu">=</span> [ <span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Nop</span>, opParamCount <span class="fu">=</span> <span class="dv">0</span>, opPopsCount <span class="fu">=</span> <span class="dv">0</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">                <span class="co">-- ...</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">               , <span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Call</span>, opParamCount <span class="fu">=</span> <span class="dv">1</span>, opPopsCount <span class="fu">=</span> <span class="dv">0</span>, opSimple <span class="fu">=</span> <span class="dt">False</span> }</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">               ]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="co">-- | Instructions indexed by opcode</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">instrByOp ::</span> <span class="dt">Map.Map</span> <span class="dt">Operation</span> <span class="dt">Instruction</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">instrByOp <span class="fu">=</span> Map.fromList <span class="fu">$</span> map (\i <span class="ot">-&gt;</span> (opCode i, i)) instructions</a></code></pre></div>
<p>The assembler then does nothing more than converting the opcode enum to a byte (an Int in the code but it would be serialised as a byte) checking the number of parameters for each opcode. It is small enough to be pasted in full here</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- | A single assembler error</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">data</span> <span class="dt">AssemblerError</span> <span class="fu">=</span> <span class="dt">AssemblerError</span> <span class="dt">Integer</span> <span class="dt">Operation</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">-- | Compiles the list to byte code</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="co">-- | Returns as many errors as possible rather than just first error</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">assembleByteCode ::</span> [(<span class="dt">Operation</span>, [<span class="dt">Int</span>])] <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">AssemblerError</span>] [<span class="dt">Int</span>]	</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">assembleByteCode code <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">let</span> res <span class="fu">=</span> foldl assemble [] code <span class="kw">in</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">case</span> lefts res <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    [] <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="fu">$</span> concat <span class="fu">$</span> rights res</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    errors <span class="ot">-&gt;</span> <span class="dt">Left</span> errors</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"><span class="ot">    assemble ::</span> [<span class="dt">Either</span> <span class="dt">AssemblerError</span> [<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">OpAndParam</span> <span class="ot">-&gt;</span> [<span class="dt">Either</span> <span class="dt">AssemblerError</span> [<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    assemble res (op, prms) <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">      res <span class="fu">++</span> <span class="kw">case</span> Map.lookup op instrByOp <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">               <span class="dt">Nothing</span> <span class="ot">-&gt;</span> [<span class="dt">Left</span> <span class="fu">$</span> <span class="dt">AssemblerError</span> (toInteger <span class="fu">$</span> length res) op <span class="st">&quot;unknown op code&quot;</span>]</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">               <span class="dt">Just</span> i <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">                 <span class="kw">if</span> opParamCount i <span class="fu">==</span> length prms</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">                 <span class="kw">then</span> [<span class="dt">Right</span> <span class="fu">$</span> fromEnum (opCode i) <span class="fu">:</span> prms]</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">                 <span class="kw">else</span> [<span class="dt">Left</span> <span class="fu">$</span> <span class="dt">AssemblerError</span> (toInteger <span class="fu">$</span> length res) op <span class="st">&quot;incorrect number of parameters&quot;</span>]</a></code></pre></div>
<h3 id="the-interpreter">The interpreter</h3>
<p>With all of that in place the interpreter can finally be written.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">-- | Interpreter for the byte code</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">-- | Given a byte code stream will &#39;run&#39; the code</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co">-- | If debug is enabled then the full history (all states) will be returned. </span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="ot">interpretByteCode ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Cpu</span>]</a></code></pre></div>
<p>The interpreter takes the output of the assembler or bytes loaded from a file and runs it producing CPU state along the way. In debug mode the interpreter stores all the states as it interprets, in “non-debug” mode only the last state is kept. <em>Note that currently the interpreter is always in debug mode</em></p>
<p>Before looking at the implementation of the interpreter its worth going over a few examples of how it should operate</p>
<h5 id="push-pop">Push &amp; Pop</h5>
<div class="sourceCode" id="cb8"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb8-1" data-line-number="1">                                                  +--------+</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">                          +--------+              |  123   |</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">   +--------+             |  123   |              |  456   |</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">   +--------+    push 123 +--------+    push 456  +--------+</a></code></pre></div>
<p>In the first example the value 123 is pushed onto an empty stack. Then the value 456 is pushed. The head of the stack is at the “bottom”</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb9-1" data-line-number="1">  +--------+             </a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  |  123   |        +--------+</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  |  456   |        |  123   |</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  +--------+    pop +--------+</a></code></pre></div>
<p>A <strong><em>pop</em></strong> is the opposite of a <strong><em>push</em></strong>. The pop operation get the most recent value from the stack (FIFO) in this case 456 leaving 123 on the stack.</p>
<h5 id="add">Add</h5>
<p>An <strong><em>add</em></strong> operation pops the top two items from the stack, adds them and pushes the result back onto the stack</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb10-1" data-line-number="1">           +--------+             </a>
<a class="sourceLine" id="cb10-2" data-line-number="2">           |  100   |        +--------+</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">push 100   |  123   |        |  223   |</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">push 123   +--------+    add +--------+</a></code></pre></div>
<p>Look at the definition of the instructions for these three operators</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Push</span>, opParamCount <span class="fu">=</span> <span class="dv">1</span>, opPopsCount <span class="fu">=</span> <span class="dv">0</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Pop</span>, opParamCount <span class="fu">=</span> <span class="dv">0</span>, opPopsCount <span class="fu">=</span> <span class="dv">1</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="dt">Instruction</span> { opCode <span class="fu">=</span> <span class="dt">Add</span>, opParamCount <span class="fu">=</span> <span class="dv">0</span>, opPopsCount <span class="fu">=</span> <span class="dv">2</span>, opSimple <span class="fu">=</span> <span class="dt">True</span> }</a></code></pre></div>
<p>From this you can see that the <strong><em>Instruction</em></strong> shows that a <strong><em>push</em></strong> takes one parameter, a <strong><em>pop</em></strong> takes no parameters but pops a single value off the stack and an <strong><em>Add</em></strong> pops two values off the stack. As noted in the code comments <strong><em>opSimple</em></strong> indicates that these are simple operators with fixed stack effects.</p>
<h5 id="jmp">Jmp</h5>
<p>The <strong><em>Jmp</em></strong> operator performs an unconditional jump to a fixed location relative to the start of the code stream. I.e. <strong><em>Jmp 100</em></strong> sets the instruction pointer to 100 and execution continues from there.</p>
<p>Consider the following simple list of ops in Haskel</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"> [ (<span class="dt">Jmp</span>, [<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"> , (<span class="dt">Nop</span>, [])</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"> , (<span class="dt">Halt</span>, [])</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"> ]</a></code></pre></div>
<p>This gets assembled into the following byte code</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">00: </span>0903  -- Jmp 3</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="fu">02: </span>00    -- Nop</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="fu">03: </span>02    -- Halt</a></code></pre></div>
<p>The Jmp instruction causes the CPU to set the instruction pointer (ip) to 3. In this example that means that the <strong><em>Nop</em></strong> at offset 2 is skipped and execution continues with the <strong><em>Halt</em></strong> operation at offset 3</p>
<h5 id="branching-beq-bne-blr-blte-bgt-bgte">Branching (Beq, Bne, Blr, Blte, Bgt, Bgte)</h5>
<p>Branching is a conditional jump. The top two values are popped off the stack compared based on the type of conditional operator.</p>
<p>In the following example the values 1 and to are pushed. <strong><em>Bgt</em></strong> is executed and if 2 is greater than 1 then the CPU jumps to location 7. If no then it continues executing at the location after the branch (6)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"> [ (<span class="dt">Push</span>, [<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"> , (<span class="dt">Push</span>, [<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"> , (<span class="dt">Bgt</span>, [<span class="dv">7</span>])</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"> , (<span class="dt">Nop</span>, [])</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"> , (<span class="dt">Halt</span>, [])</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"> ]</a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">00: </span>0301  -- Push 1</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="fu">02: </span>0302  -- Push 2</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="fu">04: </span>0C07  -- Bgt 7</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="fu">06: </span>00    -- Nop</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="fu">07: </span>02    -- Halt</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb16-1" data-line-number="1">         +--------+             </a>
<a class="sourceLine" id="cb16-2" data-line-number="2">         |   1    |        +--------+</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">push 1   |   2    |        |        |</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">push 2   +--------+    Bgt +--------+</a></code></pre></div>
<p>This is what the history of the CPU would look like for the above example</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">Cpu</span> {ip <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">0</span>,  state <span class="fu">=</span> <span class="st">&quot;&quot;</span>,     panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">1</span>, cpuStack <span class="fu">=</span>   [<span class="dv">1</span>], ranOp <span class="fu">=</span> <span class="dv">3</span>,  state <span class="fu">=</span> <span class="st">&quot;Push&quot;</span>, panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">3</span>, cpuStack <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">1</span>], ranOp <span class="fu">=</span> <span class="dv">3</span>,  state <span class="fu">=</span> <span class="st">&quot;Push&quot;</span>, panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">5</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">12</span>, state <span class="fu">=</span> <span class="st">&quot;Bgt&quot;</span>,  panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">6</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">0</span>,  state <span class="fu">=</span> <span class="st">&quot;Nop&quot;</span>,  panic <span class="fu">=</span> <span class="dt">False</span>}</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="dt">Cpu</span> {ip <span class="fu">=</span>  <span class="dv">7</span>, cpuStack <span class="fu">=</span>    [], ranOp <span class="fu">=</span> <span class="dv">2</span>,  state <span class="fu">=</span> <span class="st">&quot;Halt&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span>}</a></code></pre></div>
<h5 id="call-ret">Call &amp; Ret</h5>
<p>A function call is much like a jmp except that you have to store an address to return to. You could have two stacks, one for values and one for return address. It’s more common however to have a single stack with “stack frames”.</p>
<p>As a trivial example consider a the case when there are no parameters</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="fu">00: </span>1003  -- Call 03</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="fu">02: </span>02    -- Halt</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="fu">03: </span>00    -- Nop</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="fu">04: </span>11    -- Ret</a></code></pre></div>
<p>The CPU does the following</p>
<ul>
<li>Executes the <strong><em>call</em></strong> operation and pushes the return address onto the stack, i.e. the next instruction after the <strong><em>call</em></strong>. Here it is the <strong><em>halt</em></strong> at 02.</li>
<li>The ip is set to 03, the offset of the function, and the CPU executes the function (<strong><em>nop</em></strong>)</li>
<li>The <strong><em>ret</em></strong> operation gets the return address (02) from the stack and updates the ip</li>
<li>The <strong><em>halt</em></strong> at 02 is executed.</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb19-1" data-line-number="1">         +--------+        </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">         |   02   |        +--------+</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">Call 03  +--------+    Ret +--------+</a></code></pre></div>
<p>However this simple scheme does not work when you have variable numbers of parameters, locals etc. This is where the frame pointer (fp) and stack frames come in.</p>
<p>A stack frame is the set of data stored on the stack for each method call. In this virtual machine that is 1. The return address 2. Parameters for the function 3. The previous frame pointer value</p>
<p>As an example consider a function that adds two numbers and returns the sum.</p>
<ul>
<li>The caller pushes the two values to be added (123 and 22), these are pushed in reverse order. I.e. parameter 1 last.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb20-1" data-line-number="1">   00: 0322  -- Push 22    +--------+ ip = 4</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">__ 02: 037b  -- Push 123   |   22   | fp = -1</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">   06: 0502  -- PopPrev 2  +--------+</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">   08: 02    -- Halt   </a>
<a class="sourceLine" id="cb20-6" data-line-number="6">   09: 1202  -- LdArd 2</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">   0b: 1201  -- LdArg 1</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">   0c: 06    -- Add    </a>
<a class="sourceLine" id="cb20-9" data-line-number="9">   0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>The current frame pointer (-1) is stored. If no function has been called this will be -1. Further down in the example this will make more sense</li>
<li>The return address (06) is pushed onto the stack</li>
<li>The frame pointer is set to the start of the stack frame (02), i.e. position 2 from the end of the stack</li>
<li>The CPU sets the instruction pointer and “jumps” to the function (09) being called.</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb21-1" data-line-number="1">   00: 0322  -- Push 22    +--------+ ip = 0b</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">   02: 037b  -- Push 123   |   22   | fp = 2</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">   06: 0502  -- PopPrev 2  |   -1   |</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">   08: 02    -- Halt       |    6   | &lt;-- fp</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">   09: 1202  -- LdArd 2    |   22   | </a>
<a class="sourceLine" id="cb21-7" data-line-number="7">__ 0b: 1201  -- LdArg 1    |  123   |</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">   0c: 06    -- Add        +--------+</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">   0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>The function can then push any values it needs onto the stack and do its work.</li>
<li>Here the function loads the two arguments <strong><em>LdArg 1</em></strong> and <strong><em>LdArg 2</em></strong> (i.e. get params to top of stack) and then calls <strong><em>Add</em></strong> to add them</li>
<li>In this VM a function always returns a single value on the stack</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb22-1" data-line-number="1">   00: 0322  -- Push 22    +--------+ ip = 0c</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">   02: 037b  -- Push 123   |   22   | fp = 2</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">   06: 0502  -- PopPrev 2  |   -1   |</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">   08: 02    -- Halt       |    6   | &lt;-- fp</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">   09: 1202  -- LdArd 2    |  145   | </a>
<a class="sourceLine" id="cb22-7" data-line-number="7">   0b: 1201  -- LdArg 1    +--------+</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">__ 0c: 06    -- Add        </a>
<a class="sourceLine" id="cb22-9" data-line-number="9">   0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>Then when a <strong><em>ret</em></strong> operation is executed the CPU needs to do the reverse.</li>
<li>The return value is popped, and the stack shifted back to the fp</li>
<li>Notice that the original parameters are still on the stack. This is normal for the cdecl calling convention. The caller is responsible for cleaning up.</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb23-1" data-line-number="1">   00: 0322  -- Push 22    +--------+ ip = 06</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">   02: 037b  -- Push 123   |   22   | fp = -1</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">   04: 1003  -- Call 09    |  123   |</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">   06: 0502  -- PopPrev 2  |  145   | </a>
<a class="sourceLine" id="cb23-5" data-line-number="5">   08: 02    -- Halt       +--------+</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">   09: 1202  -- LdArd 2    </a>
<a class="sourceLine" id="cb23-7" data-line-number="7">   0b: 1201  -- LdArg 1    </a>
<a class="sourceLine" id="cb23-8" data-line-number="8">   0c: 06    -- Add        </a>
<a class="sourceLine" id="cb23-9" data-line-number="9">__ 0d: 11    -- Ret</a></code></pre></div>
<ul>
<li>The <strong><em>PopPrev</em></strong> operation is used to do the parameter clean-up by the caller. It pops the number of items specified before the item at the top of the stack</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb24-1" data-line-number="1">   00: 0322  -- Push 22    +--------+ ip = 08</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">   02: 037b  -- Push 123   |   145  | fp = -1</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">   04: 1003  -- Call 09    +--------+</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">__ 06: 0502  -- PopPrev 2  </a>
<a class="sourceLine" id="cb24-5" data-line-number="5">   08: 02    -- Halt       </a>
<a class="sourceLine" id="cb24-6" data-line-number="6">   09: 1202  -- LdArd 2    </a>
<a class="sourceLine" id="cb24-7" data-line-number="7">   0b: 1201  -- LdArg 1    </a>
<a class="sourceLine" id="cb24-8" data-line-number="8">   0c: 06    -- Add        </a>
<a class="sourceLine" id="cb24-9" data-line-number="9">   0d: 11    -- Ret</a></code></pre></div>
<p>The important thing to notice is that since the old frame pointer is stored on the stack you are able to call multiple functions and always be able to return to the previous function. Also having the fp lets you unwind the stack to the frame no matter how many items the current function may have pushed onto the stack, i.e. you don’t need to try and track that</p>
<p>Here is the output for the code above</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode email"><code class="sourceCode email"><a class="sourceLine" id="cb25-1" data-line-number="1">{ip = -1, fp = -1, cpuStack = [],                   ranOp =  0, state = &quot;&quot;,        panic = False}</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">{ip =  1, fp = -1, cpuStack = [22],                 ranOp =  3, state = &quot;Push&quot;,    panic = False}</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">{ip =  3, fp = -1, cpuStack = [123,22],             ranOp =  3, state = &quot;Push&quot;,    panic = False}</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">{ip =  8, fp =  2, cpuStack = [6,-1,123,22],        ranOp = 16, state = &quot;Call&quot;,    panic = False}</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">{ip = 10, fp =  2, cpuStack = [22,6,-1,123,22],     ranOp = 18, state = &quot;LdArg&quot;,   panic = False}</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">{ip = 12, fp =  2, cpuStack = [123,22,6,-1,123,22], ranOp = 18, state = &quot;LdArg&quot;,   panic = False}</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">{ip = 13, fp =  2, cpuStack = [145,6,-1,123,22],    ranOp =  6, state = &quot;Add&quot;,     panic = False}</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">{ip =  5, fp = -1, cpuStack = [145,123,22],         ranOp = 17, state = &quot;Ret&quot;,     panic = False}</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">{ip =  7, fp = -1, cpuStack = [145],                ranOp =  5, state = &quot;PopPrev&quot;, panic = False}</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">{ip =  8, fp = -1, cpuStack = [145],                ranOp =  2, state = &quot;Halt&quot;,    panic = True}</a></code></pre></div>
<h5 id="the-interpreter-code">The interpreter code</h5>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">-- | Interpreter for the byte code</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="co">-- | Given a byte code stream will run the code</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="ot">interpretByteCode ::</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Cpu</span>]</a></code></pre></div>
<ul>
<li>The interpreter converts a sequence of byte codes into a list of CPUs. Final CPU is the final state</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">  interpret [emptyCpu] byteCode</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">    interpret ::</span> [<span class="dt">Cpu</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Cpu</span>]</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    <span class="co">-- Ensure that this function is not called with an empty CPU list</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    interpret [] _ <span class="fu">=</span> [emptyCpu { state <span class="fu">=</span> <span class="st">&quot;INVALID: no start CPU&quot;</span> }]</a>
<a class="sourceLine" id="cb27-7" data-line-number="7"></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    <span class="co">-- Start interpreting </span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">    interpret cpus<span class="fu">@</span>(cpu<span class="fu">:</span>_) code <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-10" data-line-number="10">      <span class="co">-- Move to next op code</span></a>
<a class="sourceLine" id="cb27-11" data-line-number="11">      <span class="kw">let</span> atIp <span class="fu">=</span> ip cpu <span class="fu">+</span> <span class="dv">1</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12"></a>
<a class="sourceLine" id="cb27-13" data-line-number="13">      <span class="co">-- Try get the code byte at index atIp </span></a>
<a class="sourceLine" id="cb27-14" data-line-number="14">      <span class="kw">case</span> indexMay code atIp <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-15" data-line-number="15">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-16" data-line-number="16">          <span class="co">-- No byte at expected index, return error</span></a>
<a class="sourceLine" id="cb27-17" data-line-number="17">          cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> <span class="dv">0</span>, state <span class="fu">=</span> <span class="st">&quot;INVALID: invalid ip index, reading past end of byte stream&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb27-18" data-line-number="18">          </a>
<a class="sourceLine" id="cb27-19" data-line-number="19">        <span class="dt">Just</span> opByte <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-20" data-line-number="20">          <span class="co">-- Ensure this is a valid opcode</span></a>
<a class="sourceLine" id="cb27-21" data-line-number="21"></a>
<a class="sourceLine" id="cb27-22" data-line-number="22">          <span class="kw">case</span> toEnumMay<span class="ot"> opByte ::</span> <span class="dt">Maybe</span> <span class="dt">Operation</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-23" data-line-number="23">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-24" data-line-number="24">              <span class="co">-- This is not a valid opcode, error</span></a>
<a class="sourceLine" id="cb27-25" data-line-number="25">              cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;INVALID: Unknown op&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb27-26" data-line-number="26"></a>
<a class="sourceLine" id="cb27-27" data-line-number="27">            <span class="dt">Just</span> op <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-28" data-line-number="28">              <span class="co">-- Get the instruction for the op code</span></a>
<a class="sourceLine" id="cb27-29" data-line-number="29">              <span class="kw">case</span> (op, Map.lookup op instrByOp) <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-30" data-line-number="30">                (_, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-31" data-line-number="31">                  <span class="co">-- The byte was an opcode enum but was not configured as an instruction</span></a>
<a class="sourceLine" id="cb27-32" data-line-number="32">                  cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;INVALID: Op not found&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb27-33" data-line-number="33">                  </a></code></pre></div>
<ul>
<li>Start interpreting with an empty CPU</li>
<li>The code does the following checks, to get a valid instruction for the byte</li>
</ul>
<ol type="1">
<li>Check that there is a start CPU</li>
<li>Check that there is an opcode in the sequence at the ip index</li>
<li>Check that the opcode is valid, i.e. belongs to the <strong><em>Operation</em></strong> enum</li>
<li>Check that the opcode is in the instruction map <strong><em>instrByOp</em></strong></li>
</ol>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">                (_, <span class="dt">Just</span> instr) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">                  <span class="co">-- &#39;params&#39; are the bytes from the code stream that are used as parameters for the op, e.g. to be pushed onto stack</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">                  <span class="co">-- get the params from the byte stream into a list</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">                  <span class="kw">let</span> paramsCount <span class="fu">=</span> opParamCount instr <span class="kw">in</span> </a>
<a class="sourceLine" id="cb28-5" data-line-number="5">                  <span class="kw">let</span> params <span class="fu">=</span> S.take paramsCount <span class="fu">$</span> S.drop (atIp <span class="fu">+</span> <span class="dv">1</span>) code <span class="kw">in</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7">                  <span class="co">-- &#39;Pops&#39; are the bytes popped from the stack and used by the current instruction</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">                  <span class="co">-- get the values from the stack into the list</span></a>
<a class="sourceLine" id="cb28-9" data-line-number="9">                  <span class="kw">let</span> popsCount <span class="fu">=</span> opPopsCount instr <span class="kw">in</span> </a>
<a class="sourceLine" id="cb28-10" data-line-number="10">                  <span class="kw">let</span> (pops, remainingStack) <span class="fu">=</span> S.splitAt popsCount <span class="fu">$</span> cpuStack cpu <span class="kw">in</span></a>
<a class="sourceLine" id="cb28-11" data-line-number="11"></a>
<a class="sourceLine" id="cb28-12" data-line-number="12">                  <span class="kw">if</span> S.length params <span class="fu">&gt;</span> paramsCount </a>
<a class="sourceLine" id="cb28-13" data-line-number="13">                  <span class="kw">then</span></a>
<a class="sourceLine" id="cb28-14" data-line-number="14">                    cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;Code underflow&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb28-15" data-line-number="15">                  <span class="kw">else</span></a>
<a class="sourceLine" id="cb28-16" data-line-number="16">                    <span class="kw">if</span> length pops <span class="fu">&lt;</span> popsCount</a>
<a class="sourceLine" id="cb28-17" data-line-number="17">                    <span class="kw">then</span> cpu { ip <span class="fu">=</span> atIp, ranOp <span class="fu">=</span> opByte, state <span class="fu">=</span> <span class="st">&quot;Stack underflow&quot;</span>, panic <span class="fu">=</span> <span class="dt">True</span> } <span class="fu">:</span> cpus</a></code></pre></div>
<ul>
<li>Get the parameter bytes from the code stream. E.g. Push takes a single param, the value to be pushed onto the stack</li>
<li>Pop the required number of values from the stack.</li>
<li>Check that both operations succeed</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">                    <span class="kw">else</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">                      <span class="co">-- Interpret the opcode using the simple/complex interpreter as indicated by the instruction</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">                      <span class="kw">let</span> next <span class="fu">=</span> <span class="kw">if</span> opSimple instr <span class="kw">then</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">                                   <span class="kw">let</span> res <span class="fu">=</span> interpretSimple emptyCpu { ip <span class="fu">=</span> atIp <span class="fu">+</span> paramsCount, state <span class="fu">=</span> show op } op (toList pops) params <span class="kw">in</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5">                                   cpu { ranOp <span class="fu">=</span> opByte</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">                                       , cpuStack <span class="fu">=</span> cpuStack res <span class="fu">&lt;&gt;</span> remainingStack</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">                                       , ip <span class="fu">=</span> ip res</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">                                       , panic <span class="fu">=</span> panic res</a>
<a class="sourceLine" id="cb29-9" data-line-number="9">                                       , state <span class="fu">=</span> state res</a>
<a class="sourceLine" id="cb29-10" data-line-number="10">                                       }</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">                                 <span class="kw">else</span></a>
<a class="sourceLine" id="cb29-12" data-line-number="12">                                   interpretComplex cpu { ip <span class="fu">=</span> atIp <span class="fu">+</span> paramsCount, state <span class="fu">=</span> show op, ranOp <span class="fu">=</span> opByte } op (toList pops) params remainingStack</a>
<a class="sourceLine" id="cb29-13" data-line-number="13">                                  </a>
<a class="sourceLine" id="cb29-14" data-line-number="14">                      <span class="kw">in</span> <span class="kw">if</span> panic next</a>
<a class="sourceLine" id="cb29-15" data-line-number="15">                      <span class="kw">then</span></a>
<a class="sourceLine" id="cb29-16" data-line-number="16">                        <span class="co">-- In panic state, add current CPU and stop executing</span></a>
<a class="sourceLine" id="cb29-17" data-line-number="17">                        next <span class="fu">:</span> cpus</a>
<a class="sourceLine" id="cb29-18" data-line-number="18">                      <span class="kw">else</span></a>
<a class="sourceLine" id="cb29-19" data-line-number="19">                        <span class="co">-- Everything fine, add CPU and interpret nex byte</span></a>
<a class="sourceLine" id="cb29-20" data-line-number="20">                        interpret (next <span class="fu">:</span> cpus) code</a></code></pre></div>
<p>Finally the core interpreter code can be called. Since the params, pops are now stored as lists and all checks performed this code is quite simple.</p>
<ul>
<li>Remember that in this VM there are two types of <strong><em>Instructions</em></strong>; simple and complex. Simple instructions are fully defined by the <strong><em>Instruction</em></strong>. Complex instructions have full control over the CPU</li>
<li>Simple instructions are given an empty CPU and return a CPU with the values that need to be changed. For example simple instructions can not pop extra values or change the fp</li>
<li>Complex instructions are not fully defined by the <strong><em>Instruction</em></strong> and can change the CPU in any way they need to.</li>
</ul>
<h5 id="simple-instructions">Simple instructions</h5>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">    <span class="co">-- | Simple instructions, can not directly change CPU state, e.g. cant set ip/fp and they just return data to be added to stack</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="ot">    interpretSimple ::</span> <span class="dt">Cpu</span> <span class="ot">-&gt;</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    interpretSimple cpu op popped params <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">      <span class="kw">case</span> op <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">        <span class="dt">Nop</span> <span class="ot">-&gt;</span> cpu </a></code></pre></div>
<ul>
<li>Nop just returns the current CPU</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">        <span class="dt">Push</span> <span class="ot">-&gt;</span> cpu { cpuStack <span class="fu">=</span> params }</a></code></pre></div>
<ul>
<li>Push sets the stack (appended with current stack in the interpreter code above)</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">        <span class="dt">Pop</span> <span class="ot">-&gt;</span> cpu</a></code></pre></div>
<ul>
<li>Pop also just returns the CPU. This is because as a “simple” instruction the fact that it pops a single value is configured in the <strong><em>Instruction</em></strong> and the interpreter will do that.</li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">        <span class="dt">Bne</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">        <span class="dt">Beq</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">        <span class="dt">Bgt</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">        <span class="dt">Bgte</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&gt;=</span>)</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">        <span class="dt">Blt</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&lt;</span>)</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">        <span class="dt">Blte</span> <span class="ot">-&gt;</span> branchIf cpu popped params (<span class="fu">&lt;=</span>)</a></code></pre></div>
<ul>
<li>The branch instructions call the <strong><em>branchIf</em></strong> function with the appropriate conditional operator</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">    <span class="co">-- | Perform a branch instruction if the predicate for the op (beq, bne, bgte etc) is true</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="ot">    branchIf ::</span> <span class="dt">Cpu</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    branchIf cpu popped params prd <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">      <span class="kw">case</span> head params <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> cpu { panic <span class="fu">=</span> <span class="dt">True</span>, state <span class="fu">=</span> <span class="st">&quot;missing param&quot;</span> }</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">        <span class="dt">Just</span> jmp <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7">          <span class="kw">case</span> popped <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">            [b, a] <span class="ot">-&gt;</span> cpu { ip <span class="fu">=</span> <span class="kw">if</span> prd a b <span class="kw">then</span> ip cpu <span class="fu">+</span> jmp <span class="kw">else</span> ip cpu } </a>
<a class="sourceLine" id="cb34-9" data-line-number="9">            _ <span class="ot">-&gt;</span> cpu { panic <span class="fu">=</span> <span class="dt">True</span>, state <span class="fu">=</span> <span class="st">&quot;invalid stack&quot;</span> }</a></code></pre></div>
<ul>
<li>The branch checks the predicate (prd) and if it is True the ip is updated to the ip specified by the branch.</li>
</ul>
<h5 id="complex-instructions">Complex Instructions</h5>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">    <span class="co">-- | Complex instructions have full access to the CPU and must ensure the CPU is correctly setup for the next instruction</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="ot">    interpretComplex ::</span> <span class="dt">Cpu</span> <span class="ot">-&gt;</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Seq</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cpu</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    interpretComplex cpu op popped params remainingStack <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">      <span class="kw">case</span> op <span class="kw">of</span></a></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">        <span class="dt">Call</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">          <span class="co">-- Set up a stack frame and jump to the call location. See the comments above for details of the stack frame</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">          singleVal cpu (toList params) (\v <span class="ot">-&gt;</span> cpu { ip <span class="fu">=</span> v <span class="fu">-</span> <span class="dv">1</span> <span class="co">-- 1 byte before method, next loop increments to function start byte</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4">                                                   , fp <span class="fu">=</span> S.length remainingStack <span class="co">-- frame pointer points to start of new stack frame</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5">                                                   , cpuStack <span class="fu">=</span> S.fromList [ip cpu <span class="fu">+</span> <span class="dv">1</span>, fp cpu] <span class="fu">&lt;&gt;</span> remainingStack <span class="co">-- add return ip and current fp to stack</span></a>
<a class="sourceLine" id="cb36-6" data-line-number="6">                                                   }) <span class="st">&quot;&quot;</span></a></code></pre></div>
<ul>
<li>Call creates a new CPU, setting the ip, fp and stack frame as discussed above in the section about Call &amp; Ret</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1">        <span class="dt">Ret</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">          <span class="co">-- Return to the calling code, get the previous frame pointer (fp) and return address from the current stack frame.</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">          <span class="co">-- A ret always &#39;returns&#39; a single value, the last item on the stack </span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4">          <span class="kw">let</span> stackAtFp <span class="fu">=</span> S.drop (S.length remainingStack <span class="fu">-</span> fp cpu <span class="fu">-</span> <span class="dv">2</span>) remainingStack <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">          <span class="kw">let</span> (retParams, retStack) <span class="fu">=</span> S.splitAt <span class="dv">2</span> stackAtFp <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">          <span class="kw">if</span> S.length retParams <span class="fu">==</span> <span class="dv">2</span> <span class="kw">then</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">            <span class="kw">let</span> [retIp, retFp] <span class="fu">=</span> toList retParams <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-8" data-line-number="8">            cpu { cpuStack <span class="fu">=</span> S.fromList popped <span class="fu">&lt;&gt;</span> retStack</a>
<a class="sourceLine" id="cb37-9" data-line-number="9">                , ip <span class="fu">=</span> retIp <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb37-10" data-line-number="10">                , fp <span class="fu">=</span> retFp</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">                }</a>
<a class="sourceLine" id="cb37-12" data-line-number="12">          <span class="kw">else</span></a>
<a class="sourceLine" id="cb37-13" data-line-number="13">            cpu { panic <span class="fu">=</span> <span class="dt">True</span>, state <span class="fu">=</span> <span class="st">&quot;Stack underflow getting return frame&quot;</span> }            </a></code></pre></div>
<ul>
<li>Ret gets the old fp and the return address from the stack frame and constructs the new CPU to return to the caller.</li>
</ul>
<h2 id="whats-next">What’s next?</h2>
<p>This explanation of the stack machine is significantly longer than the code for it :). Hopefully you’ll be able to see how easy creating a simple stack machine is. There are many things than can be built on top of this. E.g.</p>
<ul>
<li>A higher level assembler with support for labels, i.e. don’t make the user count offsets</li>
<li>A simple higher level language that generates this new assembler code. E.g. stack/concatenative language or a functional language</li>
<li>Many more operators<br />
</li>
<li>Code optimisation</li>
<li>Support for globals</li>
<li>IO</li>
<li>…..</li>
</ul>
<h2 id="links">Links</h2>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Stack_machine" class="uri">https://en.wikipedia.org/wiki/Stack_machine</a></li>
<li><a href="https://github.com/sdiehl/protolude" class="uri">https://github.com/sdiehl/protolude</a></li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=OjaAToVkoTw" class="uri">https://www.youtube.com/watch?v=OjaAToVkoTw</a></li>
</ul>

]]></summary>
</entry>
<entry>
    <title>Central Config - Multi-Machine .net Configuration Manager</title>
    <link href="http://www.andrevdm.com/posts/2015-12-15-central-config.html" />
    <id>http://www.andrevdm.com/posts/2015-12-15-central-config.html</id>
    <published>2015-12-15T00:00:00Z</published>
    <updated>2015-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December 15, 2015
    
</div>

<p>CentralConfig is available on NuGet, source at <a href="https://github.com/andrevdm/CentralConfig" class="uri">https://github.com/andrevdm/CentralConfig</a></p>
<h2 id="overview">Overview</h2>
<p>CentralConfig is a replacement for the built in .net ConfigurationManager. It makes managing multi-machine configurations simple while, from a usability point of view, looking very similar to ConfigurationManager.</p>
<h2 id="features">Features</h2>
<ul>
<li>All config must be able to be stored in version control</li>
<li>A way to have config centralised. I.e. you should not have to update the same setting on multiple machines.</li>
<li>Support for multiple environments (dev, build, test, prod etc)</li>
<li>A sane and simple way of having default values. You should not have to specify the same settings for each machine if a default will work.</li>
<li>Override a setting for a particular machine. e.g. one machine in an environment must have a slightly different config.</li>
<li>Simple and light weight</li>
<li>Support for simple values as well as more complex object types</li>
<li>A full replacement for ConfigManager</li>
</ul>
<h2 id="what-about-the-.net-config-transformer">What about the .net config transformer</h2>
<p>The .net transformer does a reasonable job but did not quite do everything I required. The examples below should show some of the differences</p>
<h2 id="using-centralconfig">Using CentralConfig</h2>
<p>Install “CentralConfig” from nuget Unless you have created a custom persistor use the mongo settings persistor Set the central config mongo settings Setup DI</p>
<h3 id="app.settings-for-the-mongo-persistor">app.settings for the mongo persistor</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb1-1" data-line-number="1">   <span class="kw">&lt;appSettings&gt;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">     <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;MongoDB.Server&quot;</span><span class="ot"> value=</span><span class="st">&quot;mongodb://localhost:27017&quot;</span> <span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">     <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;CentralConfig.MongoDatabase&quot;</span><span class="ot"> value=</span><span class="st">&quot;TestConfig&quot;</span> <span class="kw">/&gt;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">   <span class="kw">&lt;/appSettings&gt;</span></a></code></pre></div>
<h3 id="di-setup">DI setup</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode cs"><code class="sourceCode cs"><a class="sourceLine" id="cb2-1" data-line-number="1">       ObjectFactory.<span class="fu">Configure</span>( x =&gt;</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">       {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">           x.<span class="fu">For</span>().<span class="fu">Use</span>();</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">           x.<span class="fu">For</span>().<span class="fu">Use</span>();</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">       } );</a></code></pre></div>
<h3 id="configure-settings-in-mongo">Configure settings in Mongo</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cs"><code class="sourceCode cs"><a class="sourceLine" id="cb3-1" data-line-number="1">       {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">           <span class="st">&quot;key&quot;</span> : <span class="st">&quot;TestSetting&quot;</span>,</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">           <span class="st">&quot;machine&quot;</span> : <span class="kw">null</span>,</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">           <span class="st">&quot;value&quot;</span> : <span class="st">&quot;some value&quot;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">       }</a></code></pre></div>
<h3 id="use-the-setting-from-code">Use the setting from code</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode cs"><code class="sourceCode cs"><a class="sourceLine" id="cb4-1" data-line-number="1">       Console.<span class="fu">WriteLine</span>( <span class="st">&quot;test: {0}&quot;</span>, ConfigManager.<span class="fu">AppSettings</span>[<span class="st">&quot;TestSetting&quot;</span>] );</a></code></pre></div>
<h2 id="different-persistors">Different Persistors</h2>
<p>I’ve always used the mongo persistor but you can easily create new persistors as required. To do so implement the IPersistor interface</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cs"><code class="sourceCode cs"><a class="sourceLine" id="cb5-1" data-line-number="1">        <span class="kw">public</span> <span class="kw">interface</span> IConfigPersistor</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">        {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">            <span class="dt">string</span> <span class="fu">ReadAppSetting</span>( <span class="dt">string</span> key, <span class="dt">string</span> machine, <span class="dt">long</span> version );</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">            <span class="dt">string</span> <span class="fu">ReadAppSetting</span>( <span class="dt">string</span> key, <span class="dt">string</span> machine );</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">            <span class="dt">string</span> <span class="fu">ReadAppSetting</span>( <span class="dt">string</span> key, <span class="dt">long</span> version );</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">            <span class="dt">string</span> <span class="fu">ReadAppSetting</span>( <span class="dt">string</span> key );</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">            TResult <span class="fu">GetSection</span>( <span class="dt">string</span> sectionName, <span class="dt">string</span> machine, <span class="dt">long</span> version );</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">            TResult <span class="fu">GetSection</span>( <span class="dt">string</span> sectionName, <span class="dt">string</span> machine );</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">            TResult <span class="fu">GetSection</span>( <span class="dt">string</span> sectionName, <span class="dt">long</span> version );</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">            TResult <span class="fu">GetSection</span>( <span class="dt">string</span> sectionName );</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        }</a></code></pre></div>
<h2 id="order-of-matching">Order of matching</h2>
<p>When you request a value, CentralConfig will try find the most specific value it can. So it will first look for the setting match both the key and the current machine name, if that does not match then it looks for a value matching on key only</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb6-1" data-line-number="1">       <span class="fu">{</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">           <span class="dt">&quot;key&quot;</span> <span class="fu">:</span> <span class="st">&quot;TestSetting&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">           <span class="dt">&quot;machine&quot;</span> <span class="fu">:</span> <span class="kw">null</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">           <span class="dt">&quot;value&quot;</span> <span class="fu">:</span> <span class="st">&quot;some value&quot;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">       <span class="fu">}</span><span class="er">,</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">       <span class="fu">{</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">           <span class="dt">&quot;key&quot;</span> <span class="fu">:</span> <span class="st">&quot;TestSetting&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">           <span class="dt">&quot;machine&quot;</span> <span class="fu">:</span> <span class="st">&quot;MYPC&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">           <span class="dt">&quot;value&quot;</span> <span class="fu">:</span> <span class="st">&quot;another value&quot;</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">       <span class="fu">}</span></a></code></pre></div>
<p>Given the mongo settings above when you request “TestSetting” you will get “another value” if your machine name is MYPC or “some value otherwise”</p>

]]></summary>
</entry>

</feed>
